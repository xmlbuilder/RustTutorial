# Coons Patch Builder

- ÏÇ¨Í∞Å Í≤ΩÍ≥Ñ(ÎÑ§ Í∞úÏùò Í≥°ÏÑ† ÎòêÎäî Ìè¥Î¶¨ÎùºÏù∏)Î°ú ÎëòÎü¨Ïã∏Ïù∏ ÏòÅÏó≠ÏùÑ ÎÇ¥Î∂ÄÎ°ú Îß§ÎÅÑÎüΩÍ≤å Î≥¥Í∞ÑÌïòÎäî **Coons Î≥¥Í∞Ñ(CoÃÇons Patch / Transfinite Interpolation)** Ïùò  
  ÏàòÌïôÏ†Å ÏöîÏïΩÍ≥º, Ïù¥Î•º Ïú†Ìïú Í≤©Ïûê(mesh)Î°ú Íµ¨ÌòÑÌïòÎäî Ï†àÏ∞®Î•º Ï†ïÎ¶¨Ìïú Î¨∏ÏÑúÏûÖÎãàÎã§.

---

## 1) Î¨∏Ï†ú ÏÑ§Ï†ï

ÏÇ¨Í∞ÅÌòï Í≤ΩÍ≥ÑÎ•º Íµ¨ÏÑ±ÌïòÎäî ÎÑ§ Í∞úÏùò Í≤ΩÍ≥Ñ Í≥°ÏÑ†ÏùÑ Îã§ÏùåÍ≥º Í∞ôÏù¥ Îë°ÎãàÎã§. Îß§Í∞úÎ≥ÄÏàòÎäî Ï†ïÍ∑úÌôî Íµ¨Í∞Ñ $[0,1]$ ÏûÖÎãàÎã§.

- ÌïòÎ≥Ä(ÏïÑÎûò): $\mathbf{B}(s),\ s\in[0,1]$‚ÄÉ(left $\to$ right)
- ÏÉÅÎ≥Ä(ÏúÑ): $\mathbf{T}(s),\ s\in[0,1]$‚ÄÉ(left $\to$ right)
- Ï¢åÎ≥Ä: $\mathbf{L}(t),\ t\in[0,1]$‚ÄÉ(bottom $\to$ top)
- Ïö∞Î≥Ä: $\mathbf{R}(t),\ t\in[0,1]$‚ÄÉ(bottom $\to$ top)

ÎÑ§ Î™®ÏÑúÎ¶¨(ÏΩîÎÑà) Ï†êÏùÄ

$$
\begin{aligned}
\mathbf{C}_{00}&=\mathbf{L}(0)=\mathbf{B}(0), &
\mathbf{C}_{10}&=\mathbf{R}(0)=\mathbf{B}(1), \\
\mathbf{C}_{01}&=\mathbf{L}(1)=\mathbf{T}(0), &
\mathbf{C}_{11}&=\mathbf{R}(1)=\mathbf{T}(1).
\end{aligned}
$$

### **Î∞©Ìñ• Í∑úÏïΩ**  
- Î≥∏ Î¨∏ÏÑúÏôÄ Ï†úÍ≥µÎêú Íµ¨ÌòÑÏùÄ **B, TÎäî Ï¢å‚ÜíÏö∞**, **L, RÏùÄ Ìïò‚ÜíÏÉÅ** Î∞©Ìñ•ÏúºÎ°ú Í∞ÄÏ†ïÌï©ÎãàÎã§.    
  Ïù¥ Í∑úÏïΩÏù¥ Ïñ¥Í∏ãÎÇòÎ©¥ ÏΩîÎÑà ÏùºÏπòÍ∞Ä Íπ®ÏßÄÍ≥† Ï†ëÌûò/Íº¨ÏûÑÏù¥ ÏÉùÍ∏∏ Ïàò ÏûàÏúºÎØÄÎ°ú, ÌïÑÏöî Ïãú ÏûÖÎ†•ÏùÑ Îí§ÏßëÏñ¥ ÎßûÏ∂∞Ïïº Ìï©ÎãàÎã§.

---

## 2) Coons Ìå®Ïπò: Transfinite Î≥¥Í∞ÑÏãù

Coons Î≥¥Í∞ÑÏùÄ ‚ÄúÎëê ÏßëÌï©Ïùò ÏÑ†Ìòï Î≥¥Í∞Ñ Ìï©‚ÄùÏóêÏÑú ‚ÄúÏΩîÎÑàÏùò bilinear Ï§ëÎ≥µ‚ÄùÏùÑ Ï†úÍ±∞ÌïòÏó¨ ÎÇ¥Î∂ÄÎ•º Ï†ïÏùòÌï©ÎãàÎã§.

### 2.1 ÌòºÌï©(blending) Íµ¨ÏÑ±ÏöîÏÜå

- **ÏàòÌèâ Î≥¥Í∞Ñ(ÏÉÅ¬∑Ìïò Í≤ΩÍ≥Ñ):**

$$
  \mathbf{S}(s,t)=(1-t) \mathbf{B}(s)+t \mathbf{T}(s)
$$

- **ÏàòÏßÅ Î≥¥Í∞Ñ(Ï¢å¬∑Ïö∞ Í≤ΩÍ≥Ñ):**

$$
  \mathbf{T r}(s,t)=(1-s) \mathbf{L}(t)+s \mathbf{R}(t)
$$

- **Ï§ëÎ≥µ Î≥¥Ï†ï(ÏΩîÎÑàÏùò bilinear):**
$$
  \mathbf{B l}(s,t)=
  (1-s)(1-t) \mathbf{C}_{00}
  + s(1-t) \mathbf{C}_{10}
  + (1-s)t \mathbf{C}_{01}
  + st \mathbf{C}_{11}
$$

### 2.2 Coons Ìå®Ïπò Ï†ïÏùò

$$
\boxed{
\mathbf{C}(s,t)=\mathbf{S}(s,t)+\mathbf{T r}(s,t)-\mathbf{B l}(s,t)
}
$$

Ïù¥ ÏãùÏùÄ Í≤ΩÍ≥ÑÏóêÏÑú Ï†ïÌôïÌûà Í≤ΩÍ≥Ñ Í≥°ÏÑ†ÏùÑ Ïû¨ÌòÑÌï©ÎãàÎã§. ÏòàÎ•º Îì§Ïñ¥ $t=0$ Ïù¥Î©¥
$\mathbf{C}(s,0)=\mathbf{B}(s)$, $s=1$ Ïù¥Î©¥ $\mathbf{C}(1,t)=\mathbf{R}(t)$ Îì±.

> **ÏßÅÍ¥Ä**  
> $\mathbf{S}$ ÏôÄ $\mathbf{T r}$ ÏùÑ Îã®Ïàú Ìï©ÌïòÎ©¥ ÏΩîÎÑàÍ∞Ä **Îëê Î≤à** ÎçîÌï¥ÏßëÎãàÎã§. $\mathbf{B l}$ ÏùÄ Ï†ïÌôïÌûà Í∑∏ Ï§ëÎ≥µÏùÑ Ï†úÍ±∞ÌïòÎäî **bilinear Î≥¥Ï†ï**ÏûÖÎãàÎã§.

---

## 3) Ïù¥ÏÇ∞Ìôî(Î©îÏãú ÏÉùÏÑ±)

Ïã§ÏÇ¨Ïö©ÏóêÏÑúÎäî ÎÇ¥Î∂ÄÎ•º Í≤©Ïûê ÏÉòÌîåÎ°ú Ïù¥ÏÇ∞ÌôîÌïòÏó¨ Ï†ïÏ†ê/Î©¥ÏùÑ ÎßåÎì≠ÎãàÎã§.

### 3.1 ÌååÎùºÎØ∏ÌÑ∞ ÏÉòÌîå

Ï†ïÏàò Ìï¥ÏÉÅÎèÑ $\(N_u, N_v \ge 2\)$ Î•º Ï†ïÌïòÍ≥†,

$$
s_i = \frac{i}{N_u-1}\quad (i=0,\dots,N_u-1),\qquad
t_j = \frac{j}{N_v-1}\quad (j=0,\dots,N_v-1).
$$

Í∞Å Í≤©ÏûêÏ†êÏùò 3D ÏúÑÏπòÎäî

$$
\mathbf{P}_{ij}=\mathbf{C}(s_i,t_j)
$$

Î°ú Í≥ÑÏÇ∞Ìï©ÎãàÎã§.

### 3.2 ÏΩîÎÑà Í∞ïÏ†ú ÏùºÏπò

Ïã§Ï†ú Í≤ΩÍ≥Ñ ÏûÖÎ†•Ïù¥ ÏôÑÎ≤ΩÌûà ÏùºÏπòÌïòÏßÄ ÏïäÏùÑ Ïàò ÏûàÏäµÎãàÎã§(ÏàòÏπò Ïò§Ï∞®, Îç∞Ïù¥ÌÑ∞ ÎÖ∏Ïù¥Ï¶à Îì±).    
**force-corner-match** ÏòµÏÖòÏùÄ $\mathbf{B},\mathbf{T},\mathbf{L},\mathbf{R}$ Ïùò ÎÅùÏ†êÎì§ÏùÑ  
ùêÇ‚ÇÄ‚ÇÄ, ùêÇ‚ÇÅ‚ÇÄ, ùêÇ‚ÇÄ‚ÇÅ, ùêÇ‚ÇÅ‚ÇÅ Ïóê Ïä§ÎÉÖÏãúÏºú Î™®ÏàúÏùÑ Ï†úÍ±∞Ìï©ÎãàÎã§.

### 3.3 Î©¥ ÏÉùÏÑ±

- **ÏÇ¨Í∞ÅÌòï Î©îÏâ¨(quad mesh):**  
  ÏÖÄ $\((i,j)\)$ ÏóêÏÑú Ï†ïÏ†ê Ïù∏Îç±Ïä§Î•º  

$$
  n_{00}=(i,j),\ n_{10}=(i+1,j),\ n_{11}=(i+1,j+1),\ n_{01}=(i,j+1)
$$

  Î°ú Ïû°Í≥†, Î©¥ÏùÑ $(n_{00},n_{10},n_{11},n_{01})$ ÏàúÏúºÎ°ú ÏÉùÏÑ±Ìï©ÎãàÎã§.

- **ÏÇºÍ∞ÅÌòï Î©îÏâ¨(tri mesh):**  
  Í∞ôÏùÄ ÏÖÄÏùÑ ÏÇºÍ∞ÅÌòï Îëê Ïû•ÏúºÎ°ú ÎÇòÎàïÎãàÎã§. Î∂ÑÌï¥ Ïä§ÌÉÄÏùºÏùÄ ÏÑ∏ Í∞ÄÏßÄÎ•º Ï†úÍ≥µÌï©ÎãàÎã§.
  - **AlignLeft:** $(n_{00},n_{10},n_{01})$, $(n_{10},n_{11},n_{01})$
  - **AlignRight:** $(n_{00},n_{10},n_{11})$, $(n_{00},n_{11},n_{01})$
  - **UnionJack:** Í≤©Ïûê parityÎ•º Î≤àÍ∞àÏïÑ Í∞ÄÎ©∞ Ï¢å/Ïö∞ ÎåÄÍ∞ÅÏÑ†ÏùÑ ÍµêÏ∞® Î∞∞ÏπòÌï¥ Ïû•Í∏∞Ï†ÅÏù∏ Î∞©Ìñ• Ìé∏Ìñ•ÏùÑ Ï§ÑÏûÖÎãàÎã§.

### 3.4 ÎÖ∏Î©Ä/ÌÖçÏä§Ï≤ò Ï¢åÌëú

- **Ï†ïÏ†ê ÎÖ∏Î©Ä:** Í∞Å Î©¥Ïùò Î≤ïÏÑ†ÏùÑ Ïù∏Ï†ë Ï†ïÏ†êÏóê ÎàÑÏ†Å ÌõÑ Ï†ïÍ∑úÌôî(ÎùºÌîåÎùºÏãúÏïà Ïä§Î¨¥Îî© Í≥ÑÏó¥Í≥º Ìò∏Ìôò).
- **ÌÖçÏä§Ï≤ò Ï¢åÌëú:** $(u,v)=(s_i,t_j) \in [0,1]^2$ Î•º Í∑∏ÎåÄÎ°ú Ï†ÄÏû•ÌïòÎ©¥ UV Îß§ÌïëÏù¥ ÏûêÏó∞Ïä§ÎüΩÍ≤å Ï†ïÏÇ¨ÏòÅÎê©ÎãàÎã§.

---

## 4) ÏïÑÌÅ¨Í∏∏Ïù¥(Ìò∏Ïû•) Í∏∞Î∞ò Îß§Í∞úÌôî (ÏÑ†ÌÉù)

Ìè¥Î¶¨ÎùºÏù∏/Í≥°ÏÑ† ÏÉòÌîåÏù¥ **Î∂àÍ∑†Ïùº**ÌïòÎ©¥, Í∑†ÏùºÌïú $s,t$ ÏÉòÌîåÎßåÏúºÎ°úÎäî ÏãúÍ∞ÅÏ†Å ÏôúÍ≥°Ïù¥ ÏûàÏùÑ Ïàò ÏûàÏäµÎãàÎã§.  
Ïù¥Î•º ÏôÑÌôîÌïòÎ†§Î©¥ Í≤ΩÍ≥ÑÏùò ÎàÑÏ†Å Í∏∏Ïù¥Î•º Ï†ïÍ∑úÌôîÌïú **ÏïÑÌÅ¨Í∏∏Ïù¥ ÌååÎùºÎØ∏ÌÑ∞** $\tilde{s}(i),\tilde{t}(j)$ Î•º ÏÇ¨Ïö©Ìï©ÎãàÎã§.

1. Í≤ΩÍ≥Ñ Í∞Å ÏÑ†Î∂Ñ Í∏∏Ïù¥Î•º ÎàÑÏ†ÅÌï¥ $\ell_k$ Î•º ÏñªÍ≥†, Ï†ÑÏ≤¥ Í∏∏Ïù¥Î°ú ÎÇòÎàÑÏñ¥ $[0,1]$ Î°ú Ï†ïÍ∑úÌôîÌï©ÎãàÎã§.
2. Ïù¥ $\tilde{s},\tilde{t}$ Îäî **Í≤ΩÍ≥Ñ ÌååÎùºÎØ∏ÌÑ∞Ïùò Í∏∞Î°ù/Îß§Ìïë Ï†ïÎ≥¥**Î°ú Ïì∞Í±∞ÎÇò, ÌïÑÏöî Ïãú Í≤ΩÍ≥ÑÎ•º Ïû¨ÌëúÎ≥∏(resample)ÌïòÏó¨  
   $s_i, t_j$ Ïóê ÎåÄÏùëÌïòÎäî Ï†êÏùÑ ÏÉàÎ°ú ÏñªÎäî Îç∞ ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.

> Ï†úÍ≥µÎêú Î†àÌçºÎü∞Ïä§ Íµ¨ÌòÑÏùÄ ‚Äú**ÏßÄÏò§Î©îÌä∏Î¶¨Îäî ÏûÖÎ†• ÏÉòÌîå Í∑∏ÎåÄÎ°ú**‚Äù ÎëêÍ≥†, ÎßµÎßå ÏïÑÌÅ¨Í∏∏Ïù¥ Ï∂ïÏ≤ôÏùÑ **Í∏∞Î°ù**ÌïòÎäî ÏÑ†ÌÉùÏßÄÎ•º Ìè¨Ìï®Ìï©ÎãàÎã§.  
> Îçî Í≥†Î•∏ ÎÇ¥Î∂Ä Î∂ÑÌè¨Í∞Ä ÌïÑÏöîÌïòÎ©¥, Í≤ΩÍ≥ÑÎ•º ÏïÑÌÅ¨Í∏∏Ïù¥ Í∑†Îì±ÏúºÎ°ú **Ïû¨ÌëúÎ≥∏**Ìïú ÌõÑ Coons Î≥¥Í∞ÑÏóê Ìà¨ÏûÖÌïòÏÑ∏Ïöî.

---

## 5) ÏàòÏπòÏ†Å Í≥†Î†§ÏÇ¨Ìï≠

- **Ï†ëÌûò/ÏûêÏ≤¥ ÍµêÏ∞®(folding):** Í≤ΩÍ≥ÑÍ∞Ä Ïã¨ÌïòÍ≤å ÎπÑÏÑ†Ìòï¬∑ÏÉÅÌò∏ ÍµêÏ∞®Ïóê Í∞ÄÍπåÏö∞Î©¥ ÎÇ¥Î∂ÄÍ∞Ä Ï†ëÌûê Ïàò ÏûàÏäµÎãàÎã§.  
  *ÎåÄÏùë:* Îçî Ï°∞Î∞ÄÌïú ÏÉòÌîåÎßÅ, Í≤ΩÍ≥Ñ Ïû¨ÌååÎùºÎØ∏ÌÑ∞Ìôî, Î≥¥Í∞Ñ Ïù¥ÌõÑÏùò ÎùºÌîåÎùºÏãúÏïà/ÏúàÏä¨Î°ú(Winslow) Ïä§Î¨¥Îî© Ï†ÅÏö©.
- **Î∞©Ìñ• Î∂àÏùºÏπò:** B/T, L/RÏùò ÏßÑÌñâ Î∞©Ìñ•Ïù¥ Î¨∏ÏÑú Í∑úÏïΩÍ≥º Îã§Î•¥Î©¥ ÏΩîÎÑàÍ∞Ä ÎßûÏßÄ ÏïäÍ±∞ÎÇò Îí§ÌãÄÎ¶ΩÎãàÎã§.  
  *ÎåÄÏùë:* ÏãúÏûë¬∑ÎÅù Ï†êÏùÑ ÎπÑÍµêÌï¥ ÌïÑÏöî Ïãú Í≤ΩÍ≥ÑÎ•º Îí§ÏßëÏñ¥ Î∞©Ìñ•ÏùÑ ÏùºÏπòÏãúÌÇµÎãàÎã§.
- **Ï†ïÏàò Í≤©Ïûê Ìï¥ÏÉÅÎèÑ:** \(N_u,N_v\)Í∞Ä ÎÑàÎ¨¥ ÎÇÆÏúºÎ©¥ Í∞ÅÏßÄÍ≤å Î≥¥Ïù¥Í≥†, ÎÑàÎ¨¥ ÎÜíÏúºÎ©¥ Í≥ÑÏÇ∞/Î©îÎ™®Î¶¨ ÎπÑÏö©Ïù¥ ÌÅΩÎãàÎã§.  
  Ïã§Î¨¥ÏóêÏÑ† Í≥°Î•† Í∏∞Î∞ò Ï†ÅÏùë ÏÉòÌîåÎßÅÏù¥ÎÇò Î©ÄÌã∞Ìï¥ÏÉÅÎèÑ Ï†ëÍ∑ºÏùÑ ÏûêÏ£º ÏÇ¨Ïö©Ìï©ÎãàÎã§.

---

## 6) Íµ¨ÌòÑ Í∞úÏöî (ÏùòÏÇ¨ÏΩîÎìú)

```text
input: bottom[0..Nu-1], top[0..Nu-1], left[0..Nv-1], right[0..Nv-1]
output: vertices[Nu*Nv], faces

C00=left[0],  C01=left[Nv-1]
C10=right[0], C11=right[Nv-1]

for iu in 0..Nu-1:
  s = iu/(Nu-1)
  for iv in 0..Nv-1:
    t = iv/(Nv-1)
    S  = (1-t)*B(s) + t*T(s)                  // ÏàòÌèâ Î≥¥Í∞Ñ
    Tr = (1-s)*L(t) + s*R(t)                  // ÏàòÏßÅ Î≥¥Í∞Ñ
    Bl = (1-s)(1-t)*C00 + s(1-t)*C10
       + (1-s)t*C01  + st*C11                 // bilinear ÏΩîÎÑà Î≥¥Ï†ï
    P(iu,iv) = S + Tr - Bl

// Î©¥ ÏÉùÏÑ±: quad ÎòêÎäî tri(Î∂ÑÌï¥ Ïä§ÌÉÄÏùº ÏÑ†ÌÉù)
```

---

## 7) Rust API ÏòàÏãú (ÏöîÏïΩ)

Ïù¥ Î¨∏ÏÑúÏôÄ Ìï®Íªò Ï†úÍ≥µÎêú Rust Íµ¨ÌòÑÏùò ÌïµÏã¨ ÏãúÍ∑∏ÎãàÏ≤ò:

```rust
pub struct CoonsOptions {
    pub quad_mesh: bool,
    pub tri_style: TriStyle,        // AlignLeft | AlignRight | UnionJack
    pub build_normals: bool,
    pub build_texcoord: bool,       // (u,v) = (s,t)
    pub use_arclen_sampling: bool,  // Í≤ΩÍ≥Ñ ÌååÎùºÎØ∏ÌÑ∞ Í∏∞Î°ùÏö©
    pub force_corner_match: bool,
}

pub fn build_coons_patch_mesh(
    bottom: &[Vec3f], right: &[Vec3f], top: &[Vec3f], left: &[Vec3f],
    opt: &CoonsOptions, want_maps: bool
) -> Result<(Mesh, Option<CoonsBoundaryMaps>), String>;
```

ÏÇ¨Ïö© Ïãú **Í≤ΩÍ≥Ñ Î∞©Ìñ• Í∑úÏïΩ** (B/T Ï¢å‚ÜíÏö∞, L/R Ìïò‚ÜíÏÉÅ)ÏùÑ Î∞òÎìúÏãú ÏßÄÏºúÏïº Ìï®.

---

## 8) Ï∞∏Ï°∞

- S. A. Coons, *Surfaces for Computer-Aided Design of Space Forms*, 1967.  
- J. Hoschek & D. Lasser, *Fundamentals of Computer Aided Geometric Design*, 1993.  
- Piegl & Tiller, *The NURBS Book*, 2nd ed., 1997 ‚Äî Coons Ìå®ÏπòÏôÄ Í¥ÄÎ†®Îêú transfinite interpolation Í∞úÏöî.

---

## 9) Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏

- [ ] Í≤ΩÍ≥Ñ Î∞©Ìñ•(B/T Ï¢å‚ÜíÏö∞, L/R Ìïò‚ÜíÏÉÅ) ÌôïÏù∏/Î≥¥Ï†ï  
- [ ] ÏΩîÎÑà ÏùºÏπò Ïó¨Î∂Ä ÌôïÏù∏(ÌïÑÏöî Ïãú Ïä§ÎÉÖ)  
- [ ] Ï†ÅÏ†àÌïú \(N_u,N_v\) ÏÑ†ÌÉù Î∞è(ÎòêÎäî) ÏïÑÌÅ¨Í∏∏Ïù¥ Í∏∞Î∞ò Ïû¨ÌëúÎ≥∏  
- [ ] ÏøºÎìú/Ìä∏ÎùºÏù¥ Î∂ÑÌï¥ Î∞©Ïãù ÏÑ†ÌÉù(Î†åÎçîÎü¨/ÌõÑÏ≤òÎ¶¨ ÌååÏù¥ÌîÑÎùºÏù∏ Í≥†Î†§)  
- [ ] ÎÖ∏Î©Ä/UV ÏÉùÏÑ± Î∞è Í≤ÄÏ¶ù  
- [ ] Ï†ëÌûò Í≤ÄÏÇ¨(ÏãúÍ∞Å/Î≤ïÏÑ† Î∂ÄÌò∏/ÏûêÏ≤¥ÍµêÏ∞®), ÌïÑÏöî Ïãú Ïä§Î¨¥Îî©/Ïû¨ÌååÎùºÎØ∏ÌÑ∞Ìôî

---

Coons Ìå®ÏπòÎäî Îã®ÏàúÌïú ÏÑ†Ìòï ÌòºÌï©Í≥º bilinear Î≥¥Ï†ïÎßåÏúºÎ°ú **Í≤ΩÍ≥Ñ Ï∂©Ïã§ÎèÑ** Î•º Ïú†ÏßÄÌïòÎ©¥ÏÑú ÎÇ¥Î∂ÄÎ•º Ï±ÑÏõå Ï£ºÎäî Í∞ïÎ†•Ìïú Í∏∞Î≥∏ Î∏îÎ°ùÏûÖÎãàÎã§.  

---

## Ïã§Ï†Ñ ÏΩîÎìú
```rust
use crate::math::prelude::{Point3D, Vector3D};
use crate::mesh::mesh::Mesh;

#[derive(Copy, Clone, Debug, Default, PartialEq)]
pub struct Vec3f { pub x: f32, pub y: f32, pub z: f32 }
impl Vec3f {
    pub fn new(x: f32, y: f32, z: f32) -> Self { Self { x, y, z } }
    pub fn add(self, o: Self) -> Self { Self::new(self.x+o.x, self.y+o.y, self.z+o.z) }
    pub fn sub(self, o: Self) -> Self { Self::new(self.x-o.x, self.y-o.y, self.z-o.z) }
    pub fn mul(self, s: f32) -> Self { Self::new(self.x*s, self.y*s, self.z*s) }
    pub fn dot(self, o: Self) -> f32 { self.x*o.x + self.y*o.y + self.z*o.z }
    pub fn cross(self, o: Self) -> Self {
        Self::new(self.y*o.z - self.z*o.y, self.z*o.x - self.x*o.z, self.x*o.y - self.y*o.x)
    }
    pub fn length(self) -> f32 { self.dot(self).sqrt() }
    pub fn normalize(self) -> Self {
        let l = self.length();
        if l > 0.0 { self.mul(1.0/l) } else { Self::new(0.0,0.0,0.0) }
    }
}

#[derive(Copy, Clone, Debug, Default, PartialEq)]
pub struct Vec2f { pub x: f32, pub y: f32 }
impl Vec2f { pub fn new(x: f32, y: f32) -> Self { Self { x, y } } }



#[derive(Clone, Debug)]
pub struct CoonsMesh {
    pub vertices: Vec<Vec3f>,
    pub faces:     Vec<[u32;4]>,
    pub v_normals: Vec<Vec3f>,
    pub tex_coords: Vec<Vec2f>,
}
impl CoonsMesh {
    pub fn empty() -> Self {
        Self { vertices: vec![], faces: vec![], v_normals: vec![], tex_coords: vec![] }
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum TriStyle { AlignLeft, AlignRight, UnionJack }

#[derive(Copy, Clone, Debug)]
pub struct CoonsOptions {
    pub quad_mesh: bool,            // true Î©¥ quad, false Î©¥ triangle
    pub tri_style: TriStyle,        // ÏÇºÍ∞Å Î∂ÑÌï¥ Î∞©Ïãù
    pub build_normals: bool,        // ÎÖ∏Î©Ä ÏÉùÏÑ±
    pub build_tex_coord: bool,       // (s,t) [0,1]^2 Ï†ÄÏû•
    pub use_arc_len_sampling: bool,  // Í≤ΩÍ≥Ñ ÌååÎùºÎØ∏ÌÑ∞Î•º Ìò∏Ïû• Í∏∞Î∞òÏúºÎ°ú Í∏∞Î°ù(ÏßÄÏò§Î©îÌä∏Î¶¨Ïóî ÏòÅÌñ• X)
    pub force_corner_match: bool,   // ÏΩîÎÑà Ï†ïÌôïÌûà ÏùºÏπò(ÏûÖÎ†•Ïù¥ Ïù¥ÎØ∏ ÎßûÎã§Í≥† Í∞ÄÏ†ï)
}
impl Default for CoonsOptions {
    fn default() -> Self {
        Self {
            quad_mesh: false,
            tri_style: TriStyle::AlignLeft,
            build_normals: true,
            build_tex_coord: true,
            use_arc_len_sampling: false,
            force_corner_match: true,
        }
    }
}

#[derive(Clone, Debug)]
pub struct CoonsBoundaryMaps {
    // Ï†ïÍ∑úÌôîÎêú Í≤ΩÍ≥Ñ UV
    pub s_on_bottom: Vec<f64>, pub s_on_top: Vec<f64>,   // size=Nu
    pub t_on_left:   Vec<f64>, pub t_on_right: Vec<f64>, // size=Nv
    // ÏõêÍ≥°ÏÑ† ÌååÎùºÎØ∏ÌÑ∞(Ìò∏Ïû• Í∏∞Î∞ò ÎòêÎäî Í∑†Îì±)
    pub t_bottom: Vec<f64>, pub t_top: Vec<f64>, // size=Nu
    pub t_left:   Vec<f64>, pub t_right: Vec<f64>, // size=Nv
}


#[inline]
fn grid_idx(iu: usize, iv: usize, nv: usize) -> usize { iu*nv + iv }

fn cumulative_lengths(poly: &[Vec3f]) -> Vec<f64> {
    let n = poly.len();
    let mut acc = vec![0.0_f64; n];
    if n == 0 { return acc; }
    for i in 1..n {
        let d = poly[i].sub(poly[i-1]).length() as f64;
        acc[i] = acc[i-1] + d;
    }
    if acc[n-1] > 0.0 {
        let total = acc[n-1];
        for a in &mut acc[1..] { *a /= total; }
    }
    acc
}

#[inline]
fn push_tri(out: &mut Vec<[u32;4]>, a:u32,b:u32,c:u32) {
    out.push([a,b,c,c]); // STL Ìò∏Ìôò: ÏÇºÍ∞ÅÌòïÏùÄ ÎßàÏßÄÎßâ Ïù∏Îç±Ïä§Î•º cÎ°ú Ï§ëÎ≥µ
}
#[inline]
fn push_quad(out: &mut Vec<[u32;4]>, a:u32,b:u32,c:u32,d:u32) {
    out.push([a,b,c,d]);
}

/// bottom: left->right, top: left->right, left: bottom->top, right: bottom->top
pub fn build_coons_patch_mesh(
    bottom: &[Vec3f],
    right:  &[Vec3f],
    top:    &[Vec3f],
    left:   &[Vec3f],
    opt:    &CoonsOptions,
    want_maps: bool,
) -> Result<(CoonsMesh, Option<CoonsBoundaryMaps>), String> {
    let nu = bottom.len();
    let nv = left.len();
    if nu < 2 || nv < 2 { return Err("Need at least 2 samples for each opposite boundary".into()); }
    if top.len() != nu { return Err("top.size() must equal bottom.size()".into()); }
    if right.len() != nv { return Err("right.size() must equal left.size()".into()); }

    // (ÏÑ†ÌÉù) Í≤ΩÍ≥Ñ Îßµ Íµ¨ÏÑ± ‚Äî Í∏∞Ï°¥ ÏΩîÎìú Ïú†ÏßÄ
    // ... (maps ÎßåÎìúÎäî Î∂ÄÎ∂ÑÏùÄ ÎãπÏã† ÏΩîÎìú Í∑∏ÎåÄÎ°ú ÎëêÏÑ∏Ïöî)
    let maps: Option<CoonsBoundaryMaps> = None; // ÌïÑÏöîÌïòÎ©¥ Í∏∞Ï°¥ Î°úÏßÅ Î∂ôÏù¥ÏÑ∏Ïöî

    // ÏΩîÎÑà
    let c00 = left.first().copied().unwrap();
    let c01 = left.last().copied().unwrap();
    let c10 = right.first().copied().unwrap();
    let c11 = right.last().copied().unwrap();

    // ÎÇ¥Î∂Ä Ï†ïÏ†ê
    let v_count = nu*nv;
    let mut mesh = CoonsMesh { vertices: Vec::with_capacity(v_count), faces: Vec::new(),
        v_normals: Vec::new(), tex_coords: Vec::new() };

    if opt.build_tex_coord {
        mesh.tex_coords.reserve(v_count);
    }

    for iu in 0..nu {
        let s = if nu==1 { 0.0 } else { iu as f32 / (nu-1) as f32 };
        for iv in 0..nv {
            let t = if nv==1 { 0.0 } else { iv as f32 / (nv-1) as f32 };

            // Í≤ΩÍ≥Ñ ÌëúÎ≥∏
            let l = left[iv];    // L(t)
            let r = right[iv];   // R(t)
            let b = bottom[iu];  // B(s)
            let tp= top[iu];     // T(s)

            // Coons: sum - surplus
            let sum = l.mul(1.0 - s).add(r.mul(s)).add(b.mul(1.0 - t)).add(tp.mul(t));
            let s00 = c00.mul((1.0 - s) * (1.0 - t));
            let s01 = c01.mul((1.0 - s) * t);
            let s10 = c10.mul( s * (1.0 - t));
            let s11 = c11.mul( s * t);

            mesh.vertices.push(Vec3f::new(
                sum.x - (s00.x + s01.x + s10.x + s11.x),
                sum.y - (s00.y + s01.y + s10.y + s11.y),
                sum.z - (s00.z + s01.z + s10.z + s11.z),
            ));
            if opt.build_tex_coord {
                mesh.tex_coords.push(Vec2f{ x:s, y:t });
            }
        }
    }

    // Î©¥ ÏÉùÏÑ± ‚Äî Ïó¨Í∏∞Îßå Ï†ÑÎ©¥ ÍµêÏ≤¥
    let fq = (nu - 1) * (nv - 1);
    mesh.faces = Vec::with_capacity(if opt.quad_mesh { fq } else { fq * 2 });

    for iu in 1..nu {
        for iv in 1..nv {
            let n00 = grid_idx(iu-1, iv-1, nv) as u32;
            let n10 = grid_idx(iu,   iv-1, nv) as u32;
            let n11 = grid_idx(iu,   iv,   nv) as u32;
            let n01 = grid_idx(iu-1, iv,   nv) as u32;

            if opt.quad_mesh {
                push_quad(&mut mesh.faces, n00, n10, n11, n01);
            } else {
                match opt.tri_style {
                    TriStyle::AlignRight => {
                        push_tri(&mut mesh.faces, n00, n10, n11);
                        push_tri(&mut mesh.faces, n00, n11, n01);
                    }
                    TriStyle::UnionJack => {
                        let flip = (iu & 1) == (iv & 1);
                        if !flip {
                            push_tri(&mut mesh.faces, n00, n10, n01);
                            push_tri(&mut mesh.faces, n10, n11, n01);
                        } else {
                            push_tri(&mut mesh.faces, n00, n10, n11);
                            push_tri(&mut mesh.faces, n00, n11, n01);
                        }
                    }
                    TriStyle::AlignLeft => {
                        push_tri(&mut mesh.faces, n00, n10, n01);
                        push_tri(&mut mesh.faces, n10, n11, n01);
                    }
                }
            }
        }
    }
    // ÎÖ∏Î©Ä Îì±ÏùÄ ÌïÑÏöîÏãú Î≥ÑÎèÑ Í≥ÑÏÇ∞(ÎãπÏã† ÌîÑÎ°úÏ†ùÌä∏Ïùò recompute_normals ÏÇ¨Ïö©)
    // if opt.build_normals { recompute_normals_for_coons(&mut mesh); }
    Ok((mesh, maps))
}

/* --------------------------- Ïú†Ìã∏: ÎÖ∏Î©Ä --------------------------- */

fn face_normal(a:Vec3f,b:Vec3f,c:Vec3f)->Vec3f {
    (b.sub(a)).cross(c.sub(a)).normalize()
}
pub fn recompute_normals(mesh: &mut CoonsMesh) {
    let n = mesh.vertices.len();
    mesh.v_normals.clear();
    mesh.v_normals.resize(n, Vec3f::new(0.0, 0.0, 0.0));
    for f in &mesh.faces {
        if f[2] == f[3] {
            let (a,b,c) = (f[0] as usize, f[1] as usize, f[2] as usize);
            let nrm = face_normal(mesh.vertices[a], mesh.vertices[b], mesh.vertices[c]);
            for &vi in &[a,b,c] { mesh.v_normals[vi] = mesh.v_normals[vi].add(nrm); }
        } else {
            let (a,b,c,d) = (f[0] as usize, f[1] as usize, f[2] as usize, f[3] as usize);
            let n1 = face_normal(mesh.vertices[a], mesh.vertices[b], mesh.vertices[c]);
            let n2 = face_normal(mesh.vertices[a], mesh.vertices[c], mesh.vertices[d]);
            for &vi in &[a,b,c] { mesh.v_normals[vi] = mesh.v_normals[vi].add(n1); }
            for &vi in &[a,c,d] { mesh.v_normals[vi] = mesh.v_normals[vi].add(n2); }
        }
    }
    for v in &mut mesh.v_normals { *v = v.normalize(); }
}

pub fn coons_into_mesh(cm: &CoonsMesh) -> Mesh {
    let vertices: Vec<Point3D> = cm.vertices.iter().map(|v| Point3D {
        x: v.x as f64, y: v.y as f64, z: v.z as f64
    }).collect();

    let faces = cm.faces.clone(); // ÎèôÏùº ÌòïÏãù [u32;4]

    let normals = if !cm.v_normals.is_empty() {
        Some(cm.v_normals.iter().map(|n| Vector3D {
            x: n.x as f64, y: n.y as f64, z: n.z as f64
        }).collect())
    } else {
        None
    };

    Mesh { vertices, faces, normals }
}
```

## ÌÖåÏä§Ìä∏ ÏΩîÎìú
```rust
#[cfg(test)]
mod tests {
    use std::fs;
    use std::path::Path;
    use geometry::io::stl_writer::StlWriter;
    use geometry::mesh::coons_patch::{build_coons_patch_mesh, coons_into_mesh, CoonsMesh, CoonsOptions, TriStyle, Vec3f};
    use geometry::mesh::mesh::Mesh;

    #[test]
    fn coons_quad_and_tri_ok() {
        // Ï∂ï Ï†ïÎ†¨ ÏÇ¨Í∞Å Í≤ΩÍ≥Ñ(Ï†ïÏÇ¨Í∞ÅÌòï): bottom/ top (left->right), left/right (bottom->top)
        let n = 8usize;
        let mut bottom = Vec::with_capacity(n);
        let mut top    = Vec::with_capacity(n);
        for i in 0..n {
            let s = i as f32 / (n-1) as f32;
            bottom.push(Vec3f::new(-1.0 + 2.0*s, -1.0, 0.0));
            top.push(Vec3f::new(-1.0 + 2.0*s,  1.0, 0.0));
        }
        let mut left  = Vec::with_capacity(n);
        let mut right = Vec::with_capacity(n);
        for j in 0..n {
            let t = j as f32 / (n-1) as f32;
            left.push (Vec3f::new(-1.0, -1.0 + 2.0*t, 0.0));
            right.push(Vec3f::new( 1.0, -1.0 + 2.0*t, 0.0));
        }

        // Quad mesh
        let (mesh_q, maps_q) = build_coons_patch_mesh(
            &bottom, &right, &top, &left,
            &CoonsOptions{ quad_mesh:true, ..Default::default() },
            true
        ).unwrap();
        assert_eq!(mesh_q.vertices.len(), n*n);
        assert!(!mesh_q.faces.is_empty());
        assert!(maps_q.is_some());

        // Tri mesh (UnionJack)
        let (mesh_t, _) = build_coons_patch_mesh(
            &bottom, &right, &top, &left,
            &CoonsOptions{ quad_mesh:false, tri_style:TriStyle::UnionJack, ..Default::default() },
            false
        ).unwrap();
        assert_eq!(mesh_t.vertices.len(), n*n);
        assert!(mesh_t.faces.len() > mesh_q.faces.len()); // ÏÇºÍ∞Å Î∂ÑÌï†Ïù¥ Îçî ÎßéÏùå
    }


    fn lerp(a: Vec3f, b: Vec3f, t: f32) -> Vec3f {
        Vec3f { x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t, z: a.z + (b.z - a.z) * t }
    }

    /// Coons PatchÏùò ÎÑ§ Í≤ΩÍ≥Ñ Í≥°ÏÑ†ÏùÑ ÏÉòÌîåÎßÅÌï¥ÏÑú Î∞òÌôòÌï©ÎãàÎã§.
    /// - bottom: left -> right
    /// - top   : left -> right
    /// - left  : bottom -> top
    /// - right : bottom -> top
    fn build_example_boundaries(nu: usize, nv: usize) -> (Vec<Vec3f>, Vec<Vec3f>, Vec<Vec3f>, Vec<Vec3f>) {
        // ÏÇ¨Í∞Å ÏòÅÏó≠Ïùò ÎÑ§ Î™®ÏÑúÎ¶¨
        let p00 = Vec3f { x: 0.0, y: 0.0, z: 0.0 }; // left-bottom
        let p10 = Vec3f { x: 1.0, y: 0.0, z: 0.0 }; // right-bottom
        let p01 = Vec3f { x: 0.0, y: 1.0, z: 0.0 }; // left-top
        let p11 = Vec3f { x: 1.0, y: 1.0, z: 0.0 }; // right-top

        // ÏïÑÎûò/ÏúÑ Í≤ΩÍ≥Ñ: xÎ∞©Ìñ•ÏúºÎ°ú ÏßÑÌñâ
        let mut bottom = Vec::with_capacity(nu);
        let mut top    = Vec::with_capacity(nu);

        for i in 0..nu {
            let s = if nu <= 1 { 0.0 } else { i as f32 / (nu as f32 - 1.0) };
            let mut b = lerp(p00, p10, s);
            let mut t = lerp(p01, p11, s);

            // ÏïΩÍ∞ÑÏùò Íµ¥Í≥°ÏùÑ Ï§òÏÑú 3D ÎäêÎÇå
            t.z = 0.2 * (std::f32::consts::PI * s).sin();

            bottom.push(b);
            top.push(t);
        }

        // Ïôº/Ïò§ Í≤ΩÍ≥Ñ: y Î∞©Ìñ•ÏúºÎ°ú ÏßÑÌñâ
        let mut left  = Vec::with_capacity(nv);
        let mut right = Vec::with_capacity(nv);

        for j in 0..nv {
            let t = if nv <= 1 { 0.0 } else { j as f32 / (nv as f32 - 1.0) };
            let mut l = lerp(p00, p01, t);
            let mut r = lerp(p10, p11, t);

            // Ïò§Î•∏Ï™Ω Í≤ΩÍ≥ÑÏóêÎèÑ Íµ¥Í≥°
            r.z = 0.15 * (std::f32::consts::PI * t).sin();

            left.push(l);
            right.push(r);
        }

        (bottom, right, top, left)
    }

    #[test]
    fn coons_patch_export_to_stl() -> Result<(), Box<dyn std::error::Error>> {
        // ÏÉòÌîå Ìï¥ÏÉÅÎèÑ(Í≤ΩÍ≥Ñ Ìè¨Ïù∏Ìä∏ Í∞úÏàò)
        let nu = 64;
        let nv = 48;

        let (bottom, right, top, left) = build_example_boundaries(nu, nv);

        // Coons ÏòµÏÖò: STLÏùÑ ÏúÑÌï¥ ÏÇºÍ∞ÅÌòï Î©îÏâ¨Í∞Ä Ìé∏ÌïòÎØÄÎ°ú quad_mesh=false
        let mut opt = CoonsOptions::default();
        opt.quad_mesh = false;                   // ÏÇºÍ∞ÅÌòïÏúºÎ°ú ÏÉùÏÑ±
        opt.tri_style = TriStyle::AlignLeft;     // ÏÇºÍ∞Å Î∂ÑÌï† Î∞©Ïãù
        opt.build_normals = true;
        opt.build_tex_coord = true;

        // Ìå®Ïπò ÏÉùÏÑ±
        let (coons_mesh, _maps) = build_coons_patch_mesh(&bottom, &right, &top, &left, &opt, true)
            .expect("Failed to build Coons patch mesh");

        let mesh = coons_into_mesh(&coons_mesh) ;

        // Ï∂úÎ†• Ìè¥Îçî
        let out_dir = Path::new("target/tmp");
        fs::create_dir_all(out_dir)?;

        let ascii_path = out_dir.join("coons_patch_ascii.stl");
        let bin_path   = out_dir.join("coons_patch_binary.stl");

        // ASCII STL
        {
            let mut writer = StlWriter::new(ascii_path.to_str().unwrap(), false)?;
            writer.run_ascii(&mesh)?;
        }

        // Binary STL
        {
            let mut writer = StlWriter::new(bin_path.to_str().unwrap(), true)?;
            writer.run_binary(&mesh)?;
        }

        // Í∞ÑÎã®Ìïú Í≤ÄÏ¶ù: ÌååÏùºÏù¥ ÏÉùÏÑ±ÎêòÏóàÍ≥† 0Î∞îÏù¥Ìä∏Í∞Ä ÏïÑÎãåÏßÄ
        let ascii_meta = fs::metadata(&ascii_path)?;
        let bin_meta   = fs::metadata(&bin_path)?;
        assert!(ascii_meta.len() > 0, "ASCII STL is empty");
        assert!(bin_meta.len() > 84, "Binary STL should be > 84 bytes (header + count)");

        Ok(())
    }
}

```


