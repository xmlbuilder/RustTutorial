# Parameter
Rust에서 **매개변수(parameter)** 가 있는 함수 선언은 함수의 유연성과 재사용성을 높이는 핵심 기능.

## 🧠 매개변수가 있는 함수란?
함수에 입력값을 전달할 수 있도록 정의된 변수들이 바로 매개변수입니다.  
Rust에서는 매개변수의 이름과 타입을 명시적으로 선언해야 해요.

### ✅ 기본 문법
```rust
fn 함수이름(매개변수1: 타입, 매개변수2: 타입, ...) {
    // 함수 본문
}
```

### 🔍 예제 분석

### 1. 단일 매개변수 함수
```rust
fn main() {
    print_number(12);
}

fn print_number(x: i32) {
    println!("x = {x}");
}
```

- print_number 함수는 i32 타입의 정수 하나를 받아 출력합니다.
- x는 함수 내부에서 사용할 수 있는 지역 변수입니다.

### 2. 다중 매개변수 함수
```rust
fn main() {
    add_numbers(12, 13);
}

fn add_numbers(x: i32, y: i32) {
    let sum = x + y;
    println!("x + y = {sum}");
}
```

- add_numbers는 두 개의 i32 값을 받아 합을 계산하고 출력합니다.
- 매개변수는 쉼표로 구분하며, 각각 타입을 명시해야 합니다.

## 📦 Rust 함수의 특징

| 항목             | 설명                                                                 |
|------------------|----------------------------------------------------------------------|
| 함수 선언 키워드 | `fn` 키워드를 사용하여 함수 선언                                     |
| 매개변수         | `이름: 타입` 형식으로 명시하며, 여러 개일 경우 쉼표로 구분           |
| 반환값           | `-> 타입` 형식으로 명시하며, `return` 또는 표현식으로 반환 가능       |
| main 함수        | 프로그램의 진입점이며, 반드시 있어야 실행 가능                        |
| 타입 명시        | 모든 매개변수와 반환값은 타입을 명시해야 하며, 타입 추론은 불가능     |
| 위치 유연성      | 함수 정의는 `main` 함수보다 앞이나 뒤에 있어도 호출 가능              |
| 표현식 기반      | 함수 본문은 표현식으로 구성되며, 마지막 줄의 값이 자동으로 반환될 수 있음 |
| 재사용성         | 매개변수를 통해 다양한 입력을 받아 재사용 가능                        |

---

# Reference

값을 직접 전달하는 방식 외에도, **참조(reference)** 를 통해 값을 빌려서 전달할 수 있음.  
이걸 **빌림(borrowing)** 이라고 하며, 소유권을 넘기지 않고도 데이터를 함수에 전달할 수 있는 아주 중요한 개념입니다.

## 🔁 값 전달 vs 참조 전달
| 구분           | 설명                                                                 |
|----------------|----------------------------------------------------------------------|
| 값 전달        | 변수의 값을 복사하여 함수에 전달. 소유권이 이동하거나 복사됨         |
| 참조 전달 `&`  | 변수의 주소를 전달. 소유권은 유지되며, 함수는 읽기만 가능             |
| 가변 참조 `&mut` | 변수의 주소를 전달하되, 함수에서 값을 수정할 수 있음. 단일 가변 참조만 허용 |


## ✅ 예제: 참조 전달
```rust
fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1); // 참조 전달
    println!("The length of '{s1}' is {len}.");
}

fn calculate_length(s: &String) -> usize {
    s.len() // 참조된 값 사용
}
```

- &s1은 s1의 참조를 함수에 전달합니다.
- calculate_length는 String의 소유권을 받지 않고, 참조만 사용합니다.
- 따라서 s1은 main 함수에서 계속 사용할 수 있어요.

### ⚠️ 주의: 가변 참조는 `&mut` 필요
```rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s); // 가변 참조 전달
    println!("{s}");
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

- `&mut s` 를 통해 가변 참조를 전달하면 함수에서 값을 수정할 수 있음.
- 단, 가변 참조는 `한 번에 하나만 허용` 되므로, 동시에 여러 참조를 만들면 컴파일 오류가 발생합니다.

---

## Rust와 C++ 비교

Rust와 C++ 모두 함수 인자로 **참조(reference)** 를 전달할 수 있지만,  
두 언어는 메모리 안전성, 소유권 모델, 가변성 제어 방식이 다르기 때문에 그 의미와 사용법도 꽤 다릅니다.

## 🧭 기본 개념 비교: C++ vs Rust 함수 인자 참조
| 개념             | C++                          | Rust                          |
|------------------|-------------------------------|-------------------------------|
| 참조 문법        | `T&`, `const T&`              | `&T`, `&mut T`                |
| 가변성 제어      | `const` 키워드로 제어         | 타입 수준에서 `&` / `&mut`로 구분 |
| 소유권 개념      | 없음                          | 있음 (`ownership`, `borrowing`) |
| 라이프타임 개념  | 없음                          | 있음 (`'a` 등으로 명시 또는 추론) |
| 안전성           | 개발자 책임                   | 컴파일러가 강제 검사 (safe by default) |


## 🧪 예시 비교
### C++ 예시
```cpp
void printName(const std::string& name) {
    std::cout << name << std::endl;
}
```

- const std::string&는 복사 없이 참조만 전달.
- const를 붙여서 함수 내에서 수정하지 않겠다는 의도 표현.
- 하지만 const_cast로 강제 수정도 가능 → 위험!

### Rust 예시
```rust
fn print_name(name: &String) {
    println!("{}", name);
}
```

- &String은 불변 참조.
- 함수 내에서 name을 수정할 수 없음.
- &mut String을 쓰면 가변 참조로 변경 가능.

## 🔐 Rust의 안전성: Borrow Checker
Rust는 borrow checker를 통해 다음을 강제합니다:
- 하나의 &mut 가변 참조만 허용
- 여러 개의 & 불변 참조는 허용
- 불변 참조와 가변 참조는 동시에 불가
이 덕분에 **데이터 경쟁(race condition)** 이나 dangling pointer가 발생하지 않아요.

## 🧠 라이프타임(Lifetime)의 차이
Rust에서는 참조가 얼마나 오래 살아야 하는지를 명시해야 할 때가 있음:
```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```

- 'a는 두 참조가 같은 라이프타임을 가져야 함을 의미.
- C++에서는 이런 개념이 없고, dangling reference는 런타임 오류로 이어질 수 있음.

## 🧩 정리: C++ vs Rust 참조 방식
| 개념             | C++                      | Rust                      |
|------------------|---------------------------|---------------------------|
| 참조 문법        | `T&`, `const T&`          | `&T`, `&mut T`            |
| 가변성 제어      | `const` 키워드            | 타입 수준에서 `&` / `&mut` |
| 소유권 개념      | 없음                      | 있음 (`ownership`)        |
| 라이프타임 개념  | 없음                      | 있음 (`'a`)               |
| 안전성           | 개발자 책임               | 컴파일러가 강제 검사       |

---



