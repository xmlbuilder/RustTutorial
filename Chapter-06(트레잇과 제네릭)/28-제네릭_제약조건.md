# Generic 제약 조건
Rust의 Generic 제약 조건(Trait Bounds)은 제네릭 타입이 특정 기능을 갖도록 제한하는 규칙입니다.    
이를 통해 타입 안정성과 코드 재사용성을 높일 수 있습니다.


## ✅ std::ops::Add<Output = T>의 의미
```rust
T: std::ops::Add<Output = T>
```
`std::ops::Add<Output = T>` 를 명시하는 건 단순히 + 연산을 쓰기 위해서만이 아니라,  
타입 안전성과 제네릭 연산 가능성을 확보하는 핵심적인 제약 조건.

- T 타입은 + 연산이 가능해야 함
- T + T의 결과가 다시 T여야 함
예를 들어 i32, f64, u8 같은 기본 숫자 타입은 이 trait을 만족합니다.

## 🎯 왜 필요한가?
### 1️⃣ + 연산을 컴파일 타임에 허용하기 위해
- Rust는 제네릭 타입에 대해 연산자 오버로드를 자동으로 허용하지 않음
- +를 쓰려면 Add trait을 명시적으로 요구해야 함
```rust
self.coords[0] + other.coords[0] // ← 이 줄을 쓰려면 반드시 Add trait 필요
```

### 2️⃣ 다양한 타입에 대해 재사용 가능
- Point<i32>, Point<f64>, Point<u8> 등 다양한 숫자 타입에 대해 add()를 사용할 수 있음
- 제네릭으로 구현되었기 때문에 코드 중복 없이 범용적으로 동작

### 3️⃣ Output = T 제약으로 타입 안정성 확보
- Add trait은 기본적으로 Output이 다른 타입일 수도 있음
```rust
impl Add<u32> for i32 {
    type Output = i32;
}
```

- Output = T를 명시하면 T + T → T가 보장됨
- 예외적인 타입 변환을 방지하고 예측 가능한 결과 타입을 유지

## ✅ 전체 제약 조건 요약
```rust
impl<T: Copy + std::ops::Add<Output = T>> Point<T>
```

| 제약       | 의미                          |
|------------|-------------------------------|
| Copy       | 값 복사가 가능해야 함         |
| Add        | `+` 연산이 가능해야 함        |
| Output = T | `T + T`의 결과가 다시 `T`여야 함 |


## 🔍 예시로 보면
```rust
impl<T: Copy + std::ops::Add<Output = T>> Point<T> {
    pub fn add(&self, other: &Self) -> Self {
        Point {
            coords: [
                self.coords[0] + other.coords[0],
                self.coords[1] + other.coords[1],
            ],
        }
    }
}
```

- Copy → self.coords[0] 같은 값 복사가 안전하게 가능해야 함
- Add → + 연산을 사용할 수 있어야 함
- Output = T → T + T의 결과가 T여야 coords 배열에 다시 넣을 수 있음

---

## 🧠 Generic 제약 조건이란?
Rust에서 제네릭은 다양한 타입에 대해 유연하게 코드를 작성할 수 있게 해줍니다.  
하지만 모든 타입이 모든 연산이나 메서드를 지원하는 것은 아니기 때문에,  
Trait Bounds를 통해 "이 타입은 이런 기능을 갖고 있어야 한다"는 제약을 걸 수 있습니다.  

### 예시:
```rust
fn double<T: std::ops::Add<Output = T>>(x: T) -> T {
    x + x
}
```
- T는 + 연산이 가능해야 하며, 결과도 T여야 함

## 🔧 주요 Trait Bound 예시
| 제약 조건               | 의미             |
|------------------------|------------------|
| T: Copy                | T 복사 가능       |
| T: Clone               | T.clone() 가능    |
| T: PartialEq           | T == / != 비교 가능 |
| T: PartialOrd          | T < / > 비교 가능 |
| T: std::fmt::Display   | T 출력 가능 `{}`  |
| T: std::ops::Add       | T + T 연산 가능   |

## 🔍 보충 설명
- Copy와 Clone은 값 복사 방식이 다름 (Copy는 암묵적, Clone은 명시적)
- PartialEq, PartialOrd는 비교 연산자 사용을 가능하게 함
- Display는 println!("{:?}")이 아닌 println!("{}", T)에 필요
- Add는 + 연산을 허용하며, Output = T 제약을 함께 쓰면 결과 타입도 고정 가능

## 🧩 여러 Trait Bound 조합
```rust
fn print_and_compare<T: std::fmt::Display + PartialOrd>(a: T, b: T) {
    if a > b {
        println!("{} is greater than {}", a, b);
    }
}
```

- T는 출력 가능하고 비교도 가능해야 함

## ✍️ Trait Bound 작성 방식
### 1️⃣ 인라인 방식
```rust
fn process<T: Clone + Copy>(item: T) { ... }
```

### 2️⃣ where 절 방식 (가독성 ↑)
```rust
fn process<T>(item: T)
where
    T: Clone + Copy,
{ ... }
```


## 🧠 왜 중요한가?
- 컴파일 타임에 타입 안정성 확보
- 불필요한 런타임 오류 방지
- 재사용 가능한 범용 함수/구조체 작성 가능
- Trait 기반으로 메서드, 연산자, 포맷 등을 안전하게 사용 가능

--- 

# Rust의 고급 제네릭 제약 패턴

## 🔹 1. T: Trait<AssocType = U> → 연관 타입 제약
```rust
trait Transformer {
    type Output;
    fn transform(&self) -> Self::Output;
}

fn apply<T: Transformer<Output = String>>(item: T) {
    let result: String = item.transform();
    println!("{}", result);
}
```
- Transformer 트레잇은 연관 타입 Output을 가짐
- T는 Transformer를 구현하고, 그 Output이 반드시 String이어야 함

## 🔹 2. impl<T: Trait> Struct<T> → 구조체에 제약
```rust
use std::fmt::Display;

struct Wrapper<T: Display> {
    value: T,
}

impl<T: Display> Wrapper<T> {
    fn show(&self) {
        println!("Value: {}", self.value);
    }
}
```

- Wrapper<T>는 T가 Display를 구현해야만 사용 가능
- 구조체 정의와 impl 블록 모두에 제약을 걸 수 있음

## 🔹 3. fn f<T>() where T: Trait → 함수에 제약
```rust
fn print_twice<T>(item: T)
where
    T: std::fmt::Display,
{
    println!("{}", item);
    println!("{}", item);
}
```

- where 절을 사용하면 제약 조건을 더 깔끔하게 분리 가능
- 특히 제약이 여러 개일 때 가독성이 좋아짐

## 🔹 4. trait A where Self: Trait → 트레잇 내부 제약
```rust
trait Printable: std::fmt::Display {
    fn print(&self) {
        println!("{}", self);
    }
}
```
## 또는
``` rust
trait Printable where Self: std::fmt::Display {
    fn print(&self) {
        println!("{}", self);
    }
}
```
- Printable을 구현하려면 Display도 구현되어 있어야 함
- 트레잇 내부에서 Self에 제약을 걸어 기능을 제한


---

