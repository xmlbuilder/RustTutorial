# Borrow<T>

Borrow<T>를 사용하는 방식과 &T를 직접 함수 인자로 받는 방식은 표면적으로 비슷해 보이지만,
유연성, 추론, 성능, 명확성 측면에서 꽤 중요한 차이가 있어요.

## 🔍 두 방식 비교
| 방식        | 함수 시그니처                                      | 장점                                                   | 단점                                                   |
|-------------|---------------------------------------------------|--------------------------------------------------------|--------------------------------------------------------|
| `&T`        | `fn dot(a: &Vector3D, b: &Vector3D)`              | - 명확하고 직관적<br>- 성능 최적화<br>- IDE 지원 강력     | - 타입 고정<br>- 다양한 소유권 모델 지원 어려움         |
| `Borrow<T>` | `fn dot<T: Borrow<Vector3D>>(a: T, b: T)`         | - 다양한 타입 허용 (`&T`, `Box<T>`, `Arc<T>` 등)<br>- API 유연성 | - 추상적이라 직관성 떨어짐<br>- 미세한 성능 오버헤드 가능 |



## ✅ Borrow<T>의 장점
### 1. 유연한 인자 타입 허용
- Borrow<Vector3D>를 구현한 타입이면 모두 인자로 받을 수 있어요
→ &Vector3D, Box<Vector3D>, Rc<Vector3D>, Arc<Vector3D> 등
```rust
let v = Vector3D { x: 1.0, y: 2.0, z: 3.0 };
dot(&v, &v);         // OK
dot(Box::new(v), &v); // OK
```

### 2. API 추상화에 유리
- 라이브러리나 범용 함수에서 다양한 ownership 모델을 지원할 수 있어요
→ 사용자 입장에서 더 자유롭게 쓸 수 있음

### 3. 자동 참조 추론 가능
- Borrow<T>는 Deref와 달리 불변 참조로 추론되기 때문에
dot(v, w)처럼 넘겨도 내부에서 .borrow()로 안전하게 처리됨


### ⚠️ Borrow<T>의 단점
#### 1. 명확성이 떨어질 수 있음
- 함수 시그니처만 보고 어떤 타입을 기대하는지 바로 파악하기 어려움
→ 특히 초보자에게는 Borrow<T>가 추상적으로 느껴질 수 있음
#### 2. 성능 측면에서 약간의 오버헤드 가능
- 대부분의 경우 최적화되지만,
Borrow<T>는 트레잇 호출을 통해 참조를 얻기 때문에
직접 &T를 받는 것보다 미세한 오버헤드가 생길 수 있음 (거의 무시 가능 수준)

### ✅ &T 직접 참조의 장점
- 명확하고 직관적: 함수가 어떤 타입을 받는지 바로 보임
- 성능 최적화에 유리: 트레잇 호출 없이 직접 참조
- IDE 지원이 더 강력함: 타입 추론이 더 빠르고 명확

## ✨ 언제 어떤 걸 쓰면 좋을까?
| 상황                          | 추천 방식                  | 설명                                                                 |
|-------------------------------|-----------------------------|----------------------------------------------------------------------|
| 다양한 소유권 모델을 지원할 때 | `Borrow<T>`                | `&T`, `Box<T>`, `Arc<T>` 등 여러 타입을 받아들일 수 있음             |
| 내부 로직에서 명확한 참조가 필요할 때 | `&T`                      | 타입이 고정되어 있고, 성능과 명확성이 중요할 때 적합                 |
| 라이브러리에서 범용 API를 만들 때 | `Borrow<T>` 또는 `AsRef<T>` | `Borrow`는 의미 기반, `AsRef`는 타입 기반 추상화에 적합              |
| 단순한 연산 함수에서 타입이 고정된 경우 | `&T`                      | 불필요한 추상화를 피하고, IDE 지원과 성능을 최우선으로 고려할 때     |

## 💬 결론
- 내부 로직에서는 &Vector3D로 명확하게 처리하고
- 외부 API에서는 Borrow<Vector3D>로 유연하게 열어두는 방식이 가장 이상적이에요.

---
# Borrow<Vector3D>를 구현한 타입

이 부분은 Rust의 트레잇 기반 추상화를 이해하는 데 아주 중요한 포인트예요.

## 🔍 Borrow<T>란 무엇인가?
Borrow<T>는 Rust의 표준 라이브러리에 있는 트레잇으로,
**“나를 T처럼 다뤄도 돼”**라는 의미를 담고 있어요.
```rust
pub trait Borrow<Borrowed: ?Sized> {
    fn borrow(&self) -> &Borrowed;
}
```

즉, 어떤 타입이 Borrow<Vector3D>를 구현했다면,
그 타입은 Vector3D처럼 참조할 수 있다는 뜻이에요.

## ✅ 어떤 타입들이 Borrow<Vector3D>를 구현할 수 있을까?
Rust 표준 라이브러리에서 이미 많은 타입들이 Borrow<T>를 자동으로 구현해요:
| 타입                  | `Borrow<Vector3D>` 구현 여부 | 설명                                                                 |
|-----------------------|------------------------------|----------------------------------------------------------------------|
| `&Vector3D`           | ✅                            | 가장 기본적인 참조. `borrow()`는 자기 자신을 그대로 반환함             |
| `Box<Vector3D>`       | ✅                            | 힙에 저장된 값. `borrow()`는 내부 참조(`&Vector3D`)를 반환함           |
| `Rc<Vector3D>`        | ✅                            | 참조 카운팅 기반 공유. 여러 소유자가 동시에 읽을 수 있음               |
| `Arc<Vector3D>`       | ✅                            | 스레드 안전한 공유. `Rc`와 유사하지만 `Send + Sync` 가능               |
| `Cow<'a, Vector3D>`   | ✅                            | 복사/참조 혼합 타입. 읽기 전용일 땐 참조, 수정 시 복사됨                |
이들은 모두 .borrow()를 호출하면 &Vector3D를 반환해요.


## ⚠️ 왜 “마음에 걸릴 수” 있는가?
### 1. 암묵적인 타입 허용이 불안할 수 있음
- Borrow<T>를 쓰면 다양한 타입이 들어올 수 있어서
→ “내 함수가 어떤 타입을 받는지 명확하지 않다”는 느낌이 들 수 있어요
### 2. 실제 구현체가 보이지 않음
- Borrow<Vector3D>를 구현한 타입이 어디서 어떻게 구현됐는지 파악하기 어렵고
→ 실수로 이상한 타입이 들어올 수도 있다는 불안감이 생길 수 있어요
### 3. IDE나 문서에서 타입 추적이 어려움
- Borrow<T>는 추상화가 강해서
→ 함수 호출 시 어떤 타입이 들어가는지 IDE가 명확히 보여주지 않을 수 있어요

## ✨ 해결책 또는 대안
| 방식                         | 설명                                                                 |
|------------------------------|----------------------------------------------------------------------|
| `&Vector3D`                  | 가장 명확하고 직관적인 방식. 타입이 고정되어 있고 성능 최적화에 유리함. |
| `AsRef<Vector3D>`            | 타입 변환 기반 추상화. `&T`, `Box<T>`, `Arc<T>` 등에서 `&Vector3D`로 변환 가능. |
| `Borrow<Vector3D>`           | 의미 기반 추상화. `HashMap` 키 조회 등에서 자주 사용되며, 다양한 참조 타입을 허용함. |
| `T: Borrow<Vector3D> + Debug`| 제네릭 제약을 추가해 타입 추적과 디버깅을 더 쉽게 만들 수 있음. |
| `&Vector3D`, `Box<Vector3D>` | 직접 참조와 힙 할당된 객체를 모두 받아들이고 싶을 때 `Borrow` 또는 `AsRef`로 추상화 가능. |


# ?Sized

Rust에서 ?Sized는 처음 보면 “사이즈가 필요한 건가?”라는 오해를 살 수 있지만, 
실제 의미는 **“사이즈가 없어도 괜찮다”**는 뜻.

## 🔍 Sized란?
Rust는 기본적으로 모든 타입이 컴파일 타임에 크기를 알아야 해요.
그래야 스택에 얼마만큼 메모리를 할당할지 결정할 수 있거든요.
예를 들어:
```rust
fn foo<T>(x: T) { ... }
```

이건 사실상 이렇게 해석돼요:
```rust
fn foo<T: Sized>(x: T) { ... }
```

즉, Rust는 기본적으로 모든 제네릭 타입 T에 대해 Sized 제약을 자동으로 붙입니다.

### ❓ 그런데 ?Sized는 뭐냐?
?Sized는 그 기본 제약을 해제하는 키워드예요.
즉, “이 타입은 Sized일 수도 있고 아닐 수도 있다”는 뜻입니다.
예시:
```rust
struct Wrapper<T: ?Sized> {
    inner: Box<T>,
}
```

이렇게 하면 Wrapper<dyn Trait>나 Wrapper<[i32]> 같은 크기를 알 수 없는 타입도 받을 수 있어요.

## ✅ 왜 필요한가?
### 1. Trait Object (dyn Trait)
- dyn Trait는 크기를 알 수 없기 때문에 Sized가 아닙니다
- 그래서 Box<dyn Trait>처럼 포인터로 감싸야 사용할 수 있어요

### 2. Slice ([T])
- [i32]는 크기를 알 수 없지만 &[i32]는 가능하죠
- 그래서 str도 직접 쓰지 않고 &str로 쓰는 거예요

## ✨ 요약 표
| 키워드     | 의미                                  | 예시 사용처                  |
|------------|---------------------------------------|------------------------------|
| `Sized`    | 컴파일 타임에 크기를 알 수 있는 타입 | 대부분의 기본 타입, 구조체   |
| `?Sized`   | 크기를 알 수 없어도 허용             | `dyn Trait`, `[T]`, `str` 등 |


## 💬 결론
?Sized는 “크기를 알 수 없는 타입도 받아들일 수 있게 해주는 예외 처리”예요.
Rust의 타입 시스템이 워낙 정밀하다 보니, 이런 예외를 명시적으로 선언해야 안전성을 유지할 수 있는 거죠.

---

# Borrow<Vector3D> for Point3D

impl Borrow<Vector3D> for Point3D를 작성하면 Point3D를 Borrow<Vector3D>로 사용할 수 있습니다.
하지만 Rust에는 **고아 규칙 (Orphan Rule)**이 있어서, 이걸 구현하려면 몇 가지 조건을 만족.

## ✅ 가능 조건: Borrow<Vector3D>를 Point3D에 구현하려면?
Rust에서는 다음 조건 중 하나를 만족해야 트레잇을 구현할 수 있어요:
- 트레잇이 내 크레이트에 정의되어 있어야 함
- 타입이 내 크레이트에 정의되어 있어야 함
→ Borrow는 표준 라이브러리에 있는 외부 트레잇이지만
→ Point3D는 당신이 정의한 타입이므로
impl Borrow<Vector3D> for Point3D는 합법적으로 구현 가능합니다.

## ✨ 예시 구현
```rust
use std::borrow::Borrow;

impl Borrow<Vector3D> for Point3D {
    fn borrow(&self) -> &Vector3D {
        // 안전하게 변환하려면 Vector3D와 Point3D가 메모리 구조가 같아야 함
        // 여기선 단순 복사로 처리
        unsafe { &*(self as *const Point3D as *const Vector3D) }
    }
}
```

이건 unsafe 캐스팅을 사용한 예시.
Point3D와 Vector3D가 메모리 구조상 완전히 동일하다는 전제가 있어야 안전합니다.


## ⚠️ 주의할 점
- Borrow<T>는 불변 참조만 반환해야 해요 (&T)
- Point3D와 Vector3D가 구조적으로 같아야 transmute 또는 cast가 안전해요
- 만약 필드가 다르거나 의미가 다르면, 새로운 Vector3D를 생성해서 반환하는 방식이 더 안전합니다:
```rust
impl Borrow<Vector3D> for Point3D {
    fn borrow(&self) -> &Vector3D {
        // 안전한 대안: 새 Vector3D를 생성해서 반환 (단, 이건 참조가 아니라 값)
        // 이 방식은 트레잇 요구사항을 만족하지 않음
        unimplemented!("Point3D와 Vector3D는 구조가 달라 unsafe가 필요합니다")
    }
}
```


## 💡 대안: AsRef<Vector3D> 사용
만약 Borrow가 너무 위험하거나 추상적이라면,
AsRef<Vector3D>를 구현해서 더 명확하게 사용할 수도 있어요:
```rust
impl AsRef<Vector3D> for Point3D {
    fn as_ref(&self) -> &Vector3D {
        unsafe { &*(self as *const Point3D as *const Vector3D) }
    }
}
```
→ as_ref()는 명시적으로 호출해야 하므로,
→ API 사용자가 더 의도를 파악하기 쉬워요

## 💬 결론
- impl Borrow<Vector3D> for Point3D는 가능하지만 unsafe가 필요
- 구조가 완전히 같을 때만 안전하게 참조 변환 가능
- 더 안전하고 명확한 대안으로는 AsRef<Vector3D>가 있음

---
