# 클로저가 받는 인자의 타입

## 🧠 핵심 차이: 클로저가 받는 인자의 타입
### 예시 코드
```rust
let v = vec![1, 2, 3, 4];

v.iter()
    .filter(|&&x| x % 2 == 0)
    .map(|&x| x)

```

## 🔍 단계별 분석
### 1️⃣ .iter()의 반환 타입
- v.iter() → `Iterator<Item = &i32>`
즉, 각 요소는 `&i32` (참조)

### 2️⃣ .filter(`|&&x|` ...)
- filter는 `&i32` 를 클로저에 넘김
- `&&x` 는 `&(&i32)` → 두 번 참조 해제해서 x: i32로 사용
- 즉, `|&&x|` 는 `|x: i32|` 처럼 동작하게 만드는 패턴
✔️ 왜 두 개냐? → `filter는 &i32` 를 받고, 그걸 다시 `&` 로 받았기 때문

### 3️⃣ .map(`|&x|` ...)
- map도 `&i32` 를 받음
- |&x|는 x: i32로 해석됨 → 한 번만 참조 해제
✔️ 왜 하나냐? → map에서는 `&i32` 를 `직접 받아서` 한 번만 해제하면 됨

## ✅ 요약
| 메서드   | 클로저 인자 타입 | 참조 해제 수준 | 설명                          |
|----------|------------------|----------------|-------------------------------|
| filter   | &&x              | &(&i32) → i32  | 두 번 참조 해제 필요           |
| map      | &x               | &i32 → i32     | 한 번 참조 해제면 충분         |


## 💡 팁
- filter에서 `&&x` 는 흔히 헷갈리는 부분이지만,  
`참조의 참조를 받는다` 는 점만 기억하면 쉽게 이해.
- copied()를 쓰면 더 깔끔하게 처리할 수도 있음:
```rust
v.iter()
    .copied()
    .filter(|x| x % 2 == 0)
    .map(|x| x)
```
---



