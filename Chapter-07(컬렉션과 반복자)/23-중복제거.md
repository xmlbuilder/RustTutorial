# Vec::dedup() 연속된 중복 제거
Vec::dedup()은 벡터에서 연속된 중복 요소를 제거하는 메서드입니다.  
즉, 같은 값이 여러 번 연속으로 나올 때 → 하나만 남기고 나머지를 제거합니다.  

## ✅ Vec::dedup() 요약
| 메서드       | vec.dedup()                         |
|-------------|--------------------------------------|
| 반환값       | () (제자리에서 변경됨)               |
| 작동 방식    | 연속된 중복 요소만 제거               |
| 요구사항     | T: PartialEq                         |


## 🧪 예제
```rust
fn main() {
    let mut v = vec![1, 1, 2, 2, 2, 3, 1, 1];
    v.dedup();
    println!("{:?}", v); // 출력: [1, 2, 3, 1]
}
```

- 1, 1 → 하나로
- 2, 2, 2 → 하나로
- 3 → 그대로
- 1, 1 → 다시 연속이므로 하나로

### 💡 주의
- 정렬되지 않은 중복 값은 제거되지 않음
- 예를 들어 [1, 2, 1] → 그대로 유지됨

## 🔧 중복 전체 제거하려면?
v.sort();
v.dedup();
- 먼저 정렬한 뒤 dedup()을 쓰면 전체 중복 제거 가능

---
# Vec::dedup_by() / Vec::dedup_by_key()

아래는 Vec::dedup_by()와 Vec::dedup_by_key()의 차이점

## ✅ dedup 계열 메서드 요약
| 메서드           | 설명                                      | 요구사항             |
|------------------|-------------------------------------------|----------------------|
| dedup()          | 연속된 동일 값 제거 (`==` 기준)           | `T: PartialEq`       |
| dedup_by()       | 사용자 정의 비교 함수로 중복 판단          | `FnMut(&mut T, &T)`  |
| dedup_by_key()   | 키 추출 함수로 중복 판단 (`==` 기준)       | `FnMut(&T) -> K`, `K: PartialEq` |


## 🧪 예제 1: dedup_by() → 사용자 정의 비교
```rust
let mut v = vec!["apple", "Apple", "banana", "Banana"];
v.dedup_by(|a, b| a.to_lowercase() == b.to_lowercase());
println!("{:?}", v); // ["apple", "banana"]
```
- 대소문자 구분 없이 중복 제거

## 🧪 예제 2: dedup_by_key() → 키 기반 중복 제거
```rust
let mut v = vec!["apple", "Apple", "banana", "Banana"];
v.dedup_by_key(|s| s.to_lowercase());
println!("{:?}", v); // ["apple", "banana"]
```

- to_lowercase()를 키로 사용해 중복 판단

---

# flaot 중복 제거

float 값에 대한 중복 제거 방법까지 완전 정리한 자료입니다.

## 🧪 예제 1: float 값 중복 제거 (오차 허용)
```rust
let mut v = vec![1.0, 1.00001, 2.0, 2.0001, 3.0];
let epsilon = 0.001;

v.dedup_by(|a, b| (a - b).abs() < epsilon);
println!("{:?}", v); // [1.0, 2.0, 3.0]
```

- dedup_by()를 활용해 오차 기반 중복 제거
- f32 또는 f64는 == 비교가 위험하므로 근사 비교가 안전

## ✅ float 중복 제거 팁
| 방법                  | 설명                                 | 예시 또는 효과                      |
|-----------------------|--------------------------------------|-------------------------------------|
| dedup_by()            | 오차 기반 비교 `(a - b).abs() < ε`   | 근사값 중복 제거                    |
| sort_by() + dedup_by()| 정렬 후 오차 기반 중복 제거           | 전체 중복 제거 가능                 |
| OrderedFloat          | 정확한 비교 및 정렬 가능              | `Ord` 구현으로 BinaryHeap 등에서 사용 |

Vec::dedup() 계열은 연속된 중복만 제거하기 때문에
정상적으로 중복 제거하려면 먼저 정렬하고 나서 dedup을 적용해야 함.
아래에 정리와 함께 int, float에 대한 샘플 2개를 준비했어요.

## ✅ 정렬 후 중복 제거 흐름
| 단계       | 설명                                   |
|------------|----------------------------------------|
| 1. sort()  | 요소를 정렬하여 중복이 연속되도록 만듦 |
| 2. dedup() | 연속된 중복 요소를 제거함              |

dedup()은 연속된 중복만 제거하므로, 정렬이 선행되어야 전체 중복 제거가 가능.


## 🧪 샘플 1: int 중복 제거
```rust
fn main() {
    let mut nums = vec![3, 1, 2, 3, 2, 1, 4];
    nums.sort();       // [1, 1, 2, 2, 3, 3, 4]
    nums.dedup();      // [1, 2, 3, 4]
    println!("{:?}", nums);
}
```


## 🧪 샘플 2: float 중복 제거 (오차 허용)
```rust
fn main() {
    let mut floats = vec![1.0, 1.00001, 2.0, 2.0001, 3.0];
    let epsilon = 0.001;

    floats.sort_by(|a, b| a.partial_cmp(b).unwrap());
    floats.dedup_by(|a, b| (a - b).abs() < epsilon);

    println!("{:?}", floats); // [1.0, 2.0, 3.0]
}
```
partial_cmp()은 f64의 정렬에 필요하고,  
dedup_by()는 오차 기반 비교로 근사값 중복 제거에 적합.


## ✅ 요약 포인트
- dedup()은 정렬 후에 써야 전체 중복 제거 가능
- float은 dedup_by()로 오차 기반 비교 처리
- sort() → dedup() 또는 dedup_by() 순서가 핵심

---

# VecDeque / LinkedList / HashSet 중복 제거
아래는 VecDeque, LinkedList, HashSet을 활용한 중복 제거 방식과  
각각의 설명 + 실전 샘플 코드를 정리한 자료입니다.

## ✅ 1. VecDeque에서 중복 제거
VecDeque은 직접 dedup() 메서드를 제공하지 않기 때문에  
retain() 또는 HashSet을 활용한 방식이 일반적입니다.
### ✔ 예제: HashSet으로 중복 제거
```rust
use std::collections::{VecDeque, HashSet};

fn main() {
    let mut deque = VecDeque::from([1, 2, 2, 3, 1, 4]);
    let mut seen = HashSet::new();

    deque.retain(|x| seen.insert(*x)); // insert() returns false if already present

    println!("{:?}", deque); // [1, 2, 3, 4]
}
```

## ✅ 2. LinkedList에서 중복 제거
LinkedList도 dedup()이 없기 때문에  
retain()과 HashSet 또는 Vec으로 변환 후 처리가 필요합니다.

### ✔ 예제: HashSet으로 중복 제거
```rust
use std::collections::{LinkedList, HashSet};

fn main() {
    let mut list = LinkedList::from([1, 2, 2, 3, 1, 4]);
    let mut seen = HashSet::new();

    list.retain(|x| seen.insert(*x));

    println!("{:?}", list); // [1, 2, 3, 4]
}
```

## ✅ 3. HashSet 기반 중복 제거 (Vec 포함)
HashSet은 중복을 자동으로 제거해주는 구조이므로  
중복 제거 목적이라면 가장 간단한 방법입니다.
###  ✔ 예제: Vec → HashSet → Vec
```rust
use std::collections::HashSet;

fn main() {
    let nums = vec![1, 2, 2, 3, 1, 4];
    let set: HashSet<_> = nums.into_iter().collect();
    let deduped: Vec<_> = set.into_iter().collect();

    println!("{:?}", deduped); // 순서는 보장되지 않음
}
```
HashSet은 순서를 보장하지 않기 때문에  
순서가 중요하다면 Vec::retain() 방식이 더 적합.


## ✅ 중복 제거 방식 비교
| 컬렉션     | dedup 지원 | 순서 유지 | 중복 제거 방식             | 특징 또는 주의사항                  |
|------------|------------|-----------|----------------------------|------------------------------------|
| Vec        | ✅ 있음     | ✅         | `sort()` + `dedup()`       | 연속된 중복만 제거 → 정렬 필요     |
| VecDeque   | ❌ 없음     | ✅         | `retain()` + `HashSet`     | 직접 구현 필요                     |
| LinkedList | ❌ 없음     | ✅         | `retain()` + `HashSet`     | 직접 구현 필요                     |
| HashSet    | ✅ 자동     | ❌         | `collect()`로 중복 제거     | 순서 보장 안 됨                    |


---






