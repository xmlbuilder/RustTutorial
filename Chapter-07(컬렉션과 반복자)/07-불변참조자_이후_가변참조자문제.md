
# 불변 참조자 후에 가변 참조 때문에 발생하는 빈번한 버그 회피

```rust
let first = &v[0]; // 불변 참조자 생성
v.push(6);         // 가변 참조자 발생 → 에러
println!("{}", first); // 불변 참조자 사용
```
Rust에서 let first = &v[0]; 이후 v.push(6);을 하면 컴파일 에러가 발생하는   
이유는 불변 참조자(&T)가 살아있는 동안 가변 참조자(&mut T)를 만들 수 없기 때문입니다.    
이는 Rust의 엄격한 빌림 규칙(Borrow Checker) 덕분에 데이터 경쟁을 방지하기 위한 안전장치입니다.  
이런 상황을 피하는 방법은 여러 가지가 있습니다.


아래에 대표적인 회피 전략들을 소개:

## 🛠️ 해결 방법 1: 참조 대신 값 복사
```rust
let first = v[0]; // 값 복사
v.push(6);
println!("{}", first);
```

- v[0]의 값을 복사하면 참조가 아닌 소유권을 가진 값이므로 v.push()가 문제되지 않음
- 단, T: Copy trait을 구현한 타입이어야 함 (예: i32, bool, char 등)

## 🔄 해결 방법 2: 참조 사용 범위 축소
```rust
let first = &v[0];
println!("{}", first); // 참조 사용 완료
v.push(6); // 이후에 가변 참조 가능
```

- 불변 참조의 사용이 끝난 뒤에 push를 호출하면 문제 없음
- Rust는 참조의 실제 사용 시점을 기준으로 빌림을 판단함

## 📦 해결 방법 3: 스코프 분리
```rust
{
    let first = &v[0];
    println!("{}", first);
} // first의 스코프 종료

v.push(6); // 이제 안전하게 호출 가능
```

- 참조의 생존 범위를 명시적으로 줄여서 빌림 충돌을 방지

## 🧠 해결 방법 4: split_at 또는 슬라이스 활용
```rust
let (first, rest) = v.split_at(1);
println!("{}", first[0]);
v.push(6); // 안전
```

- 슬라이스를 통해 부분적으로 접근하면 빌림 충돌을 피할 수 있음

## 🧰 해결 방법 5: VecDeque 사용 고려
- VecDeque은 양방향 큐로, 앞뒤에서 효율적으로 push/pop 가능
- 내부적으로 빌림 충돌이 덜 발생하는 구조

## 🚫 피해야 할 방법: unsafe 사용
- unsafe 블록으로 빌림 규칙을 우회할 수 있지만, 데이터 경쟁 위험이 있으므로 추천하지 않음

이 중 어떤 방법이 가장 적합한지는 상황에 따라 달라짐.  
예를 들어, 성능이 중요한 경우 값 복사보다 참조 범위 축소가 더 나을 수 있고,  
구조적으로 반복되는 패턴이라면 VecDeque로 자료구조를 바꾸는 것도 고려.
