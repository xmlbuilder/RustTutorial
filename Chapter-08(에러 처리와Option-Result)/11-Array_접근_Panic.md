# Array 접근 Panic
Rust에서 배열의 범위를 벗어난 접근이 런타임에 panic을 발생시키는 것은 사실상 “안전하지 않다”는 느낌을 줄 수 있지만,  
Rust의 “안전성” 개념은 조금 더 정교하게 정의.

## 🧠 Rust의 안전성(safety)은 무엇을 의미하나?
Rust에서 말하는 “안전한 언어”란 메모리 안전(memory safety)을 보장하는 언어를 의미합니다.
즉, 뻗더라도 메모리를 망가뜨리지는 않는다는 것.


## 🔥 범위 초과 접근: panic은 왜 안전한가?
```rust
let arr = [1, 2, 3];
println!("{}", arr[5]); // 런타임 panic 발생
```

- Rust는 이 상황에서 panic을 발생시키고 프로그램을 종료함
- 하지만 메모리 손상이나 미정의 동작(undefined behavior)은 발생하지 않음
- C/C++에서는 이런 경우 쓰레기 값을 읽거나, 다른 메모리를 덮어쓸 수 있음 → 진짜 위험

## ✅ Rust의 안전성 계층
| 계층               | 설명                                                              |
|--------------------|-------------------------------------------------------------------|
| 컴파일 타임 안전성 | 소유권, 빌림, 라이프타임으로 대부분의 오류를 컴파일 시점에 차단     |
| 런타임 안전성      | panic을 통해 오류를 감지하고 메모리 손상 없이 안전하게 종료          |
| unsafe 블록        | 명시적으로 위험한 작업을 허용하지만, 개발자가 안전성을 직접 책임짐   |

## 💡 결론
Rust는 **“안전하지 않은 일이 일어날 수는 있지만, 그 일이 메모리를 망가뜨리지는 않는다”**는 철학을 갖고 있음.
즉, panic은 안전한 실패 방식입니다.

---

# C++ 프로그램 손상
C++이나 Windows에서 프로그램이 죽더라도 시스템 전체가 무너지지 않는 이유는 운영체제가 “메모리 샌드박스”를 제공하기 때문.  
이건 Rust의 안전성과는 다른 계층의 보호 메커니즘입니다.

## 🧠 OS가 제공하는 메모리 보호: “샌드박스”
### ✅ 프로세스 격리
- 각 프로그램은 자기만의 메모리 공간을 갖고 있음
- 다른 프로세스의 메모리에 접근하면 OS가 즉시 차단하고 종료(panic or crash)
### ✅ 페이지 보호
- 메모리는 페이지 단위로 관리되며, 읽기/쓰기 권한이 설정됨
- 잘못된 접근은 Segmentation Fault로 처리됨
### ✅ 커널 모드 vs 유저 모드
- 일반 프로그램은 유저 모드에서 실행됨 → 시스템 자원에 직접 접근 불가
- 커널 모드는 OS만 사용 → 안정성 보장

## 🔒 Rust와 OS의 차이점
| 보호 계층       | 적용 시점     | 역할 및 특징                                                  |
|----------------|---------------|---------------------------------------------------------------|
| Rust 언어       | 컴파일 타임   | 소유권, 빌림, 라이프타임으로 메모리 안전을 사전에 강제함         |
| Rust 런타임     | 런타임        | panic으로 오류를 감지하고 메모리 손상 없이 안전하게 종료함       |
| 운영체제(OS)    | 런타임        | 프로세스 격리와 샌드박스로 시스템 전체의 안정성을 보장함         |
- Rust는 “내 코드 안에서 안전하게”
- OS는 “내 코드가 죽더라도 시스템은 안전하게”

## 💡 결론
Rust는 언어 차원에서 안전성을 강제하고,
OS는 시스템 차원에서 격리와 보호를 제공합니다.
둘이 합쳐지면 “죽더라도 남에게 피해 안 주는” 구조가 완성.

---



