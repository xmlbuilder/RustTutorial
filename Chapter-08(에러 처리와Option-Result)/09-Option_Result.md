# Option / Result
Rustì—ì„œ Option<T>ê³¼ Result<T, E>ëŠ” ì—ëŸ¬ ì—†ëŠ” ì•ˆì „í•œ í”„ë¡œê·¸ë˜ë°ì˜ í•µì‹¬.
ì˜¤ëŠ˜ì€ ì´ ë‘ íƒ€ì…ì˜ ê°’ ì¶”ì¶œ ë°©ë²•, ì¢‹ì€ ì‚¬ìš©ë²•, ê·¸ë¦¬ê³  ì„œë¡œ ë³€í™˜í•˜ëŠ” ë°©ë²•ê¹Œì§€ ê¹”ë”í•˜ê²Œ ì •ë¦¬.

## âœ… 1. Option<T>ì—ì„œ ê°’ ì¶”ì¶œí•˜ëŠ” ë°©ë²•
| ë©”ì„œë“œ               | ë™ì‘ ì¡°ê±´      | ë°˜í™˜ íƒ€ì…                 | ì„¤ëª…                                      |
|-------------------------------|----------------|-------------------------|-------------------------------------------|
| .unwrap()             | Some             | T                      | Noneì´ë©´ panic ë°œìƒ (âŒ ìœ„í—˜)              |
| .expect("msg")        | Some            | T                      | Noneì´ë©´ panic + ë©”ì‹œì§€ ì¶œë ¥ (âŒ ìœ„í—˜)     |
| .unwrap_or(default)   | í•­ìƒ            | T                      | Noneì´ë©´ ê¸°ë³¸ê°’ ë°˜í™˜ (âœ… ì•ˆì „)             |
| .unwrap_or_else(||)  | í•­ìƒ            | T                      | Noneì´ë©´ í•¨ìˆ˜ ì‹¤í–‰í•´ì„œ ê°’ ë°˜í™˜ (âœ… ì•ˆì „)   |
| .map(|v| ...)        | Some            | Option<U>              | ê°’ì— í•¨ìˆ˜ ì ìš© (âœ… ì•ˆì „)                  |
| .and_then(|v| ...)   | Some            | Option<U>             | ì²´ì´ë‹ ì²˜ë¦¬ (Option â†’ Option) (âœ… ì•ˆì „)   |
| .ok_or(err)          | Some/None       | Result<T, E>         | None â†’ Err(err)ë¡œ ë³€í™˜ (âœ… ì•ˆì „)           |
| .ok_or_else(|| err)  | Some/None       | Result<T, E>         | None â†’ Err(err) (ì§€ì—° ìƒì„±) (âœ… ì•ˆì „)      |


## âœ… 2. Result<T, E>ì—ì„œ ê°’ ì¶”ì¶œí•˜ëŠ” ë°©ë²•
| ë©”ì„œë“œ                  | ë™ì‘ ì¡°ê±´     | ë°˜í™˜ íƒ€ì…         | ì„¤ëª…                                      |
|-------------------------|----------------|--------------------|-------------------------------------------|
| .unwrap()               | Ok             | T                  | Errì´ë©´ panic ë°œìƒ (âŒ ìœ„í—˜)               |
| .expect("msg")          | Ok             | T                  | Errì´ë©´ panic + ë©”ì‹œì§€ ì¶œë ¥ (âŒ ìœ„í—˜)      |
| .unwrap_or(default)     | í•­ìƒ           | T                  | Errì´ë©´ ê¸°ë³¸ê°’ ë°˜í™˜ (âœ… ì•ˆì „)              |
| .unwrap_or_else(|e| ...) | í•­ìƒ          | T                  | Errì´ë©´ í•¨ìˆ˜ ì‹¤í–‰í•´ì„œ ê°’ ë°˜í™˜ (âœ… ì•ˆì „)    |
| .map(|v| ...)           | Ok             | Result<U, E>       | ê°’ì— í•¨ìˆ˜ ì ìš© (âœ… ì•ˆì „)                  |
| .and_then(|v| ...)      | Ok             | Result<U, E>       | ì²´ì´ë‹ ì²˜ë¦¬ (Result â†’ Result) (âœ… ì•ˆì „)   |
| .ok()                   | Ok/Err         | Option<T>          | Err â†’ None, Ok â†’ Some (âœ… ì•ˆì „)            |
| .err()                  | Ok/Err         | Option<E>          | Ok â†’ None, Err â†’ Some (âœ… ì•ˆì „)            |


## ğŸ”„ 3. Option â†” Result ë³€í™˜ ë°©ë²•
| ë³€í™˜ ë°©í–¥              | ë©”ì„œë“œ             | ì„¤ëª…                                 |
|------------------------|--------------------|--------------------------------------|
| Option<T> â†’ Result<T,E> | .ok_or(err)        | None â†’ Err(err)                      |
| Option<T> â†’ Result<T,E> | .ok_or_else(||err) | None â†’ Err(err) (ì§€ì—° ìƒì„±)          |
| Result<T,E> â†’ Option<T> | .ok()              | Ok â†’ Some, Err â†’ None                |
| Result<T,E> â†’ Option<E> | .err()             | Err â†’ Some, Ok â†’ None                |



## ğŸ’¡ ì–´ë–¤ ë°©ì‹ì´ ì¢‹ì€ê°€ìš”?
| ë°©ì‹                          | ì•ˆì „ì„±     | ì¶”ì²œ ìƒí™©                          | ì„¤ëª…                                               |
|------------------------------|------------|------------------------------------|----------------------------------------------------|
| .expect("msg")               | âŒ ìœ„í—˜    | í…ŒìŠ¤íŠ¸ ì¤‘ ë¹ ë¥´ê²Œ ì‹¤íŒ¨ í™•ì¸         | None/Errì´ë©´ panic ë°œìƒ, ë””ë²„ê¹…ì— ìœ ìš©              |
| .unwrap_or(...).map(...).and_then(...) | âœ… ì•ˆì „ | ì‹¤ì „ ì½”ë“œì—ì„œ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬       | ê¸°ë³¸ê°’, ì²´ì´ë‹, í•¨ìˆ˜ ì ìš© ë“± ìœ ì—°í•œ íë¦„ ì œì–´ ê°€ëŠ¥ |
| Result<T, String>            | âœ… ì•ˆì „    | ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ ëª…í™•íˆ ì „ë‹¬í•  ë•Œ     | ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ ë©”ì‹œì§€ í¬í•¨, ë¡œê¹…/UIì— ì í•©            |
| Result<T, String>? (with ?)  | âœ… ë§¤ìš° ì•ˆì „ | í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ ì˜¤ë¥˜ ì „íŒŒí•  ë•Œ       | `?` ì—°ì‚°ìë¡œ ê¹”ë”í•˜ê²Œ ìƒìœ„ë¡œ ì˜¤ë¥˜ ì „ë‹¬ ê°€ëŠ¥        |


## âœ¨ ì˜ˆì‹œë¡œ ì •ë¦¬
```rust
fn get_value(opt: Option<f64>) -> Result<f64, String> {
    opt.ok_or("ê°’ì´ ì—†ìŠµë‹ˆë‹¤".to_string())
}


fn safe_divide(a: f64, b: f64) -> Option<f64> {
    if b == 0.0 {
        None
    } else {
        Some(a / b)
    }
}


let result: Result<f64, String> = safe_divide(10.0, 2.0).ok_or("0ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ì—†ìŠµë‹ˆë‹¤".to_string());
```


## ğŸ’¬ ë‚´ ìƒê°
RustëŠ” Optionê³¼ Resultë¥¼ í†µí•´ panic ì—†ëŠ” ì•ˆì „í•œ íë¦„ì„ ë§Œë“¤ ìˆ˜ ìˆê²Œ í•´ì¤Œ.  
Result<T, String> ê¸°ë°˜ìœ¼ë¡œ ì²˜ë¦¬í•˜ê³ , ? ì—°ì‚°ìì™€ .map_err(...)ë¥¼ í™œìš©í•˜ë©´  
ì—ëŸ¬ ë©”ì‹œì§€ê¹Œì§€ ê¹”ë”í•˜ê²Œ ì „ë‹¬í•  ìˆ˜ ìˆìŒ.

# f64 -> Ok / Result

f64 ê°’ì„ Result<f64, String>ì— ë‹´ì•„ì„œ ë„˜ê¸°ëŠ” ë°©ë²•ì€ ì•„ì£¼ ê°„ë‹¨í•˜ì§€ë§Œ,
ì–¸ì œ ì–´ë–¤ ë°©ì‹ìœ¼ë¡œ ê°ì‹¸ëŠ”ì§€ê°€ ë” ì¤‘ìš”

## âœ… ê¸°ë³¸ ë¬¸ë²•
```rust
let value: f64 = 10.0;
let result: Result<f64, String> = Ok(value);
```

â†’ Ok(...)ë¡œ ê°ì‹¸ë©´ ì„±ê³µ ê²°ê³¼
â†’ Err("ì—ëŸ¬ ë©”ì‹œì§€".to_string())ë¡œ ê°ì‹¸ë©´ ì‹¤íŒ¨ ê²°ê³¼

## âœ… í•¨ìˆ˜ì—ì„œ ë°˜í™˜í•  ë•Œ
```rust
fn compute(x: f64, y: f64) -> Result<f64, String> {
    if x.is_nan() || y.is_nan() {
        return Err("ì…ë ¥ê°’ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤".to_string());
    }
    Ok(x * 2.0 + y)
}
```

â†’ Result<f64, String>ì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
â†’ ? ì—°ì‚°ìì™€ í•¨ê»˜ ì“°ë©´ ì²´ì´ë‹ë„ ê°€ëŠ¥

## âœ… Optionì—ì„œ f64ë¥¼ Resultë¡œ ë³€í™˜í•  ë•Œ
```rust
let x_opt: Option<f64> = Some(3.0);
let x: Result<f64, String> = x_opt.ok_or("xê°€ ì—†ìŠµë‹ˆë‹¤".to_string());
```

â†’ Option<f64> â†’ Result<f64, String> ë³€í™˜
â†’ Noneì´ë©´ Err(...)ë¡œ ì²˜ë¦¬

## âœ… DSL í´ë¡œì €ì—ì„œ ë„˜ê¸¸ ë•Œ
```rust
let f = |vars: &HashMap<String, f64>| -> Result<f64, String> {
    let x = vars.get("x").copied().ok_or("x ëˆ„ë½")?;
    let y = vars.get("y").copied().unwrap_or(0.0);
    Ok(x * 2.0 + y)
};
```

â†’ Result<f64, String>ì„ ë°˜í™˜í•˜ëŠ” í´ë¡œì €
â†’ DSL registryì— ë“±ë¡ ê°€ëŠ¥

## âœ¨ ì •ë¦¬
| ì‚¬ìš© ë°©ì‹                          | ì„¤ëª…                                               |
|-----------------------------------|----------------------------------------------------|
| Ok(10.0)                          | ì„±ê³µ ê²°ê³¼ë¡œ `f64` ê°’ì„ ì§ì ‘ ê°ì‹¸ì„œ ë°˜í™˜            |
| Err("ì—ëŸ¬ ë©”ì‹œì§€".to_string())    | ì‹¤íŒ¨ ê²°ê³¼ë¡œ ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ ë‹´ì•„ ë°˜í™˜                |
| .ok_or("ì—ëŸ¬")                    | `Option<f64>` â†’ `Result<f64, String>` ë³€í™˜          |
| fn â†’ Result<f64, String>         | í•¨ìˆ˜ì—ì„œ `Result` íƒ€ì…ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ë°˜í™˜           |

## ğŸ’¡ ì˜ˆì‹œ ì½”ë“œ ìŠ¤ë‹ˆí«
```rust
let value: Result<f64, String> = Ok(10.0);

let error: Result<f64, String> = Err("ê³„ì‚° ì‹¤íŒ¨".to_string());

let x_opt: Option<f64> = Some(3.0);

let x: Result<f64, String> = x_opt.ok_or("xê°€ ì—†ìŠµë‹ˆë‹¤".to_string());

fn compute(x: f64, y: f64) -> Result<f64, String> {
    if x.is_nan() {
        return Err("xê°€ ìœ íš¨í•˜ì§€ ì•ŠìŒ".to_string());
    }
    Ok(x * 2.0 + y)
}

let f = |vars: &HashMap<String, f64>| -> Result<f64, String> {
    let x = vars.get("x").copied().ok_or("x ëˆ„ë½")?;
    let y = vars.get("y").copied().unwrap_or(0.0);
    Ok(x * 2.0 + y)
};
```

## ğŸ’¡ ê°„ë‹¨í•˜ê²Œ ë‹¤ì‹œ ì •ë¦¬í•´ë³¼ê²Œìš”
```
Some(T)  â†’ Option<T>ì—ì„œ ì„±ê³µ
None     â†’ Option<T>ì—ì„œ ì‹¤íŒ¨

Ok(T)    â†’ Result<T, E>ì—ì„œ ì„±ê³µ
Err(E)   â†’ Result<T, E>ì—ì„œ ì‹¤íŒ¨
```

- Optionì€ ì‹¤íŒ¨ ì´ìœ ë¥¼ ë§í•˜ì§€ ì•ŠìŒ â†’ ê·¸ëƒ¥ ê°’ì´ ì—†ì„ ë¿
- ResultëŠ” ì‹¤íŒ¨ ì´ìœ ë¥¼ ëª…í™•íˆ ì „ë‹¬í•¨ â†’ Err("ì´ìœ ")

---



