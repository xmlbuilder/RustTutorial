## ğŸ”¤ UTFâ€‘8 ì¸ì½”ë”© ê·œì¹™ (ë¹„íŠ¸ íŒ¨í„´)

ì™¸ë¶€ ì–¸ì–´(Java, C#, C++, Python ë“±)ì™€ êµí™˜í•  ë•ŒëŠ” UTF-8 ë³€í™˜ì„ ê±°ì¹˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì…ë‹ˆë‹¤.  
UTFâ€‘8ì€ **8ë¹„íŠ¸ ë‹¨ìœ„(ë°”ì´íŠ¸)** ë¡œ ë¬¸ìë¥¼ í‘œí˜„í•˜ë©°, ê°€ë³€ ê¸¸ì´(1~4ë°”ì´íŠ¸) ì¸ì½”ë”©ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.  
ë¬¸ìì˜ ìœ ë‹ˆì½”ë“œ ì½”ë“œ í¬ì¸íŠ¸ ë²”ìœ„ì— ë”°ë¼ ë‹¤ìŒê³¼ ê°™ì´ ë¹„íŠ¸ íŒ¨í„´ì´ ê²°ì •ë©ë‹ˆë‹¤.

- 1ë°”ì´íŠ¸ (U+0000 ~ U+007F)
```
0xxxxxxx
```

- 2ë°”ì´íŠ¸ (U+0080 ~ U+07FF)
```
110xxxxx 10xxxxxx
```

- 3ë°”ì´íŠ¸ (U+0800 ~ U+FFFF)
```
1110xxxx 10xxxxxx 10xxxxxx
```

- 4ë°”ì´íŠ¸ (U+10000 ~ U+10FFFF)
```
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
```


## Rust UTF-8 ê¸¸ì´ íŒë³„ê³¼ ë””ì½”ë”© ì½”ë“œ
ì•„ë˜ëŠ” UTFâ€‘8ì˜ ë¹„íŠ¸ íŒ¨í„´ì„ ë°”íƒ•ìœ¼ë¡œ **ì²« ë°”ì´íŠ¸ë¡œ ê¸¸ì´ë¥¼ íŒë³„** í•˜ê³ , ì´ì–´ì„œ **ë°”ì´íŠ¸ ë°°ì—´ì—ì„œ ì‹¤ì œ ì½”ë“œ í¬ì¸íŠ¸ë¥¼ ë””ì½”ë”©** í•˜ëŠ” Rust ì˜ˆì œì…ë‹ˆë‹¤.  
ê° ë‹¨ê³„ë§ˆë‹¤ ë¹„íŠ¸ ë§ˆìŠ¤í¬ì™€ ì‹œí”„íŠ¸ ì—°ì‚°ì„ ì–´ë–»ê²Œ ì ìš©í•˜ëŠ”ì§€ ìì„¸íˆ ì„¤ëª…í–ˆìŠµë‹ˆë‹¤.

### ê°œìš”
- í•µì‹¬ ê·œì¹™: ì²« ë°”ì´íŠ¸ì˜ ìƒìœ„ ë¹„íŠ¸ íŒ¨í„´ìœ¼ë¡œ ì´ ë°”ì´íŠ¸ ìˆ˜ë¥¼ ê²°ì •í•©ë‹ˆë‹¤.
- 0xxxxxxx â†’ 1ë°”ì´íŠ¸
- 110xxxxx â†’ 2ë°”ì´íŠ¸
- 1110xxxx â†’ 3ë°”ì´íŠ¸
- 11110xxx â†’ 4ë°”ì´íŠ¸
- ì—°ì† ë°”ì´íŠ¸: ë‘ ë²ˆì§¸ ë°”ì´íŠ¸ë¶€í„°ëŠ” í•­ìƒ 10xxxxxxë¡œ ì‹œì‘í•©ë‹ˆë‹¤.
- ê²€ì¦ í¬ì¸íŠ¸: ì—°ì† ë°”ì´íŠ¸ ì ‘ë‘ì–´(10), ì˜¤ë²„ë¡±(Overlong) ì¸ì½”ë”© ê¸ˆì§€, ì„œë¡œê²Œì´íŠ¸ ë²”ìœ„ ê¸ˆì§€, ìµœëŒ€ ì½”ë“œ í¬ì¸íŠ¸ U+10FFFF ì´ˆê³¼ ê¸ˆì§€.

### UTFâ€‘8 ê¸¸ì´ íŒë³„ í•¨ìˆ˜
```rust
/// ì²« ë°”ì´íŠ¸ë¡œ UTF-8 ë¬¸ìì˜ ì´ ë°”ì´íŠ¸ ìˆ˜ë¥¼ íŒë³„í•©ë‹ˆë‹¤.
/// ìœ íš¨í•˜ì§€ ì•Šì€ ë¦¬ë”© ë°”ì´íŠ¸ë©´ Errë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
fn utf8_char_length(first_byte: u8) -> Result<usize, &'static str> {
    if first_byte & 0b1000_0000 == 0 {
        // 0xxxxxxx â†’ 1ë°”ì´íŠ¸ (ASCII)
        Ok(1)
    } else if first_byte & 0b1110_0000 == 0b1100_0000 {
        // 110xxxxx â†’ 2ë°”ì´íŠ¸
        Ok(2)
    } else if first_byte & 0b1111_0000 == 0b1110_0000 {
        // 1110xxxx â†’ 3ë°”ì´íŠ¸
        Ok(3)
    } else if first_byte & 0b1111_1000 == 0b1111_0000 {
        // 11110xxx â†’ 4ë°”ì´íŠ¸
        Ok(4)
    } else {
        Err("Invalid UTF-8 leading byte")
    }
}
```

### ë™ì‘ ì„¤ëª…
- 1ë°”ì´íŠ¸ íŒë³„: (b & 0b1000_0000) == 0 ì´ë©´ ìƒìœ„ ë¹„íŠ¸ê°€ 0 â†’ ASCII.
- 2ë°”ì´íŠ¸ íŒë³„: (b & 0b1110_0000) == 0b1100_0000 â†’ ì ‘ë‘ì–´ 110.
- 3ë°”ì´íŠ¸ íŒë³„: (b & 0b1111_0000) == 0b1110_0000 â†’ ì ‘ë‘ì–´ 1110.
- 4ë°”ì´íŠ¸ íŒë³„: (b & 0b1111_1000) == 0b1111_0000 â†’ ì ‘ë‘ì–´ 11110.
- ì˜¤ë¥˜ ë°˜í™˜: ìœ„ íŒ¨í„´ì— í•´ë‹¹í•˜ì§€ ì•Šìœ¼ë©´ UTFâ€‘8 ë¦¬ë”© ë°”ì´íŠ¸ê°€ ì•„ë‹˜.

### ë‹¨ì¼ ì½”ë“œ í¬ì¸íŠ¸ ë””ì½”ë”© í•¨ìˆ˜
ë‹¤ìŒ í•¨ìˆ˜ëŠ” ë°”ì´íŠ¸ ìŠ¬ë¼ì´ìŠ¤ì—ì„œ ì‹œì‘ ìœ„ì¹˜ì˜ ë¬¸ìë¥¼ í•˜ë‚˜ ë””ì½”ë”©í•˜ì—¬ (char, ì‚¬ìš©í•œ ë°”ì´íŠ¸ ìˆ˜)ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.  
ì—°ì† ë°”ì´íŠ¸ ì ‘ë‘ì–´ í™•ì¸, ì˜¤ë²„ë¡± ì¸ì½”ë”© ê¸ˆì§€, ì„œë¡œê²Œì´íŠ¸ ë²”ìœ„ ê¸ˆì§€, ìƒí•œ ì²´í¬ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.
```rust
/// bytes[start..]ì—ì„œ UTF-8 ë¬¸ì í•˜ë‚˜ë¥¼ ë””ì½”ë”©í•©ë‹ˆë‹¤.
/// ì„±ê³µ ì‹œ (ë¬¸ì, ì‚¬ìš©í•œ ë°”ì´íŠ¸ ìˆ˜)ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
fn decode_one_utf8(bytes: &[u8], start: usize) -> Result<(char, usize), &'static str> {
    if start >= bytes.len() {
        return Err("Out of range");
    }
    let b0 = bytes[start];
    let len = utf8_char_length(b0)?;

    if start + len > bytes.len() {
        return Err("Incomplete UTF-8 sequence");
    }

    // ì—°ì† ë°”ì´íŠ¸ ì ‘ë‘ì–´ í™•ì¸: 10xxxxxx
    for i in 1..len {
        if bytes[start + i] & 0b1100_0000 != 0b1000_0000 {
            return Err("Invalid continuation byte");
        }
    }

    // ì½”ë“œ í¬ì¸íŠ¸ ì¡°ë¦½
    let codepoint: u32 = match len {
        1 => (b0 & 0b0111_1111) as u32, // 0xxxxxxx â†’ í•˜ìœ„ 7ë¹„íŠ¸
        2 => {
            let b1 = bytes[start + 1];
            let x = (b0 & 0b0001_1111) as u32; // 110xxxxx â†’ í•˜ìœ„ 5ë¹„íŠ¸
            let y = (b1 & 0b0011_1111) as u32; // 10yyyyyy â†’ í•˜ìœ„ 6ë¹„íŠ¸
            (x << 6) | y
        }
        3 => {
            let b1 = bytes[start + 1];
            let b2 = bytes[start + 2];
            let x = (b0 & 0b0000_1111) as u32; // 1110xxxx â†’ í•˜ìœ„ 4ë¹„íŠ¸
            let y = (b1 & 0b0011_1111) as u32; // 10yyyyyy
            let z = (b2 & 0b0011_1111) as u32; // 10zzzzzz
            (x << 12) | (y << 6) | z
        }
        4 => {
            let b1 = bytes[start + 1];
            let b2 = bytes[start + 2];
            let b3 = bytes[start + 3];
            let x = (b0 & 0b0000_0111) as u32; // 11110xxx â†’ í•˜ìœ„ 3ë¹„íŠ¸
            let y = (b1 & 0b0011_1111) as u32; // 10yyyyyy
            let z = (b2 & 0b0011_1111) as u32; // 10zzzzzz
            let w = (b3 & 0b0011_1111) as u32; // 10wwwwww
            (x << 18) | (y << 12) | (z << 6) | w
        }
        _ => return Err("Unsupported length"),
    };

    // ê²€ì¦: ì˜¤ë²„ë¡± ê¸ˆì§€ (ìµœì†Œ ë°”ì´íŠ¸ë¡œ í‘œí˜„ë˜ì–´ì•¼ í•¨)
    match len {
        1 => {
            // 1ë°”ì´íŠ¸ëŠ” 0x00..0x7Fë§Œ ìœ íš¨
            if codepoint > 0x7F {
                return Err("Overlong or invalid 1-byte sequence");
            }
        }
        2 => {
            if codepoint < 0x80 || codepoint > 0x7FF {
                return Err("Overlong or out-of-range 2-byte sequence");
            }
        }
        3 => {
            if codepoint < 0x800 || codepoint > 0xFFFF {
                return Err("Overlong or out-of-range 3-byte sequence");
            }
        }
        4 => {
            if codepoint < 0x1_0000 || codepoint > 0x10_FFFF {
                return Err("Overlong or out-of-range 4-byte sequence");
            }
        }
        _ => {}
    }

    // ì„œë¡œê²Œì´íŠ¸ ë²”ìœ„ ê¸ˆì§€ (UTF-16 ì „ìš© ì˜ì—­)
    if (0xD800..=0xDFFF).contains(&codepoint) {
        return Err("Surrogate range is invalid in UTF-8");
    }

    // ìƒí•œ ì´ˆê³¼ ê¸ˆì§€
    if codepoint > 0x10_FFFF {
        return Err("Code point exceeds Unicode max");
    }

    // Rust charë¡œ ë³€í™˜ (ìœ íš¨í•œ ìŠ¤ì¹¼ë¼ ê°’ë§Œ í—ˆìš©)
    match std::char::from_u32(codepoint) {
        Some(ch) => Ok((ch, len)),
        None => Err("Invalid Unicode scalar value"),
    }
}
```

### ë””ì½”ë”© ê³¼ì • ì„¤ëª…
- ì—°ì† ë°”ì´íŠ¸ í™•ì¸: ê° ì—°ì† ë°”ì´íŠ¸ê°€ 10xxxxxxì¸ì§€ ê²€ì‚¬í•©ë‹ˆë‹¤.
- ë¹„íŠ¸ ì¡°ë¦½: ë¦¬ë”© ë°”ì´íŠ¸ì˜ í•˜ìœ„ ë¹„íŠ¸ì™€ ê° ì—°ì† ë°”ì´íŠ¸ì˜ í•˜ìœ„ 6ë¹„íŠ¸ë¥¼ ì‹œí”„íŠ¸/ORë¡œ í•©ì¹©ë‹ˆë‹¤.
- 2ë°”ì´íŠ¸: (x << 6) | y
- 3ë°”ì´íŠ¸: (x << 12) | (y << 6) | z
- 4ë°”ì´íŠ¸: (x << 18) | (y << 12) | (z << 6) | w
- ì˜¤ë²„ë¡± ê¸ˆì§€: ì˜ˆë¥¼ ë“¤ì–´ U+0041ì„ 2ë°”ì´íŠ¸ë¡œ í‘œí˜„í•˜ë©´ ê¸ˆì§€. ê° ê¸¸ì´ì— ë§ëŠ” ìµœì†Œ/ìµœëŒ€ ë²”ìœ„ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
- ì„œë¡œê²Œì´íŠ¸ ê¸ˆì§€: U+D800..U+DFFFëŠ” UTFâ€‘8ì—ì„œ ê¸ˆì§€ì…ë‹ˆë‹¤.
- ìµœëŒ€ ìƒí•œ: U+10FFFF ì´ˆê³¼ëŠ” ê¸ˆì§€ì…ë‹ˆë‹¤.
- ìŠ¤ì¹¼ë¼ ê°’ ê²€ì¦: from_u32ë¡œ ìµœì¢… í™•ì¸í•©ë‹ˆë‹¤.

### ì˜ˆì œ ì‹¤í–‰
```rust
fn main() {
    let samples: &[&[u8]] = &[
        b"A",                    // U+0041 â†’ 1ë°”ì´íŠ¸
        "í•œ".as_bytes(),         // U+D55C â†’ 3ë°”ì´íŠ¸ (UTF-8)
        "ğŸ˜€".as_bytes(),         // U+1F600 â†’ 4ë°”ì´íŠ¸
    ];

    for s in samples {
        let mut i = 0;
        println!("Bytes: {:?}", s);
        while i < s.len() {
            match decode_one_utf8(s, i) {
                Ok((ch, used)) => {
                    println!("  char='{}' U+{:04X} used={} bytes", ch, ch as u32, used);
                    i += used;
                }
                Err(e) => {
                    println!("  error at offset {}: {}", i, e);
                    break;
                }
            }
        }
        println!();
    }

    // ê¸¸ì´ë§Œ íŒë³„í•´ë³´ê¸°
    for &b in &[0x41u8, 0xC2u8, 0xE3u8, 0xF0u8] {
        println!("Byte 0x{:X}: len={:?}", b, utf8_char_length(b));
    }
}
```

### ì˜ˆìƒ ì¶œë ¥
```
Bytes: [65]
  char='A' U+0041 used=1 bytes

Bytes: [237, 149, 156]
  char='í•œ' U+D55C used=3 bytes

Bytes: [240, 159, 152, 128]
  char='ğŸ˜€' U+1F600 used=4 bytes

Byte 0x41: len=Ok(1)
Byte 0xC2: len=Ok(2)
Byte 0xE3: len=Ok(3)
Byte 0xF0: len=Ok(4)
```

### êµ¬í˜„ ì‹œ ì£¼ì˜í•  ì 
- ì—°ì† ë°”ì´íŠ¸ í™•ì¸: ëª¨ë“  ì—°ì† ë°”ì´íŠ¸ëŠ” ë°˜ë“œì‹œ 10xxxxxxì—¬ì•¼ í•©ë‹ˆë‹¤.
- ì˜¤ë²„ë¡± ì¸ì½”ë”© ê¸ˆì§€: ê°€ëŠ¥í•œ ìµœë‹¨ ê¸¸ì´ë¡œ ì¸ì½”ë”©ë˜ì–´ì•¼ í•˜ë©°, ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ë©´ ì˜¤ë¥˜ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤.
- ì„œë¡œê²Œì´íŠ¸ ë²”ìœ„ ê¸ˆì§€: U+D800..U+DFFFëŠ” UTFâ€‘8ì—ì„œ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
- ì—ëŸ¬ ì²˜ë¦¬: ë„¤íŠ¸ì›Œí¬/íŒŒì¼ ì…ë ¥ ë“± ì‹ ë¢°í•  ìˆ˜ ì—†ëŠ” ë°ì´í„°ì—ì„œëŠ” Result ê¸°ë°˜ ì—ëŸ¬ ì²˜ë¦¬ê°€ í•„ìˆ˜ì…ë‹ˆë‹¤.
- ì„±ëŠ¥ ê³ ë ¤: ëŒ€ëŸ‰ íŒŒì‹± ì‹œì—ëŠ” ë£¨í”„ ì „ê°œì™€ ë¶„ê¸° ìµœì†Œí™” ë“±ì„ ê³ ë ¤í•˜ê³ , í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë‚˜ ê²€ì¦ëœ íŒŒì„œ ì‚¬ìš©ë„ ì¢‹ìŠµë‹ˆë‹¤.

---
## ì†ŒìŠ¤ ì½”ë“œ
```rust
pub fn on_decode_one_utf8(bytes: &[u8], start: usize) -> Result<(char, usize), &'static str> {
    if start >= bytes.len() {
        return Err("Out of range");
    }
    let b0 = bytes[start];
    let len = on_utf8_char_length(b0)?;

    if start + len > bytes.len() {
        return Err("Incomplete UTF-8 sequence");
    }

    // ì—°ì† ë°”ì´íŠ¸ ì ‘ë‘ì–´ í™•ì¸: 10xxxxxx
    for i in 1..len {
        if bytes[start + i] & 0b1100_0000 != 0b1000_0000 {
            return Err("Invalid continuation byte");
        }
    }

    // ì½”ë“œ í¬ì¸íŠ¸ ì¡°ë¦½
    let codepoint: u32 = match len {
        1 => (b0 & 0b0111_1111) as u32, // 0xxxxxxx â†’ í•˜ìœ„ 7ë¹„íŠ¸
        2 => {
            let b1 = bytes[start + 1];
            let x = (b0 & 0b0001_1111) as u32; // 110xxxxx â†’ í•˜ìœ„ 5ë¹„íŠ¸
            let y = (b1 & 0b0011_1111) as u32; // 10yyyyyy â†’ í•˜ìœ„ 6ë¹„íŠ¸
            (x << 6) | y
        }
        3 => {
            let b1 = bytes[start + 1];
            let b2 = bytes[start + 2];
            let x = (b0 & 0b0000_1111) as u32; // 1110xxxx â†’ í•˜ìœ„ 4ë¹„íŠ¸
            let y = (b1 & 0b0011_1111) as u32; // 10yyyyyy
            let z = (b2 & 0b0011_1111) as u32; // 10zzzzzz
            (x << 12) | (y << 6) | z
        }
        4 => {
            let b1 = bytes[start + 1];
            let b2 = bytes[start + 2];
            let b3 = bytes[start + 3];
            let x = (b0 & 0b0000_0111) as u32; // 11110xxx â†’ í•˜ìœ„ 3ë¹„íŠ¸
            let y = (b1 & 0b0011_1111) as u32; // 10yyyyyy
            let z = (b2 & 0b0011_1111) as u32; // 10zzzzzz
            let w = (b3 & 0b0011_1111) as u32; // 10wwwwww
            (x << 18) | (y << 12) | (z << 6) | w
        }
        _ => return Err("Unsupported length"),
    };

    // ê²€ì¦: ì˜¤ë²„ë¡± ê¸ˆì§€ (ìµœì†Œ ë°”ì´íŠ¸ë¡œ í‘œí˜„ë˜ì–´ì•¼ í•¨)
    match len {
        1 => {
            // 1ë°”ì´íŠ¸ëŠ” 0x00..0x7Fë§Œ ìœ íš¨
            if codepoint > 0x7F {
                return Err("Overlong or invalid 1-byte sequence");
            }
        }
        2 => {
            if codepoint < 0x80 || codepoint > 0x7FF {
                return Err("Overlong or out-of-range 2-byte sequence");
            }
        }
        3 => {
            if codepoint < 0x800 || codepoint > 0xFFFF {
                return Err("Overlong or out-of-range 3-byte sequence");
            }
        }
        4 => {
            if codepoint < 0x1_0000 || codepoint > 0x10_FFFF {
                return Err("Overlong or out-of-range 4-byte sequence");
            }
        }
        _ => {}
    }

    // ì„œë¡œê²Œì´íŠ¸ ë²”ìœ„ ê¸ˆì§€ (UTF-16 ì „ìš© ì˜ì—­)
    if (0xD800..=0xDFFF).contains(&codepoint) {
        return Err("Surrogate range is invalid in UTF-8");
    }

    // ìƒí•œ ì´ˆê³¼ ê¸ˆì§€
    if codepoint > 0x10_FFFF {
        return Err("Code point exceeds Unicode max");
    }

    // Rust char ë¡œ ë³€í™˜ (ìœ íš¨í•œ ìŠ¤ì¹¼ë¼ ê°’ë§Œ í—ˆìš©)
    match std::char::from_u32(codepoint) {
        Some(ch) => Ok((ch, len)),
        None => Err("Invalid Unicode scalar value"),
    }
}
```
```rust
pub fn on_utf8_char_length(first_byte: u8) -> Result<usize, &'static str> {
    if first_byte & 0b1000_0000 == 0 {
        // 0xxxxxxx â†’ 1ë°”ì´íŠ¸ (ASCII)
        Ok(1)
    } else if first_byte & 0b1110_0000 == 0b1100_0000 {
        // 110xxxxx â†’ 2ë°”ì´íŠ¸
        Ok(2)
    } else if first_byte & 0b1111_0000 == 0b1110_0000 {
        // 1110xxxx â†’ 3ë°”ì´íŠ¸
        Ok(3)
    } else if first_byte & 0b1111_1000 == 0b1111_0000 {
        // 11110xxx â†’ 4ë°”ì´íŠ¸
        Ok(4)
    } else {
        Err("Invalid UTF-8 leading byte")
    }
}
```
```rust
pub fn on_is_invalid_uf8(byte: u8) -> bool {
    on_utf8_char_length(byte).is_ok()
}
```
```rust
/// String â†’ UTF-8 ë°”ì´íŠ¸ ë°°ì—´
pub fn on_string_to_utf8_bytes(s: &str) -> Vec<u8> {
    s.as_bytes().to_vec()
}

/// UTF-8 ë°”ì´íŠ¸ ë°°ì—´ â†’ String
pub fn on_utf8_bytes_to_string(bytes: &[u8]) -> Result<String, std::string::FromUtf8Error> {
    String::from_utf8(bytes.to_vec())
}
```

## í…ŒìŠ¤íŠ¸ ì½”ë“œ
```rust
#[cfg(test)]
mod tests {
    use nurbslib::core::string_utils::{on_decode_one_utf8, on_is_invalid_uf8,
        on_string_to_utf8_bytes, on_utf8_bytes_to_string, on_utf8_char_length};
    use super::*; // ê°™ì€ ëª¨ë“ˆì— ì •ì˜ëœ í•¨ìˆ˜ ì‚¬ìš©

    #[test]
    fn test_utf8_char_length() {
        // 'A' â†’ 0xxxxxxx â†’ 1ë°”ì´íŠ¸
        assert_eq!(on_utf8_char_length(0x41).unwrap(), 1);

        // 'Ã‚' â†’ 110xxxxx â†’ 2ë°”ì´íŠ¸
        assert_eq!(on_utf8_char_length(0xC2).unwrap(), 2);

        // 'Ã£' â†’ 1110xxxx â†’ 3ë°”ì´íŠ¸
        assert_eq!(on_utf8_char_length(0xE3).unwrap(), 3);

        // ğŸ˜€ â†’ 11110xxx â†’ 4ë°”ì´íŠ¸
        assert_eq!(on_utf8_char_length(0xF0).unwrap(), 4);
    }
```
```rust
    #[test]
    fn test_decode_one_utf8_ascii() {
        let bytes = b"A"; // U+0041
        let (ch, used) = on_decode_one_utf8(bytes, 0).unwrap();
        assert_eq!(ch, 'A');
        assert_eq!(used, 1);
    }
```
```rust
    #[test]
    fn test_decode_one_utf8_korean() {
        let bytes = "í•œ".as_bytes(); // U+D55C
        let (ch, used) = on_decode_one_utf8(bytes, 0).unwrap();
        assert_eq!(ch, 'í•œ');
        assert_eq!(used, 3);
    }
```
```rust
    #[test]
    fn test_decode_one_utf8_emoji() {
        let bytes = "ğŸ˜€".as_bytes(); // U+1F600
        let (ch, used) = on_decode_one_utf8(bytes, 0).unwrap();
        assert_eq!(ch, 'ğŸ˜€');
        assert_eq!(used, 4);
    }

    #[test]
    fn test_invalid_byte() {
        // 0xFFëŠ” ìœ íš¨í•œ UTF-8 ë¦¬ë”© ë°”ì´íŠ¸ê°€ ì•„ë‹˜
        assert!(!on_is_invalid_uf8(0xFF));
    }
```
```rust
    #[test]
    fn main() {
        let original = String::from("ì•ˆë…•í•˜ì„¸ìš” ğŸ˜€");

        // String â†’ UTF-8 ë°”ì´íŠ¸ ë°°ì—´
        let utf8_bytes = on_string_to_utf8_bytes(&original);
        println!("UTF-8 bytes: {:?}", utf8_bytes);

        // UTF-8 ë°”ì´íŠ¸ ë°°ì—´ â†’ String
        match on_utf8_bytes_to_string(&utf8_bytes) {
            Ok(restored) => println!("Restored String: {}", restored),
            Err(e) => println!("Error decoding UTF-8: {}", e),
        }
    }
}
```



