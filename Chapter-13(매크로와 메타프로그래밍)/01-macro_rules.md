# ë§¤í¬ë¡œ
Rustì˜ ë§¤í¬ë¡œëŠ” ë‹¨ìˆœí•œ ì½”ë“œ ì¹˜í™˜ì„ ë„˜ì–´ì„œ ì»´íŒŒì¼ íƒ€ì„ì— ì½”ë“œ ìƒì„±ê³¼ ì œì–´ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ” ê°•ë ¥í•œ ë„êµ¬.  
Rustì˜ macro_rules!ëŠ” Cì˜ `#define` ë³´ë‹¤ í›¨ì”¬ ê°•ë ¥í•˜ê³  ì•ˆì „í•œ íŒ¨í„´ ê¸°ë°˜ ë§¤í¬ë¡œ ì‹œìŠ¤í…œ.

## ğŸ§  ë§¤í¬ë¡œë€?
- ì»´íŒŒì¼ íƒ€ì„ì— ì½”ë“œ ìƒì„±ì„ ìˆ˜í–‰í•˜ëŠ” ê¸°ëŠ¥
- ë°˜ë³µë˜ëŠ” íŒ¨í„´ì„ ì¤„ì´ê³ , ë‹¤ì–‘í•œ ì…ë ¥ì„ ì²˜ë¦¬í•˜ë©°, ëŸ°íƒ€ì„ ë¹„ìš© ì—†ì´ ì½”ë“œ í™•ì¥ ê°€ëŠ¥
- í•¨ìˆ˜ì™€ ë‹¬ë¦¬ ! ê¸°í˜¸ë¥¼ ì‚¬ìš©í•˜ë©°, ëŸ°íƒ€ì„ì´ ì•„ë‹Œ ì»´íŒŒì¼ íƒ€ì„ì— ì‹¤í–‰ë¨  
ì˜ˆ: `println!`, `vec!`, `assert_eq!` ë“±ì€ ëª¨ë‘ ë§¤í¬ë¡œ

## ğŸ§© ë§¤í¬ë¡œì˜ ì¢…ë¥˜
| ì¢…ë¥˜       | ì˜ˆì‹œ ë˜ëŠ” ì„¤ëª…                                |
|------------------------|-----------------------------------------------|
| `macro_rules!`         | ì„ ì–¸ì  ë§¤í¬ë¡œ. íŒ¨í„´ ê¸°ë°˜ ì½”ë“œ ìƒì„±             |
| `#[derive]` ë§¤í¬ë¡œ     | `#[derive(Debug)]`, `#[derive(Clone)]` ë“± ìë™ trait êµ¬í˜„ |
| ì†ì„±(attribute) ë§¤í¬ë¡œ | `#[test]`, `#[route]`, `#[tokio::main]` ë“± í•¨ìˆ˜/íƒ€ì…ì— ë¶€ê°€ ë™ì‘ ë¶€ì—¬ |
| í•¨ìˆ˜(proc macro) ë§¤í¬ë¡œ| `my_macro!(...)` í˜•íƒœ. ì‚¬ìš©ì ì •ì˜ êµ¬ë¬¸ ì²˜ë¦¬ ê°€ëŠ¥ |


## ğŸ›  macro_rules! ì‚¬ìš©ë²•
```rust
#[macro_export]
macro_rules! say_hello {
    () => {
        println!("Hello from macro!");
    };
}
```
### ì‚¬ìš©ë²•
```rust
// ë§¤í¬ë¡œë¥¼ ì •ì˜í•œ í¬ë ˆì´íŠ¸ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤
use my_project::say_hello;
fn main() {
    say_hello!(); // Hello from macro! ì¶œë ¥
}
```

- `#[macro_export]` ë¥¼ ë¶™ì´ë©´ í¬ë ˆì´íŠ¸ ë£¨íŠ¸ì— ë“±ë¡ë˜ì–´ ì™¸ë¶€ì—ì„œë„ ì‚¬ìš© ê°€ëŠ¥
- ë‹¤ì–‘í•œ íŒ¨í„´ì„ ì •ì˜í•´ ì…ë ¥ì— ë”°ë¼ ë‹¤ë¥¸ ì½”ë“œë¥¼ ìƒì„± ê°€ëŠ¥


## ğŸ§  ë§¤í¬ë¡œ êµ¬ì¡°
```rust
macro_rules! square {
    ($x:expr) => {
        $x * $x
    };
}
```

### ğŸ§© macro_rules! ë¬¸ë²• êµ¬ì„± ì˜ˆì‹œ

| êµ¬ì„± ìš”ì†Œ             | ì„¤ëª…                          |
|------------------------|-------------------------------|
| `macro_rules! square` | `square`ë¼ëŠ” ì´ë¦„ì˜ ë§¤í¬ë¡œ ì •ì˜ ì‹œì‘ |
| `($x:expr)`           | ì…ë ¥ íŒ¨í„´: `$x`ëŠ” í‘œí˜„ì‹(`expr`) íƒ€ì… |
| `=> { $x * $x }`      | ë§¤í¬ë¡œ ë³¸ë¬¸: `$x`ë¥¼ ë‘ ë²ˆ ê³±í•œ ê²°ê³¼ë¡œ ì¹˜í™˜ |
| `;`                   | ë§¤í¬ë¡œ ì •ì˜ ì¢…ë£Œ (ì—¬ëŸ¬ íŒ¨í„´ êµ¬ë¶„ ì‹œ ì‚¬ìš©) |


### ğŸ“Œ $x:exprì´ë€?
- `$x`ëŠ” ë§¤í¬ë¡œ ì¸ì ì´ë¦„
- `:expr` ì€ ì´ ì¸ìê°€ í‘œí˜„ì‹(expression) íƒ€ì…ì´ì–´ì•¼ í•¨ì„ ì˜ë¯¸
- ë‹¤ë¥¸ íŒ¨í„´ë„ ìˆìŒ: `ident`, `ty`, `pat`, `block`, `tt`, `path`, `meta`, `item` ë“±

### âœ… ì‚¬ìš© ì˜ˆì‹œ
```rust
fn main() {
    let a = 3;
    let result = square!(a + 1); // (a + 1) * (a + 1)
    println!("{}", result); // ì¶œë ¥: 16
}

```
- ì£¼ì˜: ê´„í˜¸ ì—†ì´ ì“°ë©´ a + 1 * a + 1ì²˜ëŸ¼ í•´ì„ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ
- ë§¤í¬ë¡œ ë‚´ë¶€ì—ì„œ ê´„í˜¸ë¡œ ê°ì‹¸ëŠ” ê²Œ ì•ˆì „í•©ë‹ˆë‹¤:
```rust
macro_rules! square {
    ($x:expr) => {
        ($x) * ($x)
    };
}
```

## ğŸ§ª í”„ë¡œì‹œì € ë§¤í¬ë¡œ ì˜ˆì‹œ

### ğŸ§ª í”„ë¡œì‹œì € ë§¤í¬ë¡œë€?
- macro_rules!ëŠ” íŒ¨í„´ ê¸°ë°˜ ë§¤í¬ë¡œ
- proc_macroëŠ” ì½”ë“œ ìƒì„± ê¸°ë°˜ ë§¤í¬ë¡œë¡œ,
- Rust ì»´íŒŒì¼ëŸ¬ê°€ ì…ë ¥ëœ í† í°ì„ ë¶„ì„í•˜ê³  ìƒˆë¡œìš´ ì½”ë“œë¥¼ ìƒì„±í•  ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤.

```rust
// lib.rs
use proc_macro::TokenStream;

#[proc_macro_derive(MyTrait)]
pub fn my_trait_derive(input: TokenStream) -> TokenStream {
    // ì…ë ¥ëœ êµ¬ì¡°ì²´ë¥¼ ë¶„ì„í•˜ê³  trait êµ¬í˜„ ì½”ë“œë¥¼ ìƒì„±
}
```

### ğŸ§ª í”„ë¡œì‹œì € ë§¤í¬ë¡œ êµ¬ì„± ìš”ì†Œ ìš”ì•½

| ì½”ë“œ ìš”ì†Œ                     | ì„¤ëª… ë˜ëŠ” ëŒ€ì‘ ì‚¬ìš© ë°©ì‹           |
|------------------------------|------------------------------------|
| `#[proc_macro_derive(MyTrait)]` | ì‚¬ìš©ìê°€ `#[derive(MyTrait)]`ë¥¼ ë¶™ì´ë©´ ì´ ë§¤í¬ë¡œê°€ í˜¸ì¶œë¨ |
| `input: TokenStream`         | ì»´íŒŒì¼ëŸ¬ê°€ êµ¬ì¡°ì²´ ì •ì˜ë¥¼ í† í° ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì „ë‹¬ |
| `-> TokenStream`             | ë§¤í¬ë¡œê°€ ìƒì„±í•œ ì½”ë“œ(impl ë“±)ë¥¼ í† í° ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë°˜í™˜ |
| `proc_macro`                 | Rust í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ procedural macro API |

- proc_macro í¬ë ˆì´íŠ¸ í•„ìš”
```
[dependencies]
syn = "2.0"     # ì…ë ¥ëœ Rust ì½”ë“œ(AST)ë¥¼ íŒŒì‹±
quote = "1.0"   # Rust ì½”ë“œ ì¡°ê°ì„ ìƒì„±
proc-macro2 = "1.0" # í™•ì¥ëœ TokenStream (syn/quoteì™€ í˜¸í™˜)

[lib]
proc-macro = true
```
- syn, quote ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ AST íŒŒì‹± ë° ì½”ë“œ ìƒì„±


### ğŸ›  ì‹¤ì „ íë¦„: ì–´ë–»ê²Œ ë™ì‘í•˜ë‚˜?
#### 1. ì‚¬ìš©ì ì½”ë“œ
```rust
#[derive(MyTrait)]
struct Person {
    name: String,
    age: u32,
}
```

#### 2. ì»´íŒŒì¼ëŸ¬ê°€ MyTrait ë§¤í¬ë¡œ í˜¸ì¶œ
- Person êµ¬ì¡°ì²´ê°€ TokenStreamìœ¼ë¡œ ë§¤í¬ë¡œ í•¨ìˆ˜ì— ì „ë‹¬ë¨

#### 3. ë§¤í¬ë¡œ ë‚´ë¶€ì—ì„œ ì²˜ë¦¬
```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(MyTrait)]
pub fn my_trait_derive(input: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(input as DeriveInput);
    let name = &ast.ident;

    let gen = quote! {
        impl MyTrait for #name {
            fn hello() {
                println!("Hello from {}", stringify!(#name));
            }
        }
    };

    gen.into()
}
```

#### 4. ê²°ê³¼
ì»´íŒŒì¼ëŸ¬ëŠ” ë‹¤ìŒ ì½”ë“œë¥¼ ìë™ ìƒì„±:
```rust
impl MyTrait for Person {
    fn hello() {
        println!("Hello from Person");
    }
}
```

## âš ï¸ ë§¤í¬ë¡œ ì‚¬ìš© ì‹œ ì£¼ì˜ì 
| í•­ëª©     | ì„¤ëª…                                                                 |
|-----------------------------|----------------------------------------------------------------------|
| ë””ë²„ê¹… ì–´ë ¤ì›€                | ë§¤í¬ë¡œëŠ” ì»´íŒŒì¼ íƒ€ì„ì— í™•ì¥ë˜ë¯€ë¡œ ì—ëŸ¬ ìœ„ì¹˜ ì¶”ì ì´ ì–´ë ¤ìš¸ ìˆ˜ ìˆìŒ       |
| ì´ë¦„ ì¶©ëŒ ìœ„í—˜               | ì „ì—­ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ì— ë“±ë¡ë˜ë¯€ë¡œ ë™ì¼ ì´ë¦„ì˜ ë§¤í¬ë¡œê°€ ì¶©ëŒí•  ìˆ˜ ìˆìŒ       |
| ê°€ë…ì„± ì €í•˜ ê°€ëŠ¥             | ê³¼ë„í•œ ë§¤í¬ë¡œ ì‚¬ìš©ì€ ì½”ë“œ íë¦„ì„ ë¶ˆëª…í™•í•˜ê²Œ ë§Œë“¤ ìˆ˜ ìˆìŒ                |
| `#[macro_export]`ì˜ ë²”ìœ„     | ë£¨íŠ¸ ìŠ¤ì½”í”„ì— ë“±ë¡ë˜ë¯€ë¡œ ëª¨ë“ˆ ê²½ë¡œì™€ ë¬´ê´€í•˜ê²Œ ì „ì—­ì—ì„œ ì ‘ê·¼ë¨            |
| `Copy`ì™€ `Drop`ì€ ì–‘ë¦½ ë¶ˆê°€  | `Drop`ì„ êµ¬í˜„í•œ íƒ€ì…ì€ `Copy`ë¥¼ ë¶™ì¼ ìˆ˜ ì—†ìŒ â†’ ë§¤í¬ë¡œë¡œ ìƒì„±ëœ íƒ€ì…ë„ ì£¼ì˜ í•„ìš” |


## âœ¨ ì–¸ì œ ë§¤í¬ë¡œë¥¼ ì“°ë©´ ì¢‹ì€ê°€?
- ë°˜ë³µë˜ëŠ” ì½”ë“œ íŒ¨í„´ì„ ì¤„ì´ê³  ì‹¶ì„ ë•Œ
- ë‹¤ì–‘í•œ ì…ë ¥ì„ ìœ ì—°í•˜ê²Œ ì²˜ë¦¬í•˜ê³  ì‹¶ì„ ë•Œ
- trait êµ¬í˜„, í…ŒìŠ¤íŠ¸, ë¼ìš°íŒ… ë“± ì½”ë“œ ìë™ ìƒì„±ì´ í•„ìš”í•  ë•Œ
- ëŸ°íƒ€ì„ ë¹„ìš© ì—†ì´ ì»´íŒŒì¼ íƒ€ì„ì— ì½”ë“œ í™•ì¥ì´ í•„ìš”í•  ë•Œ

## ğŸ§­ ì‚¬ìš©ì ì…ì¥ì—ì„œ ì–´ë–»ê²Œ ì‹œì‘í•˜ë©´ ì¢‹ì€ê°€?
### âœ… 1. ê¸°ë³¸ êµ¬ì¡° ìµíˆê¸°
- #[proc_macro_derive(...)] â†’ Derive ë§¤í¬ë¡œ
- #[proc_macro_attribute] â†’ Attribute ë§¤í¬ë¡œ
- #[proc_macro] â†’ í•¨ìˆ˜í˜• ë§¤í¬ë¡œ

### âœ… 2. synìœ¼ë¡œ ì…ë ¥ íŒŒì‹±
- DeriveInput, ItemStruct, Field ë“±ìœ¼ë¡œ êµ¬ì¡°ì²´/ì—´ê±°í˜• ë¶„ì„

### âœ… 3. quote!ë¡œ ì½”ë“œ ìƒì„±
- quote! { ... } ì•ˆì—ì„œ #name, #fields ë“±ìœ¼ë¡œ ë™ì  ì½”ë“œ ìƒì„±

### âœ… 4. í…ŒìŠ¤íŠ¸ì™€ ë””ë²„ê¹…
- cargo expandë¡œ ë§¤í¬ë¡œê°€ ìƒì„±í•œ ì½”ë“œë¥¼ í™•ì¸
- cargo testë¡œ ë§¤í¬ë¡œê°€ ì˜ ì‘ë™í•˜ëŠ”ì§€ ê²€ì¦

## ğŸ“¦ ë§¤í¬ë¡œ ê´€ë¦¬ íŒ
| ì „ëµ           | ì„¤ëª…                                                                 |
|-----------------------------|----------------------------------------------------------------------|
| `macros.rs`                 | ê³µí†µ ë§¤í¬ë¡œë¥¼ í•œ íŒŒì¼ì— ëª¨ì•„ë‘ë©´ ìœ ì§€ë³´ìˆ˜ì™€ ì¬ì‚¬ìš©ì— ìœ ë¦¬í•¨             |
| `#[macro_export]`           | ë§¤í¬ë¡œë¥¼ í¬ë ˆì´íŠ¸ ë£¨íŠ¸ì— ë“±ë¡í•˜ì—¬ ì™¸ë¶€ì—ì„œë„ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•¨          |
| ì´ë¦„ì— prefix ë¶™ì´ê¸°        | `math_approx_f64!`, `util_log!` ë“±ìœ¼ë¡œ ì´ë¦„ ì¶©ëŒ ë°©ì§€                  |
| ë‚´ë¶€ ì „ìš©ì€ export ìƒëµ     | `macro_rules!`ë§Œ ì‚¬ìš©í•˜ê³  `pub(crate)` ìˆ˜ì¤€ì—ì„œ ì œí•œí•˜ë©´ ì•ˆì „í•˜ê²Œ ê´€ë¦¬ ê°€ëŠ¥ |

---

# ë§¤í¬ë¡œ ì„ ì–¸

 ì™¸ë¶€ í¬ë ˆì´íŠ¸ì—ì„œ macro_rules! ë§¤í¬ë¡œë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ ì •í™•í•œ ìœ„ì¹˜ì— ì„ ì–¸ê³¼ ì„¤ì •ì´ í•„ìš”.
 
## âœ… 1. ë§¤í¬ë¡œ ì •ì˜ í¬ë ˆì´íŠ¸ì—ì„œ ë§¤í¬ë¡œë¥¼ ì‚¬ìš©í•˜ë ¤ë©´
| ìœ„ì¹˜ | ì„¤ëª…                                                              |
|------------------------------|-------------------------------------------------------------------|
| `macros.rs` ë˜ëŠ” `macros/mod.rs` | `macro_rules!`ë¡œ ë§¤í¬ë¡œ ì •ì˜í•˜ê³  `#[macro_export]`ë¥¼ ë¶™ì—¬ì•¼ ë£¨íŠ¸ì— ë“±ë¡ë¨ |
| `lib.rs`                     | `mod macros;` ì„ ì–¸ì„ í†µí•´ ë§¤í¬ë¡œ ëª¨ë“ˆì„ ë£¨íŠ¸ì— í¬í•¨ì‹œì¼œì•¼ ì™¸ë¶€ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥ |

```rust
// lib.rs
mod macros; // ë£¨íŠ¸ì— ë“±ë¡í•´ì•¼ #[macro_export]ê°€ ì‘ë™í•¨
```

```rust
// macros.rs
#[macro_export]
macro_rules! approx_f64 {
    ($a:expr, $b:expr, $eps:expr) => {
        (($a as f64) - ($b as f64)).abs() <= ($eps as f64)
    };
}
```

## âœ… 2. ì™¸ë¶€ í¬ë ˆì´íŠ¸ì—ì„œ
|    ìœ„ì¹˜    | ì„¤ëª…                                                              |
|------------------------------|-------------------------------------------------------------------|
| `Cargo.toml`                 | ë§¤í¬ë¡œ ì •ì˜ í¬ë ˆì´íŠ¸ë¥¼ `dependencies`ì— ì¶”ê°€                       |
| ì½”ë“œ ìƒë‹¨                    | `use crate_name::macro_name;` ë°©ì‹ìœ¼ë¡œ ë§¤í¬ë¡œë¥¼ ëª…ì‹œì ìœ¼ë¡œ ê°€ì ¸ì˜´   |


```rust
use your_crate_name::approx_f64;

fn main() {
    assert!(approx_f64!(0.1 + 0.2, 0.3, 1e-9));
}
```

#### ğŸ” `#[macro_use] extern crate ...;` ëŠ” Rust 2015 ìŠ¤íƒ€ì¼ë¡œ, ì§€ê¸ˆì€ ëª…ì‹œì  `use` ë°©ì‹ì´ ê¶Œì¥

## âš ï¸ ì£¼ì˜ ìš”ì•½
| í•­ëª©               | ì„¤ëª…                                                                 |
|----------------------------|----------------------------------------------------------------------|
| `#[macro_export]`          | ë§¤í¬ë¡œë¥¼ í¬ë ˆì´íŠ¸ ë£¨íŠ¸ì— ë“±ë¡í•˜ì—¬ ì™¸ë¶€ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•¨          |
| `mod macros;`              | ë°˜ë“œì‹œ `lib.rs` ë˜ëŠ” `main.rs`ì—ì„œ ì„ ì–¸í•´ì•¼ ë£¨íŠ¸ ë“±ë¡ì´ ì‘ë™í•¨         |
| `pub use` ë¶ˆê°€             | `macro_rules!` ë§¤í¬ë¡œëŠ” `pub use`ë¡œ ì¬ìˆ˜ì¶œí•  ìˆ˜ ì—†ìŒ                  |

---


