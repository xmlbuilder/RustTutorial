## 🧠 Rust에서 리플렉션과 메타 프로그래밍 하는 법

Rust는 전통적인 리플렉션(reflection)을 지원하지 않지만, 
**메타 프로그래밍(metaprogramming)** 은 강력한 매크로 시스템을 통해 구현할 수 있습니다.  
아래에 주요 방법들을 정리:

## 🧠 Rust에서 리플렉션은 왜 제한적일까?
Rust는 정적 타입 시스템과 컴파일 타임 안전성을 중시하기 때문에, Java나 Python처럼 런타임에 타입 정보를 조회하거나 수정하는 리플렉션 기능은 제공하지 않습니다.  
대신, 컴파일 타임에 코드 생성을 자동화하는 방식으로 메타 프로그래밍을 구현합니다.

## 🛠️ Rust 메타 프로그래밍의 핵심: 매크로 시스템
### 1. 선언적 매크로 (macro_rules!)
- 가장 기본적인 매크로 방식
- 패턴 매칭을 통해 코드 조각을 생성
- 예시:
```rust
macro_rules! say_hello {
    () => {
        println!("Hello!");
    };
}

fn main() {
    say_hello!(); // Hello! 출력
}
```

- 반복되는 코드를 줄이고, 도메인 특화 언어(DSL)를 만들 때 유용
### 2. 절차적 매크로 (Procedural Macros)
- 더 복잡한 코드 생성을 위해 사용
- #[derive], #[attribute], #[function_like] 형태로 사용
- 예시: 구조체에 메서드를 자동으로 추가하는 매크로

```rust
use proc_macro::TokenStream;

#[proc_macro_attribute]
pub fn add_hello(attr: TokenStream, item: TokenStream) -> TokenStream {
    let attr = attr.to_string();
    let mut item = item.to_string();
    let hello_fn = format!("fn hello(&self) {{ println!(\"Hello, {}!\"); }}", attr);
    item.push_str(&hello_fn);
    item.parse().unwrap()
}

#[add_hello("world")]
struct Greeter;

fn main() {
    let greeter = Greeter;
    greeter.hello(); // Hello, world! 출력
}
```
- proc_macro 크레이트를 통해 구현하며, 외부 crate로 분리해야 함

## 🧩 1단계: 매크로 정의
```rust
#[proc_macro_attribute]
pub fn add_hello(attr: TokenStream, item: TokenStream) -> TokenStream {
```

- #[proc_macro_attribute]: 이 함수가 attribute macro임을 나타냅니다.
- add_hello: 매크로 이름입니다. 사용 시 #[add_hello("world")]처럼 구조체 위에 붙입니다.
- attr: 매크로에 전달된 인자 "world"가 들어옵니다.
- item: 매크로가 적용된 코드 조각 (struct Greeter)이 들어옵니다.

## 🧩 2단계: 문자열로 변환
```rust
let attr = attr.to_string();
let mut item = item.to_string();
```

- TokenStream은 Rust의 토큰 스트림 타입으로, 코드 조각을 나타냅니다.
- to_string()을 통해 "world"와 struct Greeter;를 문자열로 변환합니다.

## 🧩 3단계: 메서드 생성
```rust
let hello_fn = format!("fn hello(&self) {{ println!(\"Hello, {}!\"); }}", attr);
```

- hello_fn은 구조체에 추가할 메서드입니다.
- attr 값 "world"를 포함한 hello() 메서드를 생성합니다.
- 결과:
```rust
fn hello(&self) {
    println!("Hello, world!");
}
```

## 🧩 4단계: 원래 코드에 메서드 추가
```rust
item.push_str(&hello_fn);
```

- 원래 구조체 정의 뒤에 hello() 메서드를 문자열로 붙입니다.
- 최종적으로 다음과 같은 코드가 됩니다:
```rust
struct Greeter;
fn hello(&self) {
    println!("Hello, world!");
}
```


## 🧩 5단계: 다시 TokenStream으로 변환
```rust
item.parse().unwrap()
```

- 문자열로 합쳐진 코드를 다시 TokenStream으로 변환하여 컴파일러에 반환합니다.
- unwrap()은 변환 실패 시 panic을 발생시킵니다.

## 🧩 6단계: 매크로 사용
```rust
#[add_hello("world")]
struct Greeter;
```

- 이 구조체는 add_hello 매크로에 의해 hello() 메서드를 자동으로 갖게 됩니다.
- 사용 예:
```rust
fn main() {
    let g = Greeter;
    g.hello(); // Hello, world!
}
```


## 🧠 보충 설명
- 이 매크로는 매우 단순한 방식으로 동작하며, 실제로는 syn과 quote 크레이트를 사용해 더 안전하고 정교하게 구현하는 것이 일반적입니다.
- 현재 방식은 구조체 내부에 메서드를 넣지 않고, 구조체 외부에 메서드를 정의하기 때문에 impl 블록이 필요합니다.

---


##  🔍 리플렉션 대체 방법
Rust에서 리플렉션이 필요할 때는 다음과 같은 방식으로 대체합니다:
- Serde: 런타임에 구조체를 JSON 등으로 직렬화/역직렬화하며 타입 정보를 간접적으로 활용
- syn + quote: 절차적 매크로에서 AST를 파싱하고 코드 생성
- TypeId: std::any::TypeId를 통해 타입 비교는 가능하지만, 타입 이름이나 필드 조회는 불가능


이제 #[derive(Serialize, Deserialize)]를 붙인 구조체 Person을 syn과 quote를 사용해서 절차적 매크로로 확장하고, 
변수와 연동되는 방식까지 단계별로 설명.

## 🎯 목표
- #[auto_hello] 매크로를 Person 구조체에 붙이면,
- 구조체 내부 필드(name, age)를 활용해 자동으로 hello() 메서드를 생성
- 이 메서드는 변수와 연동되어 println!으로 인사 메시지를 출력

## 📦 1단계: 프로젝트 설정
`Cargo.toml`
```
[lib]
proc-macro = true

[dependencies]
syn = { version = "2.0", features = ["full"] }
quote = "1.0"
proc-macro2 = "1.0"
```


## 🧬 2단계: 매크로 구현
```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput, Data, Fields};

#[proc_macro_attribute]
pub fn auto_hello(_attr: TokenStream, item: TokenStream) -> TokenStream {
    // 1. 구조체 파싱
    let input = parse_macro_input!(item as DeriveInput);
    let struct_name = &input.ident;

    // 2. 필드 추출
    let fields = match &input.data {
        Data::Struct(data_struct) => match &data_struct.fields {
            Fields::Named(named_fields) => &named_fields.named,
            _ => panic!("Expected named fields"),
        },
        _ => panic!("Expected a struct"),
    };

    // 3. name과 age 필드 찾기
    let mut name_field = None;
    let mut age_field = None;

    for field in fields {
        let ident = field.ident.as_ref().unwrap().to_string();
        match ident.as_str() {
            "name" => name_field = Some(field.ident.clone().unwrap()),
            "age" => age_field = Some(field.ident.clone().unwrap()),
            _ => {}
        }
    }

    let name_field = name_field.expect("Missing 'name' field");
    let age_field = age_field.expect("Missing 'age' field");

    // 4. 코드 생성
    let expanded = quote! {
        #[derive(Serialize, Deserialize)]
        #input

        impl #struct_name {
            pub fn hello(&self) {
                println!("안녕하세요, 저는 {}이고 {}살입니다.", self.#name_field, self.#age_field);
            }
        }
    };

    TokenStream::from(expanded)
}
```

## 🧪 3단계: 구조체에 매크로 적용
```rust
use my_macro::auto_hello;

#[auto_hello]
struct Person {
    name: String,
    age: u32,
}
```


## 🧪 4단계: 변수와 연동
```rust
fn main() {
    let user = Person {
        name: String::from("JungHwan"),
        age: 30,
    };

    user.hello(); // 자동 생성된 메서드 호출
}
```

출력 결과:
```
안녕하세요, 저는 JungHwan이고 30살입니다.
```


## 🧠 절차 요약
| 단계               | 설명                             |
|--------------------|----------------------------------|
| parse_macro_input! | TokenStream을 AST로 파싱         |
| Data::Struct       | 구조체인지 확인                  |
| Fields::Named      | 필드 이름 추출                   |
| quote!             | impl 블록과 hello() 메서드 생성  |
| TokenStream::from  | 최종 코드 반환                   |



## 💡 확장 아이디어
- name과 age 외 다른 필드도 자동으로 인사에 포함
- serde_json과 연동해 JSON으로 직렬화 후 출력
- #[auto_debug], #[auto_builder] 같은 매크로로 확장 가능

---

# DeriveInput, Data, Fields, Field
DeriveInput, Data, Fields, Field가 어떤 역할을 하는지 정확히 짚고 넘어가야 합니다.  
아래에 각 단계별로 구조와 동작 원리를 자세히 설명.

## 🧠 전체 흐름 요약
```
pub fn auto_hello(_attr: TokenStream, item: TokenStream) -> TokenStream
```
- `item`: 구조체 정의가 TokenStream으로 들어옴 → syn으로 파싱
- `input`: 구조체 전체를 나타내는 DeriveInput 타입
- `input.data`: 구조체 내부 데이터 → Data::Struct로 다운캐스팅
- `data_struct.fields`: 필드 목록 → Fields::Named로 다운캐스팅
- `Field`: 각각의 필드 정보 (name, age 등)
- `quote!`: 코드 생성
- `TokenStream::from`: 최종 반환

## 🔍 핵심 타입 설명
### 1. DeriveInput
```rust
let input = parse_macro_input!(item as DeriveInput);
```

- DeriveInput은 구조체, 열거형, 유니언을 모두 표현할 수 있는 최상위 타입
- 주요 필드:
- `ident`: 구조체 이름 (Person)
- `data`: 실제 구조체/열거형/유니언의 내부 정보
- `attrs`: #[...] 형태의 어트리뷰트들
- 예시 구조:
```rust
DeriveInput {
    ident: Ident("Person"),
    data: Data::Struct(...),
    attrs: [Attribute],
    ...
}
```


### 2. Data::Struct
```rust
match &input.data {
    Data::Struct(data_struct) => ...
}
```

- Data는 열거형(enum), 구조체(struct), 유니언(union)을 구분
- Data::Struct는 구조체일 때만 해당
- 내부 필드:
- fields: 구조체의 필드들 (Fields 타입)

### 3. Fields::Named
```rust
match &data_struct.fields {
    Fields::Named(named_fields) => &named_fields.named,
}
```

- Fields는 세 가지 형태를 가짐:
- `Named`: { name: String } 형태
- `Unnamed`: (String, u32) 형태 (튜플 구조체)
- `Unit`: struct Foo; 형태
- `named_fields.named`: Vec<Field> 타입으로 각 필드 정보가 들어 있음

### 4. Field
for field in fields {
    let ident = field.ident.as_ref().unwrap().to_string();
    ...
}


- Field는 구조체의 각 필드를 나타냄
- 주요 필드:
- `ident`: 필드 이름 (name, age)
- `ty`: 타입 (String, u32)
- `attrs`: 필드에 붙은 어트리뷰트들
- 예시 구조:
```rust
Field {
    ident: Some(Ident("name")),
    ty: Type::Path(...),
    attrs: [],
    ...
}
```


### 🧪 필드 추출 로직
```rust
let mut name_field = None;
let mut age_field = None;

for field in fields {
    let ident = field.ident.as_ref().unwrap().to_string();
    match ident.as_str() {
        "name" => name_field = Some(field.ident.clone().unwrap()),
        "age" => age_field = Some(field.ident.clone().unwrap()),
        _ => {}
    }
}
```

- field.ident는 Option<Ident>이므로 .as_ref().unwrap()으로 꺼냄
- 이름이 "name" 또는 "age"인 필드를 찾아서 저장

### 🧬 코드 생성 (quote!)
```rust
let expanded = quote! {
    #[derive(Serialize, Deserialize)]
    #input

    impl #struct_name {
        pub fn hello(&self) {
            println!("안녕하세요, 저는 {}이고 {}살입니다.", self.#name_field, self.#age_field);
        }
    }
};
```
- `#input`: 원래 구조체 그대로 삽입
- `#struct_name`: 구조체 이름 (Person)
- `#name_field`, `#age_field`: 필드 이름을 코드에 삽입
- `quote!`는 Rust 코드 조각을 생성하는 매크로

### 📦 최종 반환
```rust
TokenStream::from(expanded)

```
- quote!로 생성된 코드를 TokenStream으로 변환
- 컴파일러가 이 코드를 실제로 컴파일

## 🧠 시각적 구조 요약
| 타입            | 역할                                |
|-----------------|-------------------------------------|
| DeriveInput     | 구조체 전체를 표현                   |
| Data::Struct    | 구조체 내부 데이터                   |
| Fields::Named   | `{}` 형태의 필드 목록                |
| Field           | 각 필드의 이름, 타입, 어트리뷰트 등 |
| quote!          | Rust 코드 생성                       |
| TokenStream     | 컴파일러에 반환할 최종 코드          |

---



