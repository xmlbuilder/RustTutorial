# Rust Swap (소유권 문제 해결)
- Rust의 소유권과 대여(borrowing) 규칙이 복잡할 때, **임시 변수에 값을 복사해서 교환(swap)** 하는 방식으로 문제를 우회.   
- 이 방식은 Rust의 안전성을 유지하면서도 실용적으로 문제를 해결하는 패턴 중 하나입니다.


## 🔁 std::mem::swap 개요
```rust
pub fn swap<T>(x: &mut T, y: &mut T)
```
- 두 개의 **가변 참조 (&mut T)** 를 받아서 값을 교환합니다
- 소유권 이동 없이 값을 바꾸는 안전한 방법입니다
- T는 Copy나 Clone을 구현하지 않아도 됩니다

### ✅ 예시
```rust
fn main() {
    let mut a = 10;
    let mut b = 20;
    std::mem::swap(&mut a, &mut b);
    println!("a = {}, b = {}", a, b); // a = 20, b = 10
}
```

### 🔍 언제 유용한가?
- 구조체 필드나 배열 요소를 교환할 때
- Option<T>에서 Some과 None을 바꿀 때
- RefCell 내부 값을 바꿀 때

## ⚠️ 주의점
- 두 인자는 서로 다른 메모리 주소여야 합니다
- 같은 변수에 대해 swap(&mut x, &mut x)처럼 쓰면 런타임 오류는 없지만 의미 없음
---

# 자체 swap 구현

## 🧠 이 방식의 핵심 아이디어
```rust
let v_p = { *a.at(piv as i32, j as i32) };
let v_k = { *a.at(k   as i32, j as i32) };
*a.at_mut(piv as i32, j as i32) = v_k;
*a.at_mut(k   as i32, j as i32) = v_p;
```

- `a.at(...)` 은 불변 참조를 반환하고 `*` 로 값을 복사
- `a.at_mut(...)` 은 가변 참조를 반환하고 `*` 로 값을 대입
- 중간에 값을 복사해두면 두 개의 가변 참조가 동시에 존재하지 않으므로 Rust의 borrow checker가 허용함

## ✅ 장점
| 항목             | 설명                                      |
|------------------|-------------------------------------------|
| 가독성 향상       | 반복되는 스코프 블록 없이 코드가 깔끔해짐   |
| 중복 제거         | `at()` 호출을 함수 내부로 감춰서 재사용 가능 |
| 의도 명확화       | `swap_at()` 이름만으로 동작을 직관적으로 이해 |
| borrow 안전성     | 동시에 여러 `&mut` 참조를 피할 수 있음       |


## ⚠️ 단점 또는 고려사항
| 항목             | 설명                                           |
|------------------|------------------------------------------------|
| 성능 오버헤드     | 값 복사가 많은 경우 성능에 영향 줄 수 있음       |
| 코드 장황함       | `at()` 호출이 반복되면 가독성이 떨어질 수 있음   |
| 추상화 필요성     | `swap_at(i, j)` 같은 함수로 감싸는 게 더 깔끔함   |


## 🧩 대안: 헬퍼 함수로 추상화
```rust
fn swap_at(a: &mut Matrix, i: i32, j: i32, k: i32) {
    let tmp = a.at(i, j).clone();
    *a.at_mut(i, j) = a.at(k, j).clone();
    *a.at_mut(k, j) = tmp;
}
```
- 반복되는 로직을 함수로 추상화하면 가독성과 재사용성이 향상됩니다

## 📘 요약
| 항목             | 설명                                           |
|------------------|------------------------------------------------|
| 목적             | 소유권 충돌 없이 안전하게 값 교환              |
| 장점             | 가독성 향상, 중복 제거, borrow 안전성 확보     |
| 고려사항         | 성능 오버헤드, `at()` 반복 호출 시 장황해질 수 있음 |
| 대안             | `swap_at()` 함수로 추상화하여 명확하게 처리     |


이 방식은 Rust의 소유권 모델을 존중하면서도 실용적으로 문제를 푸는 좋은 예.  
특히 수치 계산, 행렬 연산, 그래프 알고리즘 등에서 자주 쓰이는 패턴입니다.


## ✅ 왜 swap_at()이 더 나은가?
### 1. 스코프 오버헤드 감소
- 반복적으로 `{ *a.at(...) }` 처럼 블록을 열고 닫는 건 가독성 저하와 코드 부피 증가를 유발합니다.
- `swap_at()` 은 그 로직을 한 곳에 모아두므로 스코프 관리가 깔끔해집니다.

### 2. 중복 제거
- `a.at(...)`, `a.at_mut(...)` 를 반복 호출하면 버그 가능성도 높아지고 유지보수가 어려워집니다.
- swap_at()은 한 번만 구현하고 재사용할 수 있어요.

### 3. 의도 명확화
- `swap_at(i, j)` 는 "이 두 위치를 교환한다"는 의도를 함수 이름으로 표현하므로, 읽는 사람이 바로 이해할 수 있습니다.

### 4. Borrow Checker 친화적
- swap_at() 내부에서 값을 복사하고 교환하므로 동시 가변 참조 문제를 피할 수 있음.
- 외부에서는 단순 호출만 하므로 소유권 충돌 걱정 없음.

## 🧠 실전 팁
```rust
fn swap_at(a: &mut Matrix, i: i32, j: i32, k: i32) {
    let tmp = a.at(i, j).clone();
    *a.at_mut(i, j) = a.at(k, j).clone();
    *a.at_mut(k, j) = tmp;
}
```
- clone()을 쓰면 값 복사도 명확하게 처리됨
- Copy 트레이트가 구현된 타입이면 clone() 없이도 가능

## 📘 요약
| 항목         | 설명                                      |
|--------------|-------------------------------------------|
| 목적         | 소유권 충돌 없이 안전하게 값 교환          |
| 방식         | 임시 복사 후 `&mut` 참조로 대입            |
| 추상화 함수  | `swap_at()`으로 반복 제거 및 의도 명확화   |

---

# Copy / Clone 이용

## 🧠 왜 Copy / Clone 조건이 필요한가?
Rust에서 값을 복사할 때:  
- Copy: 비용 없는 복사 (스택에 있는 단순 타입들)
- Clone: 명시적 복사 (힙에 있는 복잡한 타입들)  
swap_at() 함수에서 값을 임시로 저장하려면 복사가 필요하므로, 타입에 따라 Copy 또는 Clone 제약을 걸어야 안전하게 동작합니다.

### ✅ Copy 제약을 붙인 swap 함수
```rust
fn swap_at<T: Copy>(a: &mut [T], i: usize, j: usize) {
    let tmp = a[i];
    a[i] = a[j];
    a[j] = tmp;
}
```

- T: Copy 제약으로 비용 없는 복사만 허용
- i, j는 인덱스이므로 Vec<T>나 슬라이스에 적용 가능

### ✅ Clone 제약을 붙인 swap 함수
```rust
fn swap_at<T: Clone>(a: &mut [T], i: usize, j: usize) {
    let tmp = a[i].clone();
    a[i] = a[j].clone();
    a[j] = tmp;
}
```
- T: Clone이면 Copy가 아닌 타입도 교환 가능
- 단, 성능 오버헤드가 있을 수 있음

## 📘 요약 테이블
| 제약 조건 | 설명                          | 예시 타입               | 성능       |
|-----------|-------------------------------|--------------------------|------------|
| `Copy`    | 스택 기반, 비용 없는 복사       | `i32`, `f64`, `bool`     | 빠름       |
| `Clone`   | 힙 기반, 명시적 복사 필요       | `String`, `Vec<T>`       | 느릴 수 있음 |

---

# Function Name
Rust에서는 함수 이름이 같으면 오버로딩이 안 되기 때문에 각각의 역할에 맞게 의미 있는 이름을 붙여주는 게 중요.  
아래는 swap_at()을 Copy, Clone, 일반 버전으로 나눌 때 추천할 수 있는 함수 이름들입니다:

## 🧠 함수 이름 추천

| 제약 조건 | 타입 제약 | 함수 이름         | 설명        |
|------------|------------|--------------------|-------------|
| `Copy`     | `T: Copy`  | `swap_copy_at()`   | 비용 없는 복사 |
| `Clone`    | `T: Clone` | `swap_clone_at()`  | 명시적 복사   |
| 없음       | 없음       | `swap_at()`        | 일반 교환     |

- Rust에서 Copy나 Clone 트레이트를 사용하려면 해당 타입에 대해 트레이트 구현이 되어 있어야만 사용할 수 있음. 

## ✅ Copy와 Clone 트레이트의 차이

| 트레이트 | 특징             | 구현 방식                  | 대표 타입 예시         |
|----------|------------------|----------------------------|-------------------------|
| `Copy`   | 자동 복사 (얕은 복사) | `#[derive(Copy, Clone)]`   | `i32`, `f64`, `bool`     |
| `Clone`  | 명시적 복사 (깊은 복사) | `#[derive(Clone)]`         | `String`, `Vec<T>`       |

## 🧩 사용 조건
- T: Copy 또는 T: Clone을 함수나 제네릭에 명시하려면,
- 해당 타입이 해당 트레이트를 구현하고 있어야 함
- Rust는 자동으로 Copy를 구현하지 않음 → Clone은 수동 구현도 가능
### 예시: 직접 구현
```rust
#[derive(Clone, Copy)]
struct Point {
    x: f64,
    y: f64,
}
```

### 예시: 수동 구현
```rust
struct MyType {
    data: String,
}
impl Clone for MyType {
    fn clone(&self) -> Self {
        MyType {
            data: self.data.clone(),
        }
    }
}
```

## 💡 실전 팁
- Copy는 Clone을 자동으로 포함하므로 Copy 타입은 Clone도 사용 가능
- Clone만 구현된 타입은 Copy처럼 자동 복사할 수 없음 → clone() 호출 필요
- Copy는 얕은 복사, Clone은 깊은 복사 가능

## 📘 요약
| 조건         | 설명                                      |
|--------------|-------------------------------------------|
| `Copy` 사용   | 타입이 `Copy` 트레이트를 구현해야 함       |
| `Clone` 사용  | 타입이 `Clone` 트레이트를 구현해야 함      |
| 자동 파생     | `#[derive(Copy, Clone)]`로 간편하게 구현 가능 |

---
## swap 실전 점검
- 두 위치의 값을 **자리 바꿈** 합니다. 소유권을 다시 구성하는 게 아니라,
- 제자리에서 두 값을 서로 바꿉니다.
    - 용도: 정렬, 선택적 자리 바꿈, 버퍼/행 교체
    - 범위: 슬라이스, Vec, 배열 등 인덱싱 가능한 컬렉션
    - 안전성: 동일 슬라이스 내 유효 인덱스여야 함; 같은 인덱스를 주면 no-op
    - 예시: 슬라이스의 두 원소 교환

```rust
fn main() {
    let mut xs = [1, 2, 3, 4];
    xs.swap(1, 3); // 2와 4 자리 바꿈
    assert_eq!(xs, [1, 4, 3, 2]);
}
```

- 예시: 행렬의 두 행 교환
```rust
fn main() {
    let mut m = [
        [1, 2, 3, 4],
        [5, 6, 7, 8],
        [9,10,11,12],
        [13,14,15,16],
    ];

    m.swap(0, 2); // 0번째 행과 2번째 행 자리 바꿈

    assert_eq!(m[0], [9,10,11,12]);
    assert_eq!(m[2], [1, 2, 3, 4]);
}
```

- 예시: 선택 정렬에서 사용
```rust
fn selection_sort(xs: &mut [i32]) {
    let n = xs.len();
    for i in 0..n {
        let mut min_idx = i;
        for j in (i+1)..n {
            if xs[j] < xs[min_idx] {
                min_idx = j;
            }
        }
        if min_idx != i {
            xs.swap(i, min_idx);
        }
    }
}
```
```rust
fn main() {
    let mut xs = [5, 3, 4, 1, 2];
    selection_sort(&mut xs);
    assert_eq!(xs, [1, 2, 3, 4, 5]);
}
```
## 실전 팁
- copy_from_slice vs. clone_from_slice:
    - copy_from_slice는 원소를 “복사”합니다. Copy가 아닌 타입도 내부적으로 복제하여 이동하지만, 값 크기가 크면 비용이 큽니다.
    - clone_from_slice는 각 원소의 clone()을 호출합니다. 원소 타입이 Clone를 효율적으로 구현했다면 더 적합할 수 있습니다.
- 성능/안전:
    - 길이가 같은지 확실하지 않다면 assert_eq!(a.len(), b.len())로 방어하고, 필요한 경우 zip으로 요소별 복사를 수행.
    - swap은 O(1)이고, 소유권/할당을 건드리지 않아 매우 저비용입니다. 인덱스 유효성만 주의.

---

## 실전 예제

```rust
pub ctrl: Vec<Point4D>
let a = on_idx_row_major(s.nu, i, j);
let b = on_idx_row_major(s.nu, n - i, j);

s.ctrl.swap(a, b);
```
---




