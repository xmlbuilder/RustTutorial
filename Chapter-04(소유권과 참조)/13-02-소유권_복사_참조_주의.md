# 🔑 소유권 / 복사 / 참조 핵심 요약

| 타입/상황         | 특징 또는 동작         | 비고 또는 해결 방법           |
|-------------------|------------------------|-------------------------------|
| `Copy` 타입       | 값 복사됨              | 예: `i32`, `bool`, `char`     |
| `Clone` 가능한 타입 | 명시적 복사 필요       | `x.clone()` 호출 필요         |
| `String`, `Vec` 등 | move 발생              | `clone()` 또는 `into_iter()` 사용 |
| `v[0]`            | `&T` 반환 (참조)       | 직접 move 불가, 참조만 가능   |


## `#[derive(Copy, Clone)]`

Rust에서 `#[derive(Copy, Clone)]` 을 매크로처럼 자동으로 붙이는 건  
편리하지만 위험할 수 있는 선택입니다.  
특히 구조체가 heap 자원을 소유하고 있을 때는 더 조심해야 함.


## ⚠️ 왜 함부로 Copy, Clone을 붙이면 위험할까?
| 트레잇 / 상황       | 동작 또는 의미              | 주의사항 또는 위험 요소               |
|---------------------|-----------------------------|---------------------------------------|
| `Copy`              | 값이 자동 복사됨            | move가 발생하지 않아 자원 중복 해제 위험 |
| `Clone`             | 명시적 복사 가능 (`clone()`) | 깊은 복사 비용 발생 가능               |
| 구조체 내부에 `String`, `Vec`, `Box` | heap 자원 포함됨           | `Copy` 불가, `Clone` 시 비용 주의        |
| `Copy`를 잘못 붙인 경우 | move가 무시됨               | 의도하지 않은 복사 → 안전성 깨짐 가능   |


### 🧠 예시로 확인해볼까요?
```rust
#[derive(Copy, Clone)] // ❌ 위험
struct Person {
    name: String, // heap 자원
}
```

- String은 Copy가 아니므로 이 구조체는 Copy를 붙이면 컴파일 에러가 납니다.
- 하지만 만약 내부가 i32, bool 같은 Copy 타입이라면 붙는 순간 자동 복사가 됨.
- 이게 문제인 이유는: move가 필요한 상황에서도 복사가 일어나서 자원 해제가 중복될 수 있음

## ✅ 안전한 매크로 사용 원칙
| 매크로 / 트레잇        | 의미 또는 조건                     | 주의사항 또는 사용 팁                          |
|------------------------|-----------------------------------|------------------------------------------------|
| `#[derive(Copy)]`      | 값 복사 가능 (`Copy` 타입만)       | 내부 필드가 모두 `Copy`일 때만 사용 가능         |
| `#[derive(Clone)]`     | 명시적 복사 가능 (`clone()` 호출) | 깊은 복사 비용이 발생할 수 있으므로 주의         |
| `Clone` 직접 구현      | 복사 동작을 커스터마이징 가능      | 복사 방식 제어가 필요할 때 추천                  |

## 💬 결론
Rust는 자동보다 명시적인 설계가 안전한 언어입니다.
Copy, Clone은 편리하지만, 붙이는 순간 의미가 완전히 달라지기 때문에  
구조체의 내부 자원과 사용 목적을 정확히 알고 있어야 함.


---

# 컴파일러 유용성

- 컴파일러가 소유권, 복사, 참조, lifetime 관련 실수를 대부분 막아줍니다.  
    그래서 실수하더라도 **런타임에서 터지는 게 아니라 컴파일 단계에서 알려줌**.

## ✅ 컴파일러가 막아주는 대표적인 실수들
| 실수 유형             | 컴파일러 반응 또는 보호 기능         | 예시 또는 설명                                      |
|------------------------|--------------------------------------|-----------------------------------------------------|
| `Copy` 잘못 파생       | "Copy not implemented for type" 에러 | `String`, `Vec` 등은 `Copy` 불가                    |
| move 후 다시 접근      | "value moved here" 에러              | 소유권이 이동된 값에 다시 접근 시 차단              |
| `&mut` vs `&` 충돌     | "cannot borrow as mutable" 에러      | 가변 참조와 불변 참조가 동시에 존재할 수 없음       |
| lifetime 누락 또는 불일치 | "missing lifetime specifier" 등     | 참조가 유효하지 않은 범위에 접근 시 경고 및 차단     |
| dangling reference 위험 | "borrowed value does not live long enough" | 스코프 밖 참조 방지                              |

## 💬 결론
Rust는 **실수해도 컴파일러가 지켜준다** 는 점에서  
초보자에게도 안전하고, 고급 개발자에게도 신뢰를 주는 언어.  
그래서 마음 놓고 실험하고, 틀려보고, 고쳐가면서 배우는 게 Rust의 방식입니다.


---

# Copy, Clone

Copy, Clone 트레잇을 직접 구현하는 것은 매크로로 자동 파생시키는 것보다  
훨씬 더 의도를 명확히 표현하고, 안전하게 제어할 수 있는 방법입니다.

## ✅ 왜 직접 구현이 더 낫나?
| 방식                  | 설명 또는 특징                  | 제어 가능성 또는 위험 요소         | 비고 또는 추천 상황               |
|-----------------------|-------------------------------|-----------------------------------|----------------------------------|
| `#[derive(Copy, Clone)]` | 자동 복사 / 자동 클론 파생       | 내부가 `Copy` 불가일 경우 실수 유발 | 편리하지만 구조체 내부 확인 필수   |
| `impl Clone for T`    | 깊은 복사 / 얕은 복사 직접 제어   | 복사 방식 커스터마이징 가능         | 복사 비용이나 동작을 제어할 때 추천 |
| `impl Copy for T`     | 자동 복사 허용 (`Copy` 타입만)    | move 무시 위험                     | 내부가 모두 `Copy`일 때만 사용     |]


## 🔧 직접 구현 
```rust
#[derive(Debug)]
struct Person {
    name: String,
}

impl Clone for Person {
    fn clone(&self) -> Self {
        Person {
            name: self.name.clone(), // 명시적 복사
        }
    }
}
```

- 이렇게 하면 clone()이 어떤 방식으로 작동하는지 내가 직접 통제할 수 있음.
- 반면 `#[derive(Clone)]` 은 내부 필드의 clone()을 자동 호출하므로 복사 비용이나 동작을 세밀하게 조절할 수 없습니다.

## 💬 결론
Rust는 **자동보다 명시적인 설계가 안전한 언어** 입니다.  
특히 Copy, Clone은 자원 해제와 복사 비용에 직결되는 트레잇이기 때문에  
직접 구현하는 습관은 실전에서 큰 사고를 막아주는 방패가 됩니다.  

---



