# 불변 참조 / 가변 참조 공존
“동시에 여러 개의 가변 참조”나 “불변 참조와 가변 참조의 공존”을 금지.  
하지만 “메모리가 섞이지 않는다”는 전제 아래에서는 몇 가지 기법을 통해 동시 접근을 안전하게 흉내낼 수 있는 방법들이 존재합니다.

## 🧠 전제: 메모리가 섞이지 않는다는 뜻
- 접근하는 영역이 겹치지 않는다
→ 예: v[0]과 v[3]을 각각 가변 참조해도 서로 영향을 주지 않음
- 논리적으로 동시에 빌리지만 실제로는 순차적 처리
→ Rust가 컴파일 타임에 판단할 수 있으면 허용

### ✅ 빌릴 수 있는 기법들
### 1. split_at_mut() — slice를 안전하게 나누기
```rust
let arr = &mut [1, 2, 3, 4];
let (left, right) = arr.split_at_mut(2);
left[0] += 1;
right[1] += 1;
```

- &mut [T]를 겹치지 않는 두 부분으로 나눔
- Rust가 영역이 겹치지 않음을 보장할 수 있으므로 허용

### 2. raw pointer로 우회
```rust
let v = &mut [10, 20, 30];
let p1 = &mut v[0] as *mut i32;
let p2 = &mut v[2] as *mut i32;
unsafe {
    *p1 += 1;
    *p2 += 1;
}
```
- *mut T는 Rust의 안전성 검사에서 벗어남
- unsafe 블록 안에서 동시 가변 접근 가능
- 단, 진짜로 메모리 섞이면 UB(Undefined Behavior) 발생

### 3. RefCell<T> — 런타임 체크 기반 내부 가변성
```rust
use std::cell::RefCell;

let data = RefCell::new(vec![1, 2, 3]);
{
    let mut borrow = data.borrow_mut();
    borrow[0] += 1;
}
{
    let borrow = data.borrow();
    println!("{}", borrow[0]);
}
```

- RefCell<T>는 런타임에 borrow 체크
- 컴파일 타임엔 허용되지만, 중복 borrow 시 panic 발생

### 4. split_array_mut() — 배열을 안전하게 나누기 (Rust 1.50+)
```rust
let arr = &mut [1, 2, 3, 4];
let [a, b, c, d] = arr else { panic!() };
*a += 1;
*d += 1;
```

- 배열을 고정 크기 튜플로 분할해서
각 요소를 독립적으로 가변 참조 가능

### 5. Scoped 접근으로 컴파일러 설득
```rust
let mut v = vec![1, 2, 3];
{
    let r1 = &mut v[0];
    *r1 += 1;
}
{
    let r2 = &mut v[2];
    *r2 += 1;
}
```

- 스코프를 분리하면 Rust가
“동시 접근이 아니다”라고 판단해서 허용

### ❌ 불가능한 예시 (컴파일 에러)
let r1 = &v[0];
let r2 = &mut v[1]; // ❌ 불변 참조와 가변 참조가 공존



### 🔍 고급 기법 — 메모리가 섞이지 않는다는 전제 하에 빌릴 수 있는 방법들

| 기법               | 안전성 수준 | 특징 및 설명                                                                 |
|--------------------|-------------|------------------------------------------------------------------------------|
| `split_at_mut()`   | ✅ 안전      | slice를 겹치지 않는 두 부분으로 나눠서 각각 `&mut` 참조 가능                |
| `RefCell<T>`       | ⚠️ 런타임 체크 | 내부 가변성. 컴파일 타임엔 허용되지만 중복 borrow 시 panic 발생             |
| `raw pointer`      | ❌ unsafe    | `*mut T`로 우회. 메모리 충돌 시 UB 발생 가능. 반드시 `unsafe` 블록 필요     |
| `scoped 접근`      | ✅ 안전      | 스코프를 분리하면 컴파일러가 “동시 접근 아님”으로 판단해 허용               |
| `split_array_mut()`| ✅ 안전      | 배열을 고정 크기 튜플로 분할해 각 요소를 독립적으로 가변 참조 가능 (Rust 1.50+) |


### 💬 결론
Rust는 “동시 접근”을 금지하는 게 아니라 “동시로 겹치는 접근”을 금지하는 언어.  
메모리가 섞이지 않는다는 걸 컴파일러가 확신할 수 있게 설계하면 여러 방식으로 안전한 빌림이 가능합니다.

