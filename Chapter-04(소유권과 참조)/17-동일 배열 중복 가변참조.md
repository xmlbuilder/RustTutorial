# 동일 배열 중복 가변 참조
동일 배열을 가변 참조하면서 불변 참조 하는 경우나 두번 가변 참조하는 경우 문제가 발생한다.

```rust
#[inline] fn sort_pair(a: &mut f32, b: &mut f32) {
    if *a > *b {
        core::mem::swap(a, b);
    }
}

let mut isect1 = [0.0f32;2];
let mut isect2 = [0.0f32;2];
sort_pair(&mut isect1[0], &mut isect1[1]);
```   
```
    |
357 |     sort_pair(&mut isect1[0], &mut isect1[1]);
    |     --------- --------------  ^^^^^^^^^^^^^^ second mutable borrow occurs here
    |     |         |
    |     |         first mutable borrow occurs here
    |     first borrow later used by call
```    


## 🧠 에러의 본질
```rust
sort_pair(&mut isect1[0], &mut isect1[1]);
```

- isect1은 [f32; 2] 타입의 배열
- &mut isect1[0]을 먼저 빌림 → 첫 번째 가변 참조 발생
- 그 상태에서 &mut isect1[1]을 또 빌리면 → 같은 배열을 두 번 가변 참조하려는 시도
- Rust는 동일한 메모리 블록에 대해 동시에 여러 가변 참조를 허용하지 않음
- 그래서 E0499: second mutable borrow occurs here 에러가 발생

## ✅ 해결 방법: `split_at_mut()` 사용
Rust는 이런 상황을 위해 안전한 방법을 제공합니다.  
배열을 두 개의 비중첩 가변 슬라이스로 나누는 `split_at_mut()` 를 사용하면 해결:

```rust
let (a, b) = isect1.split_at_mut(1);
sort_pair(&mut a[0], &mut b[0]);
```

- split_at_mut(1)은 [0]과 [1]을 서로 겹치지 않는 두 슬라이스로 나눔
- 이제 a[0]과 b[0]은 서로 다른 슬라이스의 요소이므로 동시에 가변 참조 가능

## 해결된 실제 코드
```rust
    let (a, b) = isect1.split_at_mut(1);
    let (c, d) = isect2.split_at_mut(1);

    sort_pair(&mut a[0], &mut b[0]);
    sort_pair(&mut c[0], &mut d[0]);

    !(isect1[1] < isect2[0] || isect2[1] < isect1[0])
```

## ✨ 요약
| 상황                         | 해결 방법         | 설명                                                 |
|------------------------------|-------------------|--------------------------------------------------------|
| 동일 배열 요소에 중복 가변 참조 | `split_at_mut()`  | 배열을 겹치지 않는 두 슬라이스로 나눠 안전하게 가변 참조를 얻음 |


--- 

# `split_at_mut()` 상세

split_at_mut()는 Rust에서 가변 슬라이스를 안전하게 두 부분으로 나누는 메서드.  
이 메서드는 중첩된 가변 참조를 피하면서 동일한 슬라이스의 서로 다른 부분을 동시에 수정할 수 있음.

## 🧠 의미와 정의
```rust
fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T])
```

- self: &mut [T] 타입의 가변 슬라이스
- mid: 나눌 기준 인덱스
- 반환값: 두 개의 겹치지 않는 가변 슬라이스 (&mut [T], &mut [T])
즉, split_at_mut(n)은 슬라이스를 [0..n]과 [n..]으로 나눠서  
동시에 가변 참조를 얻을 수 있게 해주는 안전한 방법.  

## ✅ 예제
```rust
let mut data = [1, 2, 3, 4, 5];
let (left, right) = data.split_at_mut(2);

left[0] = 10;
right[0] = 99;

assert_eq!(data, [10, 2, 99, 4, 5]);
```

left는 `[1, 2]`, right는 `[3, 4, 5]`  
서로 겹치지 않기 때문에 Rust가 동시 가변 참조를 허용함


## 🔒 왜 중요한가?
Rust는 메모리 안전성을 보장하기 위해  
동일한 슬라이스에서 중첩된 가변 참조를 금지.  
split_at_mut()는 이 제한을 안전하게 우회할 수 있는 도구.  

## ✨ 요약
| 상황 또는 기능             | 반환 타입             | 설명                                                                 |
|----------------------------|------------------------|----------------------------------------------------------------------|
| 슬라이스를 두 부분으로 분할 | `(&mut [T], &mut [T])` | 겹치지 않는 두 가변 슬라이스를 반환하여 동시에 안전하게 수정 가능     |

이 메서드는 특히 정렬, 비교, 병합 같은 알고리즘에서  
배열의 두 요소를 동시에 수정해야 할 때 아주 유용.


--- 
# 다른 해결 방법

## 1) 지금처럼 split_at_mut (OK)
```rust
let (a, b) = isect1.split_at_mut(1);
let (c, d) = isect2.split_at_mut(1);

sort_pair(&mut a[0], &mut b[0]);
sort_pair(&mut c[0], &mut d[0]);
```

## 2) 더 간단히: `swap` 으로 정렬 (매크로/함수 없이)
```rust
if isect1[0] > isect1[1] { isect1.swap(0, 1); }
if isect2[0] > isect2[1] { isect2.swap(0, 1); }
```
→ 두 원소만 정렬할 땐 이게 제일 깔끔하고 borrow 문제 없음.  

### 또는 helper로:

```rust
#[inline]
fn sort2(a: &mut [f32; 2]) {
    if a[0] > a[1] { a.swap(0, 1); }
}

// 사용
sort2(&mut isect1);
sort2(&mut isect2);
```


## 3) `배열 패턴 분해` 로 두 참조 만들기
```rust
let [ref mut a0, ref mut a1] = isect1;
let [ref mut b0, ref mut b1] = isect2;
sort_pair(a0, a1);
sort_pair(b0, b1);
```
- 패턴 분해는 요소가 서로 다른 메모리임을 컴파일러가 알 수 있어서 안전.

---




