# Bias Segmentation 

## Biased Segment Length Generator

### 1. ë¬¸ì œ ì„¤ì •

**í•˜ë‚˜ì˜ ì§ì„  êµ¬ê°„**(ì „ì²´ ê¸¸ì´ `L`)ì„ ì—¬ëŸ¬ ê°œì˜ ì„¸ê·¸ë¨¼íŠ¸ë¡œ ë‚˜ëˆ„ëŠ” í•¨ìˆ˜.

- ì¡°ê±´ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.
  - ì „ì²´ ê¸¸ì´ëŠ” í•­ìƒ ì •í™•íˆ `L` ì´ ë˜ì–´ì•¼ í•œë‹¤.
  - ì¢Œì¸¡ ë ì„¸ê·¸ë¨¼íŠ¸ ê¸¸ì´ëŠ” `L_left` ê·¼ì²˜ì˜ **ì‘ì€ ê°’**.
  - ìš°ì¸¡ ë ì„¸ê·¸ë¨¼íŠ¸ ê¸¸ì´ëŠ” `L_right` ê·¼ì²˜ì˜ **ì‘ì€ ê°’**.
  - ê°€ìš´ë°ë¡œ ê°ˆìˆ˜ë¡ ì„¸ê·¸ë¨¼íŠ¸ ê¸¸ì´ê°€ ì¦ê°€í•˜ì—¬ ì–´ë–¤ **ìµœëŒ€ ê¸¸ì´ `L_max` ê·¼ì²˜ì—ì„œ í‰í‰í•˜ê²Œ ìœ ì§€** ëœë‹¤.
  - ì „ì²´ ê¸¸ì´ê°€ ì§§ìœ¼ë©´ `L_max` ê¹Œì§€ ë„ë‹¬í•˜ì§€ ëª»í•˜ê³  ë‹¤ì‹œ ë‚´ë ¤ê°€ëŠ” í˜•íƒœê°€ ëœë‹¤.
  - ì „ì²´ ê¸¸ì´ê°€ ê¸¸ë©´ ê°€ìš´ë°ì—ì„œ `L_max` ê·¼ì²˜ì˜ ê¸¸ì´ë¥¼ ê°€ì§„ ì„¸ê·¸ë¨¼íŠ¸ë“¤ì´ ì—¬ëŸ¬ ê°œ ìƒê¸°ê³ ,
    ì–‘ ëìœ¼ë¡œ ê°ˆìˆ˜ë¡ ì„œì„œíˆ ì¤„ì–´ë“œëŠ” **í¬ë¬¼ì„  / ì½”ì‚¬ì¸** ë¹„ìŠ·í•œ ëª¨ì–‘ì„ ê°€ì§„ë‹¤.

- ëª©í‘œëŠ” ë‹¤ìŒê³¼ ê°™ì€ í•¨ìˆ˜ë¥¼ ì„¤ê³„í•˜ëŠ” ê²ƒì´ë‹¤.

```text
input : total_length L
        left_min    L_left
        right_min   L_right
        max_length  L_max

output: n (ì„¸ê·¸ë¨¼íŠ¸ ê°œìˆ˜)
        segments[0..n-1] (ê° ì„¸ê·¸ë¨¼íŠ¸ ê¸¸ì´)
        ë‹¨, sum(segments) == L
```

### 2. ê¸°ë³¸ ì•„ì´ë””ì–´

- 1. **ì„¸ê·¸ë¨¼íŠ¸ ê°œìˆ˜ n** ì„ ëŒ€ëµì ìœ¼ë¡œ ì¡ëŠ”ë‹¤.  
  - ì§ì„  ì „ì²´ ê¸¸ì´ë¥¼ `L_max` ë¡œ ë‚˜ëˆ ì„œ ëŒ€ëµì ì¸ ê°œìˆ˜ë¥¼ êµ¬í•˜ê³ ,  
    ë„ˆë¬´ ì ê±°ë‚˜ ë„ˆë¬´ ë§ì§€ ì•Šë„ë¡ ë²”ìœ„ë¥¼ ì œí•œí•œë‹¤.
- 2. ê¸¸ì´ ë¶„í¬ë¥¼ **ëŒ€ì¹­ì ì¸ í”„ë¡œíŒŒì¼**(cosine / parabola ê³„ì—´)ë¡œ ë§Œë“ ë‹¤.  
  - ì–‘ ëì´ ì‘ê³  ê°€ìš´ë°ê°€ í° í˜•íƒœ (ë²¨ ëª¨ì–‘).
- 3. ì´ í”„ë¡œíŒŒì¼ì„ ê·¸ëŒ€ë¡œ ì“°ë©´ í•©ì´ `L` ê³¼ ë‹¤ë¥´ë¯€ë¡œ,  
  **ì „ì²´ë¥¼ ì–´ë–¤ ìŠ¤ì¼€ì¼ íŒ©í„°ë¡œ ê³±í•´ì„œ í•©ì´ ì •í™•íˆ `L` ì´ ë˜ê²Œ ë§Œë“ ë‹¤.**
- 4. í•„ìš”í•˜ë©´ ì²« ì„¸ê·¸ë¨¼íŠ¸ì™€ ë§ˆì§€ë§‰ ì„¸ê·¸ë¨¼íŠ¸ê°€ `L_left`, `L_right` ì— ë” ê°€ê¹ë„ë¡  
   ë ë¶€ë¶„ì—ì„œë§Œ ì‚´ì§ ë³´ì •í•œë‹¤.

- ì´ë•Œ í”„ë¡œíŒŒì¼ì€ ëŒ€ì¹­ êµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ ì¢Œìš° ëì´ ê°™ì„ ë•Œ ê°€ì¥ ë‹¨ìˆœí•˜ë‹¤ (`L_left == L_right`).  
- ì¢Œìš°ê°€ ë‹¤ë¥¼ ë•ŒëŠ” ë ë¶€ë¶„ë§Œ ë”°ë¡œ ì¡°ì •í•  ìˆ˜ ìˆë‹¤.


### 3. ì„¸ê·¸ë¨¼íŠ¸ ê°œìˆ˜ n ì„ íƒ

- ë¨¼ì € `L_max` ê¸°ì¤€ìœ¼ë¡œ ëŒ€ëµì ì¸ ê°œìˆ˜ë¥¼ ì¶”ì •í•œë‹¤.

```text
n_ideal = round( L / L_max )
```

- í•˜ì§€ë§Œ ì´ë ‡ê²Œ í•˜ë©´ ë„ˆë¬´ ì‘ì€ n ì´ ë‚˜ì˜¬ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë‹¤ìŒê³¼ ê°™ì´ ìµœì†Œ ê°œìˆ˜ì™€ ìµœëŒ€ ê°œìˆ˜ë¥¼ ë‘”ë‹¤.

```text
n_min = 3            # ìµœì†Œí•œ ì¢Œ/ìš°/ì¤‘ì•™ 3ê°œëŠ” ìˆì–´ì•¼ "ì˜¤ë¥´ë½ ë‚´ë¦¬ë½" êµ¬ì¡°ë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤.
n_max = 256          # ë„ˆë¬´ ì„¸ë¶„í™”ë˜ëŠ” ê²ƒì„ ë°©ì§€í•˜ê¸° ìœ„í•œ ìƒí•œ (ìƒí™©ì— ë”°ë¼ ì¡°ì • ê°€ëŠ¥)

n = clamp(n_ideal, n_min, n_max)
```

- ì—¬ê¸°ì„œ `clamp(a, lo, hi)` ëŠ”

```text
clamp(a, lo, hi) = max(lo, min(a, hi))
```

ì´ë‹¤.

- ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ”
  - `L` ì´ ì•„ì£¼ ì§§ìœ¼ë©´ `n = n_min` ìœ¼ë¡œ ê³ ì •.
  - `L` ì´ ê¸¸ìˆ˜ë¡ `n` ì´ ì»¤ì§€ë¯€ë¡œ ì¤‘ì•™ í‰í‰í•œ êµ¬ê°„ì´ ìì—°ìŠ¤ëŸ½ê²Œ ëŠ˜ì–´ë‚œë‹¤.

### 4. ëŒ€ì¹­ í”„ë¡œíŒŒì¼ ì •ì˜

#### 4.1. ì¸ë±ìŠ¤ì™€ ì •ê·œí™” ì¢Œí‘œ

- ì„¸ê·¸ë¨¼íŠ¸ ì¸ë±ìŠ¤ë¥¼ `i = 0 .. n-1` ë¼ê³  í•  ë•Œ, ì¤‘ì‹¬(ê°€ìš´ë°)ì— ëŒ€í•´ ëŒ€ì¹­ì´ ë˜ë„ë¡ ë‹¤ìŒê³¼ ê°™ì´ ì •ê·œí™”ëœ ì¢Œí‘œ `u_i` ë¥¼ ì •ì˜í•œë‹¤.

```text
center_index c = (n - 1) / 2.0
u_i = (i - c) / c         (ëŒ€ëµ -1.0 ~ +1.0 ë²”ìœ„)
```

- ì¦‰
  - `i = 0`       â†’ `u_0   â‰ˆ -1`
  - `i = c`       â†’ `u_c   =  0`
  - `i = n-1`     â†’ `u_{n-1} â‰ˆ +1`

- ëŒ€ì¹­ì„±ì„ ìœ„í•´ ì´í›„ ê³„ì‚°ì€ ì£¼ë¡œ `|u_i|` ë¥¼ ì‚¬ìš©í•œë‹¤.

#### 4.2. ê¸°ë³¸ í˜•íƒœ í•¨ìˆ˜ (ì½”ì‚¬ì¸ ê³„ì—´)

- ê°€ìš´ë°ê°€ ê°€ì¥ í¬ê³  ì–‘ ëì´ ê°€ì¥ ì‘ì€ í˜•íƒœë¥¼ ë§Œë“¤ê¸° ìœ„í•´, ë‹¤ìŒê³¼ ê°™ì€ **ì½”ì‚¬ì¸ ê¸°ë°˜ ì—”ë²¨ë¡œí”„** ë¥¼ ì‚¬ìš©í•œë‹¤.

```text
s = |u_i|               # 0 ~ 1 (ê°€ìš´ë° 0, ë 1)

base_profile(s) = 0.5 * (1.0 + cos(pi * s))
```

- íŠ¹ì§•:
  - `s = 0` (ê°€ìš´ë°) â†’ `base_profile = 1.0`
  - `s = 1` (ë)     â†’ `base_profile = 0.5 * (1 + cos(pi)) = 0`

- ì´ë¥¼ ì´ìš©í•´ ê° ì„¸ê·¸ë¨¼íŠ¸ì˜ "ê¸°ë³¸ ê¸¸ì´"ë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í•œë‹¤.

```text
L_mid  = L_max         # ê°€ìš´ë°ì—ì„œ ëª©í‘œí•˜ëŠ” ìµœëŒ€ ê¸¸ì´
L_edge = min(L_left, L_right)

profile_i = L_edge + (L_mid - L_edge) * base_profile( |u_i| )
```

- ê·¸ëŸ¬ë©´
  - ê°€ìš´ë° (`u_i = 0`) ì—ì„œëŠ” `profile_i = L_mid`.
  - ì–‘ ë (`|u_i| â‰ˆ 1`) ì—ì„œëŠ” `profile_i â‰ˆ L_edge`.
  - ê·¸ ì‚¬ì´ì—ì„œëŠ” ì½”ì‚¬ì¸ ëª¨ì–‘ìœ¼ë¡œ ë¶€ë“œëŸ½ê²Œ ë³€í™”í•œë‹¤.

ì¦‰, **ê¸°ë³¸ í”„ë¡œíŒŒì¼ì˜ í˜•íƒœë§Œ** ë§Œë“¤ì–´ë‘ê³  ì•„ì§ ì „ì²´ ê¸¸ì´ `L` ê³¼ëŠ” ë§ì¶”ì§€ ì•Šì•˜ë‹¤ê³  ë³´ë©´ ëœë‹¤.

---

### 5. ì „ì²´ ê¸¸ì´ L ì— ë§ë„ë¡ ìŠ¤ì¼€ì¼ë§

- í˜„ì¬ `profile_i` ë“¤ì˜ í•©ì€ `sum_profile = sum_i profile_i` ì´ë‹¤.  
- ìš°ë¦¬ê°€ ì›í•˜ëŠ” ê²ƒì€ `sum_i segments_i = L` ì´ë¯€ë¡œ, ë‹¤ìŒê³¼ ê°™ì´ **ìŠ¤ì¼€ì¼ íŒ©í„° `alpha`** ë¥¼ ê³„ì‚°í•œë‹¤.

```text
sum_profile = profile_0 + profile_1 + ... + profile_{n-1}
alpha = L / sum_profile
segments_i = alpha * profile_i
```

- ì´ë ‡ê²Œ í•˜ë©´ í•­ìƒ

```text
sum_i segments_i = alpha * sum_profile = L
```
ì´ ëœë‹¤.

- ì¦‰, **ëª¨ì–‘ì€ ê·¸ëŒ€ë¡œ ë‘ê³  ì „ì²´ ìŠ¤ì¼€ì¼ë§Œ ì¡°ì •** í•´ì„œ ê¸¸ì´ë¥¼ ì •í™•í•˜ê²Œ ë§ì¶˜ë‹¤.

---

### 6. ëì  ê¸¸ì´ ë³´ì • (ì„ íƒ ì‚¬í•­)

- ìœ„ ë°©ì‹ë§Œ ì‚¬ìš©í•˜ë©´, ì–‘ ë ì„¸ê·¸ë¨¼íŠ¸ ê¸¸ì´ëŠ” ëŒ€ëµ `alpha * L_edge` ê°€ ëœë‹¤.
- ì‚¬ìš©ìê°€ ì§€ì •í•œ `L_left`, `L_right` ì™€ **ì •í™•íˆ ì¼ì¹˜í•  í•„ìš”ëŠ” ì—†ì§€ë§Œ** ë„ˆë¬´ ë²—ì–´ë‚˜ë©´ ì´ìƒí•´ ë³´ì¼ ìˆ˜ ìˆë‹¤.
- í•„ìš”í•˜ë‹¤ë©´ ë‹¤ìŒê³¼ ê°™ì´ ëì ë§Œ ì‚´ì§ ë³´ì •í•  ìˆ˜ ìˆë‹¤.

- 1. ìŠ¤ì¼€ì¼ë§ê¹Œì§€ ëë‚œ `segments_i` ë¥¼ ì–»ëŠ”ë‹¤.
- 2. í˜„ì¬ ê°’ê³¼ ì›í•˜ëŠ” ê°’ì˜ ì°¨ì´ë¥¼ ê³„ì‚°í•œë‹¤.

```text
diff_left  = L_left  - segments_0
diff_right = L_right - segments_{n-1}
```

- 3. ì´ ì°¨ì´ë¥¼ **ê°€ìš´ë° ëª‡ ê°œ ì„¸ê·¸ë¨¼íŠ¸ì— ë¶„ì‚°**ì‹œì¼œì„œ ì´í•© L ì„ ë‹¤ì‹œ ë§ì¶˜ë‹¤.

  - ì˜ˆë¥¼ ë“¤ì–´, ì¸ë±ìŠ¤ `k = 1 .. n-2` (ì–‘ ë ì œì™¸) ì— ëŒ€í•´

```text
adjust_per_segment = (diff_left + diff_right) / (n - 2)
segments_k -= adjust_per_segment
```

- 4. ëì ì€ ë‹¤ìŒì²˜ëŸ¼ ì›í•˜ëŠ” ê°’ì— ë§ì¶˜ë‹¤.

```text
segments_0     = L_left
segments_{n-1} = L_right
```

- ì´ ê³¼ì •ì„ ê±°ì¹˜ë©´
  - ì „ì²´ í•©ì€ ë‹¤ì‹œ L ìœ¼ë¡œ ë§ì¶œ ìˆ˜ ìˆê³ ,
  - ëì  ê°’ì€ `L_left`, `L_right` ì— ë” ê°€ê¹ê²Œ ì¡°ì •ëœë‹¤.

- ëì  ë³´ì •ì€ í•„ìˆ˜ëŠ” ì•„ë‹ˆë©°, í•„ìš”í•œ ê²½ìš°ì—ë§Œ ì‚¬ìš©í•˜ë©´ ëœë‹¤.

---

### 7. ì „ì²´ ì•Œê³ ë¦¬ì¦˜ ìš”ì•½ (ë‹¨ê³„ë³„)

- ì…ë ¥: `L, L_left, L_right, L_max`  
- ì¶œë ¥: `n, segments[0..n-1]`

- 1. **ì„¸ê·¸ë¨¼íŠ¸ ê°œìˆ˜ n ì¶”ì •**

```text
n_ideal = round(L / L_max)
n_min   = 3
n_max   = 256
n       = clamp(n_ideal, n_min, n_max)
```

- 2. **ê¸°ë³¸ í”„ë¡œíŒŒì¼ ê³„ì‚°**

```text
c = (n - 1) / 2.0
L_edge = min(L_left, L_right)
L_mid  = L_max

for i in 0 .. n-1:
    u  = (i - c) / c            # -1 ~ +1
    s  = abs(u)                 #  0 ~ 1

    base = 0.5 * (1.0 + cos(pi * s))
    profile[i] = L_edge + (L_mid - L_edge) * base
```

- 3. **í•©ì„ L ì— ë§ì¶”ëŠ” ìŠ¤ì¼€ì¼ë§**

```text
sum_profile = sum(profile[i] for i in 0..n-1)
alpha = L / sum_profile

for i in 0 .. n-1:
    segments[i] = alpha * profile[i]
```

- 4. (ì„ íƒ) **ëì  ê¸¸ì´ ë³´ì •**


  - 4-1. ëì  ëª©í‘œê°’ê³¼ì˜ ì°¨ì´
```text
diff_left  = L_left  - segments[0]
diff_right = L_right - segments[n-1]
```
  - 4-2. ë‚´ë¶€ ì„¸ê·¸ë¨¼íŠ¸ì— ì°¨ì´ë¥¼ ë¶„ì‚°
    - ë‚´ë¶€ ì„¸ê·¸ë¨¼íŠ¸ê°€ 1ê°œ ì´í•˜ë¼ë©´ ìƒëµ
```text    
if n > 2:
    adjust = (diff_left + diff_right) / (n - 2)
    for i in 1 .. n-2:
        segments[i] -= adjust
```

  - 4-3. ëì ì€ ì›í•˜ëŠ” ê°’ì— ë§ì¶˜ë‹¤ (í˜¹ì€ ê·¼ì²˜ ê°’ìœ¼ë¡œ ì œí•œ)
```text
segments[0]     = L_left
segments[n-1]   = L_right
```

- 5. í•„ìš”í•˜ë©´ **ìµœì†Œ/ìµœëŒ€ ê¸¸ì´ í´ë¨í”„** ë¥¼ ì ìš©í•œë‹¤.

```text
for i in 0 .. n-1:
    segments[i] = max(segments[i], L_min_allowed)
    segments[i] = min(segments[i], L_max_allowed)
```

- ê·¸ë¦¬ê³  ë‹¤ì‹œ í•œ ë²ˆ í•©ì„ L ë¡œ ë§ì¶”ëŠ” ìŠ¤ì¼€ì¼ë§ì„ í•´ ì¤„ ìˆ˜ ìˆë‹¤.

---

### 8. Rust í•¨ìˆ˜ í˜•íƒœ ì˜ˆì‹œ (ê°œëµ)

- Rust ì½”ë“œ êµ¬ì¡°ëŠ” ëŒ€ëµ ë‹¤ìŒê³¼ ê°™ì´ ì¡ì„ ìˆ˜ ìˆë‹¤.

```rust
pub fn make_biased_segments(
    total_len: f64,
    left_min: f64,
    right_min: f64,
    max_len: f64,
) -> Vec<f64> {
    assert!(total_len > 0.0);
    assert!(max_len > 0.0);

    // 1) n ì¶”ì •
    let n_ideal = (total_len / max_len).round().max(3.0);
    let n = n_ideal.min(256.0) as usize;

    let mut profile = vec![0.0; n];

    let c = (n - 1) as f64 / 2.0;
    let l_edge = left_min.min(right_min);
    let l_mid  = max_len;

    // 2) í”„ë¡œíŒŒì¼ ìƒì„±
    for i in 0..n {
        let u = (i as f64 - c) / c;        // -1 .. +1
        let s = u.abs();                   //  0 .. 1

        let base = 0.5 * (1.0 + (std::f64::consts::PI * s).cos());
        profile[i] = l_edge + (l_mid - l_edge) * base;
    }

    // 3) í•©ì„ total_len ì— ë§ì¶”ê¸°
    let sum_profile: f64 = profile.iter().sum();
    let alpha = total_len / sum_profile;

    let mut segs: Vec<f64> = profile.iter().map(|v| v * alpha).collect();

    // 4) (ì˜µì…˜) ì¢Œ/ìš° ëì  ë³´ì •
    // ... í•„ìš”ì— ë”°ë¼ diff_left / diff_right ì¡°ì • ...

    segs
}
```

- ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ”
- `n` ì„ ì¡°ê¸ˆ ë” ì„¬ì„¸í•˜ê²Œ ì¡°ì •í•˜ê±°ë‚˜,
- `L` ì´ ë„ˆë¬´ ì§§ì•„ì„œ `L_max` ì— ë„ë‹¬í•˜ì§€ ëª»í•˜ëŠ” ê²½ìš°ë¥¼ ë³„ë„ ë¶„ê¸° ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤.

---

### 9. í–¥í›„ ê°œì„  í¬ì¸íŠ¸

- 1. **ë¹„ëŒ€ì¹­ ëì **  
  - í˜„ì¬ëŠ” `L_left`, `L_right` ê°€ ê°™ì€ ê²½ìš°ê°€ ê°€ì¥ ìì—°ìŠ¤ëŸ½ë‹¤.  
  - ì¢Œ/ìš°ê°€ í¬ê²Œ ë‹¤ë¥¼ ë•Œì—ëŠ”
    - ì™¼ìª½ì—ëŠ” `L_left` ê¸°ì¤€,
    - ì˜¤ë¥¸ìª½ì—ëŠ” `L_right` ê¸°ì¤€ìœ¼ë¡œ
  - ì„œë¡œ ë‹¤ë¥¸ ì—”ë²¨ë¡œí”„ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ í™•ì¥í•  ìˆ˜ ìˆë‹¤.
- 2. **í‰íƒ„ êµ¬ê°„ ê°•ì œ**  
  - ê°€ìš´ë°ì—ì„œ `L_max` ê·¼ì²˜ì˜ ê°’ì´ ì¼ì • êµ¬ê°„ ì´ìƒ ìœ ì§€ë˜ë„ë¡
    - ì¤‘ì•™ ëª‡ ê°œ ì¸ë±ìŠ¤ì— `profile_i = L_mid` ë¥¼ ê°•ì œë¡œ ì£¼ê³ ,
    - ì–‘ìª½ ë‚˜ë¨¸ì§€ ì¸ë±ìŠ¤ì—ë§Œ ì½”ì‚¬ì¸ ì—”ë²¨ë¡œí”„ë¥¼ ì ìš©í•˜ëŠ” ë°©ë²•ë„ ê°€ëŠ¥í•˜ë‹¤.
- 3. **ë°˜ë³µ/ìˆ˜ë ´ ë°©ì‹**  
   - ìœ„ ë°©ì‹ì€ ë‹¨ í•œ ë²ˆì˜ ìŠ¤ì¼€ì¼ë§ìœ¼ë¡œ `L` ì„ ì •í™•íˆ ë§ì¶˜ë‹¤.  
   - ë³´ë‹¤ ì •êµí•œ ì¡°ê±´(ì˜ˆ: íŠ¹ì • ì¸ë±ìŠ¤ì—ì„œ ì •í™•í•œ ê¸¸ì´ ìš”êµ¬)ì´ ìˆë‹¤ë©´
   - ì‘ì€ ì‹œìŠ¤í…œì„ ì„¸ì›Œì„œ **ìˆ˜ì¹˜ì ìœ¼ë¡œ ë°˜ë³µ/ìˆ˜ë ´** í•˜ëŠ” ë°©ì‹ë„ ì ìš©í•  ìˆ˜ ìˆë‹¤.


- ì´ ë¬¸ì„œëŠ” í˜„ì¬ ì‚¬ìš© ì¤‘ì¸ **bias ê¸°ë°˜ ì„¸ê·¸ë¨¼íŠ¸ ë¶„í•  ì•Œê³ ë¦¬ì¦˜** ì˜ ìˆ˜ì‹ê³¼ ì ˆì°¨ë¥¼ ì •ë¦¬í•œ ê²ƒì´ë‹¤.  
- í•„ìš”ì— ë”°ë¼ íŒŒë¼ë¯¸í„°(`n_min`, `n_max`, ì—”ë²¨ë¡œí”„ í•¨ìˆ˜ í˜•íƒœ ë“±)ë¥¼ ì¡°ì •í•˜ì—¬ ë©”ì‰¬ ë°€ë„ì™€ ë¶€ë“œëŸ¬ì›€ì„ ì»¨íŠ¸ë¡¤í•  ìˆ˜ ìˆë‹¤.

---

## ğŸ§  ì´ í•¨ìˆ˜ì˜ ì˜ë¯¸ì™€ AI í™œìš© ê°€ëŠ¥ì„±
### ğŸ” í•¨ìˆ˜ ëª©ì 
- biased_segments()ëŠ” ì „ì²´ ê¸¸ì´ë¥¼ ì£¼ì–´ì§„ ì¡°ê±´ì— ë”°ë¼ ë¹„ëŒ€ì¹­ì ìœ¼ë¡œ ë¶„í• í•˜ëŠ” í•¨ìˆ˜.
- ì–‘ ëì˜ ê¸¸ì´(left_len, right_len)ì™€ ìµœëŒ€ ê¸¸ì´(max_len)ë¥¼ ê³ ë ¤í•´ ì¤‘ì•™ì´ ë„“ê³  ì–‘ ëì´ ì¢ì€ í¬ë¬¼ì„  í˜•íƒœì˜ ë¶„í¬ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
- ì´ëŠ” mesh biasë‚˜ adaptive samplingì—ì„œ ìì£¼ ì“°ì´ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.

## ğŸ¤– AIì—ì„œì˜ í™œìš© ë°©ì‹
### 1ï¸âƒ£ Feature Engineering
- ì´ í•¨ìˆ˜ì˜ ì¶œë ¥ì¸ Vec<f64>ëŠ” ê³µê°„ì  ë¶„í•  íŒ¨í„´ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
- ì´ë¥¼ AI ì…ë ¥ìœ¼ë¡œ ì‚¬ìš©í•˜ë©´ ëª¨ë¸ì´ ê³µê°„ì  ì¤‘ìš”ë„, ë¶„í¬ì˜ ë¹„ëŒ€ì¹­ì„±, ê²½ê³„ ì§‘ì¤‘ë„ ë“±ì„ í•™ìŠµí•  ìˆ˜ ìˆìŒ.
- ì˜ˆ: ììœ¨ì£¼í–‰ì—ì„œ ë„ë¡œ ì¤‘ì•™ì€ ë„“ê²Œ, ê°€ì¥ìë¦¬ëŠ” ì´˜ì´˜í•˜ê²Œ ì²˜ë¦¬
### 2ï¸âƒ£ Mesh Bias í•™ìŠµ
- ë‹¤ì–‘í•œ left_len, right_len, max_len ì¡°í•©ìœ¼ë¡œ ìƒì„±ëœ ë¶„í¬ë¥¼ í•™ìŠµí•˜ë©´ ëª¨ë¸ì´ ì–´ë–¤ ì¡°ê±´ì—ì„œ ì–´ë–¤ biasê°€ ìƒê¸°ëŠ”ì§€ ì˜ˆì¸¡ ê°€ëŠ¥
- ì˜ˆ: ì‹œë®¬ë ˆì´ì…˜ì—ì„œ meshê°€ ë„ˆë¬´ ì¡°ë°€í•˜ê±°ë‚˜ í¬ë°•í•  ë•Œ ë°œìƒí•˜ëŠ” ì˜¤ì°¨ë¥¼ ë³´ì •
### 3ï¸âƒ£ Simulation-to-Real ë„ë©”ì¸ ì ì‘
- ì‹œë®¬ë ˆì´ì…˜ì—ì„œ ìƒì„±ëœ biased meshë¥¼ ì‹¤ì œ ì„¼ì„œ ë°ì´í„°ì™€ ë¹„êµí•´ ë„ë©”ì¸ ê°­ì„ ì¤„ì´ëŠ” í•™ìŠµì— ì‚¬ìš© ê°€ëŠ¥
- ì˜ˆ: LiDAR í¬ì¸íŠ¸ í´ë¼ìš°ë“œì—ì„œ ì‹¤ì œ ê±°ë¦¬ ë¶„í¬ì™€ ì‹œë®¬ë ˆì´ì…˜ ë¶„í¬ë¥¼ ë¹„êµ
### 4ï¸âƒ£ Neural Field / Implicit Function í•™ìŠµ
- ê³µê°„ì„ ì—°ì†ì ìœ¼ë¡œ í‘œí˜„í•˜ëŠ” ëª¨ë¸(SDF, NeRF ë“±)ì—ì„œ ìƒ˜í”Œë§ ë¶„í¬ë¥¼ ì¡°ì ˆí•˜ëŠ” í•¨ìˆ˜ë¡œ ì‚¬ìš© ê°€ëŠ¥
- ì´ í•¨ìˆ˜ë¡œ ìƒì„±ëœ ë¶„í¬ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì¤‘ìš” ì˜ì—­ì„ ë” ë§ì´ í•™ìŠµí•˜ë„ë¡ biasë¥¼ ì¤„ ìˆ˜ ìˆìŒ

## âœ… ê²°ë¡ 
ì´ í•¨ìˆ˜ëŠ” ë‹¨ìˆœí•œ ìˆ˜ì¹˜ ê³„ì‚°ì„ ë„˜ì–´ì„œ, AI ëª¨ë¸ì´ ê³µê°„ì  êµ¬ì¡°ë‚˜ ë¶„í¬ì˜ ë¹„ëŒ€ì¹­ì„±ì„ í•™ìŠµí•˜ëŠ” ë° ë§¤ìš° ìœ ìš©í•œ ë„êµ¬ê°€ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
íŠ¹íˆ mesh bias, adaptive sampling, domain adaptation, feature weighting ê°™ì€ ê³ ê¸‰ AI ì‘ìš©ì— ì í•©.

## ğŸ¦€ Rust: Feature ìƒì„± ì˜ˆì œ
```rust
use rand::Rng;

// ì´ë¯¸ ì •ì˜ëœ biased_segments() í•¨ìˆ˜ê°€ ìˆë‹¤ê³  ê°€ì •
fn main() {
    let total_length = 10.0;
    let left_len = 1.0;
    let right_len = 1.5;
    let max_len = 2.0;

    // ë¶„í¬ ìƒì„±
    let segments = biased_segments(total_length, left_len, right_len, max_len);

    // AI ì…ë ¥ featureë¡œ ë³€í™˜ (ì˜ˆ: normalize)
    let max_val = segments.iter().cloned().fold(f64::MIN, f64::max);
    let features: Vec<f64> = segments.iter().map(|x| x / max_val).collect();

    println!("Raw segments: {:?}", segments);
    println!("Normalized features: {:?}", features);

    // CSV ë“±ìœ¼ë¡œ ì €ì¥í•´ Python í•™ìŠµì— í™œìš© ê°€ëŠ¥
    let mut rng = rand::thread_rng();
    let labels: Vec<i32> = features.iter().map(|_| rng.gen_range(0..2)).collect();
    println!("Dummy labels: {:?}", labels);
}
```

ğŸ‘‰ ì—¬ê¸°ì„œ featuresëŠ” AI ì…ë ¥ìœ¼ë¡œ ì“°ì¼ ìˆ˜ ìˆëŠ” ë²¡í„°ì´ê³ , labelsëŠ” ì˜ˆì‹œìš© ë”ë¯¸ ë ˆì´ë¸”ì…ë‹ˆë‹¤.
Rustì—ì„œ CSVë¡œ ì €ì¥í•˜ë©´ PyTorchì—ì„œ ë°”ë¡œ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## ğŸ PyTorch: í•™ìŠµ ìƒ˜í”Œ ëª¨ë¸
```python
import torch
import torch.nn as nn
import torch.optim as optim

# ì˜ˆì‹œ ë°ì´í„° (Rustì—ì„œ ìƒì„±í•œ featuresë¥¼ ë¶ˆëŸ¬ì™”ë‹¤ê³  ê°€ì •)
features = torch.tensor([
    [0.1, 0.3, 0.5, 0.7],
    [0.2, 0.4, 0.6, 0.8],
    [0.05, 0.25, 0.45, 0.65]
], dtype=torch.float32)

labels = torch.tensor([0, 1, 0], dtype=torch.long)

# ê°„ë‹¨í•œ MLP ëª¨ë¸
class SimpleModel(nn.Module):
    def __init__(self, input_dim, hidden_dim, output_dim):
        super(SimpleModel, self).__init__()
        self.fc1 = nn.Linear(input_dim, hidden_dim)
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(hidden_dim, output_dim)

    def forward(self, x):
        x = self.fc1(x)
        x = self.relu(x)
        x = self.fc2(x)
        return x

model = SimpleModel(input_dim=4, hidden_dim=8, output_dim=2)

criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.01)

# í•™ìŠµ ë£¨í”„
for epoch in range(20):
    optimizer.zero_grad()
    outputs = model(features)
    loss = criterion(outputs, labels)
    loss.backward()
    optimizer.step()
    print(f"Epoch {epoch+1}, Loss: {loss.item():.4f}")
```

## âœ… ì •ë¦¬
- Rustì—ì„œ biased_segments()ë¡œ ë¶„í¬ ê¸°ë°˜ feature ë²¡í„°ë¥¼ ìƒì„±
- PyTorchì—ì„œ ê·¸ ë²¡í„°ë¥¼ ì…ë ¥ìœ¼ë¡œ ë°›ì•„ ê°„ë‹¨í•œ MLP ëª¨ë¸ì„ í•™ìŠµ
- ì‹¤ì œ ì‘ìš©ì—ì„œëŠ” ì´ featureê°€ mesh bias, adaptive sampling, domain adaptation ê°™ì€ AI ë¬¸ì œì— í™œìš©ë  ìˆ˜ ìˆìŒ

---

## í…ŒìŠ¤íŠ¸ ì½”ë“œ
```rust
#[cfg(test)]
mod tests_biased_segments2 {
    use nurbslib::core::math_extensions::{on_biased_segments, on_print_dist};

    #[test]
    fn test_short_edge() {
        let segs = on_biased_segments(40.0, 2.0, 2.0, 10.0);
        on_print_dist("short", &segs);
        assert!((segs.iter().sum::<f64>() - 40.0).abs() < 1e-6);
    }
```
```
[short] n = 7, total = 40.000000, min = 2.000000, max = 8.685714
segs = [2.0, 5.7142857142857135, 7.942857142857142, 8.685714285714285, 7.942857142857142, 
  5.7142857142857135, 2.0]
```
```rust
    #[test]
    fn test_medium_edge() {
        let segs = on_biased_segments(100.0, 3.0, 3.0, 10.0);
        on_print_dist("medium", &segs);
        assert!((segs.iter().sum::<f64>() - 100.0).abs() < 1e-6);
    }
```
```
[medium] n = 15, total = 100.000000, min = 3.000000, max = 8.923077
segs = [3.0, 4.571428571428571, 5.901098901098901, 6.989010989010989, 7.835164835164835, 
  8.439560439560438, 8.802197802197801, 8.923076923076923, 8.802197802197801, 8.439560439560438, 
  7.835164835164835, 6.989010989010989, 5.901098901098901, 4.571428571428571, 3.0]
```
```rust
    #[test]
    fn test_long_edge() {
        let segs = on_biased_segments(300.0, 3.0, 3.0, 12.0);
        on_print_dist("long", &segs);
        assert!((segs.iter().sum::<f64>() - 300.0).abs() < 1e-6);
    }
```
```
[long] n = 35, total = 300.000000, min = 3.000000, max = 11.610390
segs = [3.0, 3.983193277310924, 4.9067990832696715, 5.770817417876241, 6.5752482811306345, 
  7.320091673032849, 8.005347593582888, 8.631016042780749, 9.197097020626432, 9.703590527119939, 
  10.150496562261269, 10.53781512605042, 10.865546218487395, 11.133689839572193, 11.342245989304812, 
  11.491214667685256, 11.580595874713522, 11.61038961038961, 11.580595874713522, 11.491214667685256, 
  11.342245989304812, 11.133689839572193, 10.865546218487395, 10.53781512605042, 10.150496562261269, 
  9.703590527119939, 9.197097020626432, 8.631016042780749, 8.005347593582888, 7.320091673032849, 
  6.5752482811306345, 5.770817417876241, 4.9067990832696715, 3.983193277310924, 3.0]

```
### í…ŒìŠ¤íŠ¸ ì´ë¯¸ì§€
![Bias Segment Image](/image/bias_segments.png)


```rust
    #[test]
    fn test_asymmetric_ends() {
        let segs = on_biased_segments(150.0, 2.0, 5.0, 10.0);
        on_print_dist("asym", &segs);
        assert!((segs.iter().sum::<f64>() - 150.0).abs() < 1e-6);
    }
}
```
```
[asym] n = 21, total = 150.000000, min = 2.000000, max = 9.344361
segs = [1.9999999999999996, 3.242857142857142, 4.370676691729321, 5.383458646616542, 6.281203007518796, 
  7.063909774436089, 7.731578947368419, 8.284210526315789, 8.721804511278195, 9.044360902255638, 
  9.25187969924812, 9.344360902255639, 9.321804511278193, 9.18421052631579, 8.93157894736842, 
  8.56390977443609, 8.081203007518797, 7.4834586466165405, 6.770676691729321, 5.942857142857141, 
  4.999999999999999]
```

---








