# 외부 라이브러리

Rust에서는 "외부 라이브러리"라는 표현을 쓸 수 있지만,  
공식적으로는 **"외부 crate"**라는 용어가 더 정확하고 일관된 표현입니다.


## 🧠 Rust 용어 정리
| 용어         | 설명                                                                 |
|--------------|----------------------------------------------------------------------|
| `crate`      | 컴파일 단위. 라이브러리 또는 실행 파일로 구성되며, 하나의 루트 소스 파일을 가짐 |
| `package`    | 하나 이상의 crate를 포함하는 프로젝트 단위. `Cargo.toml`로 정의됨         |
| `Cargo.toml` | 패키지의 메타데이터, 의존성, 빌드 설정 등을 정의하는 설정 파일             |
| `lib.rs`     | 라이브러리 crate의 루트 소스 파일. `src/lib.rs`에 위치함                   |
| `main.rs`    | 실행 파일 crate의 루트 소스 파일. `src/main.rs`에 위치함                   |
| `workspace`  | 여러 개의 package를 하나로 묶어 공통 빌드/테스트/의존성 관리를 수행         |



## ✅ 예시
```
# Cargo.toml
[dependencies]
serde = "1.0"
```

- 여기서 serde는 외부 crate입니다.
- serde는 라이브러리 역할을 하지만, Rust에서는 이를 crate라고 부릅니다.
use serde::Serialize;

- use는 외부 crate의 내부 모듈을 가져오는 문법입니다.


## 🔍 Rust 개념 요약

| 용어           | 정의                                           | 예시 경로 또는 파일         | 설명 요약                                 |
|----------------|------------------------------------------------|-----------------------------|--------------------------------------------|
| `crate`        | 컴파일 단위. 라이브러리 또는 실행 파일         | `src/lib.rs`, `src/main.rs` | 하나의 루트 소스 파일을 가진 코드 묶음     |
| `package`      | 하나 이상의 crate를 포함하는 Cargo 프로젝트    | `Cargo.toml`                | crate를 포함하고 의존성을 정의함           |
| `workspace`    | 여러 package를 하나로 묶어 관리하는 구조       | 루트 `Cargo.toml`           | 공통 빌드/테스트/의존성 관리 가능          |
| `external crate` | 외부에서 가져온 라이브러리 crate              | `serde`, `tokio` 등         | `[dependencies]`에 명시하여 사용           |


Rust에서는 모든 라이브러리도 결국 하나의 crate로 취급되기 때문에,
**"외부 crate"**라는 표현이 더 기술적으로 정확하고 일관된 용어예요.



## 🧠 결론부터 말하면:
Rust는 소스 코드 기반으로 외부 crate를 가져옵니다.
즉, crates.io에서 해당 crate의 소스 전체를 다운로드해서
내 프로젝트에서 직접 컴파일하는 방식.

## 🔍 동작 흐름
- Cargo.toml에 crate를 기술하면
예:
[dependencies]
serde = "1.0"
- cargo build를 실행하면:
- crates.io에서 해당 버전의 소스 코드를 다운로드
- 내 프로젝트의 다른 crate들과 함께 로컬에서 컴파일
- 결과물은 target/ 디렉토리에 .rlib 또는 .exe로 생성됨
- Cargo.lock에 정확한 버전과 해시가 기록되어
다음 빌드에서도 동일한 소스를 사용함


## ✅ 외부 crate 소스 기반 컴파일의 장점

| 항목              | 설명                                                                 |
|-------------------|----------------------------------------------------------------------|
| `--release` 최적화 | 소스 기반 컴파일이므로 `--release` 옵션으로 성능 최적화 가능          |
| 투명성             | 외부 crate의 실제 소스를 로컬에 다운로드하므로 내부 동작을 분석 가능   |
| 보안성             | 바이너리가 아닌 소스를 직접 컴파일하므로 신뢰성과 검증 가능성 향상     |
| 디버깅 가능         | 소스가 있으므로 디버깅 시 스택 추적, 로깅 삽입 등이 자유로움           |
| 플랫폼 맞춤 빌드    | 내 OS/CPU 환경에 맞게 컴파일되므로 호환성과 성능이 높음               |

⚠️ 예외: cargo install
- cargo install some_tool은 바이너리 crate를 설치하는 명령어예요
- 이 경우에도 소스를 다운로드해서 컴파일한 후 .exe를 설치합니다
- 이미 컴파일된 바이너리를 받는 건 아니에요


## 🔍 외부 crate 기술 vs 설치 요약

| 방식             | 목적                          | 가져오는 대상     | 결과물 위치 또는 형태 |
|------------------|-------------------------------|--------------------|------------------------|
| `Cargo.toml`     | 프로젝트 의존성으로 명시       | 소스 코드          | `target/`에 `.rlib` 또는 `.exe` |
| `cargo install`  | CLI 도구 또는 바이너리 설치    | 소스 코드          | `$CARGO_HOME/bin/`에 `.exe` |
| 시스템 패키지    | OS 패키지 매니저로 설치        | 바이너리           | `/usr/bin/`, `C:\Program Files\` 등 |

Rust는 바이너리 배포보다 소스 중심의 생태계를 지향합니다.
덕분에 빌드 최적화, 보안, 디버깅에서 강력한 유연성을 제공하죠.

----

# 소스 위치
Rust에서 외부 crate를 Cargo.toml에 기술하면, 해당 crate의 소스 코드는 로컬에 다운로드되고,
컴파일된 결과물은 프로젝트의 target/ 디렉토리에 저장됩니다.

## 📦 외부 crate의 저장 위치
### 1. 소스 코드 위치
- 다운로드된 crate 소스는 다음 경로에 저장됩니다:
```
$CARGO_HOME/registry/src/
```


- 기본적으로 $CARGO_HOME은 ~/.cargo입니다 (Linux/macOS 기준)
- 예시 경로:
```
~/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.188/
```

이 경로에는 crates.io에서 받은 전체 소스 코드가 저장됩니다.
Rust는 이 소스를 기반으로 직접 컴파일합니다.


### 2. 컴파일 결과물 위치
- 컴파일된 .rlib, .exe 등은 프로젝트의 target/ 디렉토리에 저장됩니다:
```
your_project/
├── target/
│   ├── debug/
│   │   ├── deps/
│   │   └── your_binary
│   └── release/
```

- cargo build → target/debug/
- cargo build --release → target/release/

### 3. cargo install의 경우
- cargo install some_tool로 설치한 바이너리는 다음 경로에 저장됩니다:
```
$CARGO_HOME/bin/
```

- 예시:
```
~/.cargo/bin/ripgrep
```

이 경로는 $PATH에 등록되어 있으면 터미널에서 바로 실행할 수 있어요.


## 📦 외부 crate 저장 위치 및 결과물 요약

| 사용 방식         | 소스 저장 위치                 | 결과물 위치 또는 형태         | 설명                          |
|------------------|-------------------------------|-------------------------------|-------------------------------|
| `Cargo.toml`     | `~/.cargo/registry/src/`      | `your_project/target/`        | `.rlib`, `.exe` 등 직접 컴파일 |
| `cargo install`  | `~/.cargo/registry/src/`      | `~/.cargo/bin/`               | CLI 실행 파일 (`.exe`)        |
| 시스템 패키지    | 없음 (바이너리만 설치됨)       | `/usr/bin/`, `C:\Program Files\` 등 | OS 패키지 매니저 설치         |

---

# 소스 공개

Rust는 기본적으로 소스 기반 생태계라서 crates.io에 올리는 라이브러리는 소스 공개가 전제입니다.
하지만 상용화된 라이브러리를 만들고 소스를 공개하지 않고 배포하고 싶다면, 다음과 같은 방법들이 있습니다:

## 🧱 1. 바이너리 형태로 배포 (예: .rlib, .so, .dll)
- 라이브러리를 컴파일해서 .rlib 또는 .so/.dll 형태로 배포
- 사용자는 해당 바이너리를 링크해서 사용하고, 소스는 보지 못함
방법
- cargo build --release로 빌드
- target/release/deps/libyourlib.rlib 또는 .so 생성
- 사용자에게 바이너리와 함께 .h 또는 .rs 인터페이스만 제공
단점
- Rust는 바이너리 호환성이 약해서 Rust 버전, target triple이 다르면 깨질 수 있음
- 크로스 플랫폼 지원이 까다로움

## 🧱 2. FFI 기반 C 라이브러리로 포장
- Rust로 라이브러리를 만들고, C ABI로 내보낸 후 .so 또는 .dll로 배포
- 다른 언어에서도 사용 가능하고, 소스는 숨길 수 있음
예시
```
#[no_mangle]
pub extern "C" fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

- 이렇게 하면 C에서 add() 함수를 사용할 수 있고, Rust 내부 로직은 숨겨짐

## 🧱 3. SaaS 또는 서버 API로 제공
- 라이브러리를 직접 배포하지 않고, 기능을 서버 API 형태로 제공
- 사용자는 HTTP 요청으로 기능을 사용하고, 내부 로직은 완전히 비공개
장점
- 완전한 소스 보호
- 버전 관리, 로직 변경이 서버에서 자유로움

## 🧱 4. crates.io 대신 사설 저장소 사용
- crates.io는 소스 공개가 필수지만, 사설 registry를 만들면 소스 공개 없이 배포 가능
예시

- [cargo publish --registry your-private-registry]
- Git, S3, Nexus 등으로 사설 crate 저장소 구성

## ✅ 상용 라이브러리 배포 방식 요약

| 배포 방식         | 소스 공개 여부 | 결과물 형태     | 저장 위치 예시             | 특징                          | 비고                          |
|------------------|----------------|------------------|-----------------------------|-------------------------------|-------------------------------|
| `.rlib`, `.so`    | ❌ (가능)       | 바이너리 라이브러리 | `target/release/`           | Rust 프로젝트에 직접 링크      | Rust 버전/플랫폼 호환성 주의 |
| FFI `.so`, `.dll` | ❌              | C ABI 바이너리     | `dist/`, `bin/`, etc.       | 다양한 언어에서 사용 가능      | 인터페이스 설계 필요         |
| `cargo install`   | ✅              | 실행 파일 (`.exe`) | `~/.cargo/bin/`             | CLI 도구 배포에 적합           | 소스는 crates.io에 공개됨     |
| SaaS API          | ❌              | 없음 (서버 호출)   | 클라우드 또는 API 서버       | 완전한 소스 보호               | 네트워크 연결 필요            |
| 사설 registry     | 선택적          | crate 패키지       | Git/S3/Nexus 등              | Cargo 생태계 그대로 활용 가능  | 설정 복잡, 접근 제어 필요     |

---


# 사용 라이브러리 제작

상용 라이브러리를 소스 없이 바이너리 형태로 배포한다면,
그걸 **가져다 쓰는 쪽(사용자)**에서는 다음과 같은 방식으로 연동해야 합니다:

## 🧱 1. .rlib 또는 .so 바이너리 연동
사용자가 해야 할 일:
### 🧩 바이너리 라이브러리 연동 구성 요약
| 구성 요소       | 역할 또는 예시 코드                                                  |
|----------------|-----------------------------------------------------------------------|
| `.rlib`, `.so`, `.dll` | 컴파일된 라이브러리 바이너리 파일 (Rust 또는 FFI 기반)                |
| `.rs`, `.h`     | 라이브러리 인터페이스 정의 파일 (`.rs` for Rust, `.h` for C FFI)         |
| `build.rs`      | 빌드 시 바이너리 링크 설정 스크립트<br>예: `println!("cargo:rustc-link-lib=...")` |
| `extern crate`  | 외부 crate를 Rust 코드에서 참조하는 선언<br>또는 `use`로 모듈 가져오기       |
| `cargo` 설정    | `Cargo.toml`에서 의존성 및 링크 설정<br>예: `[dependencies]`, `[build-dependencies]`, `links` |


## 예시 build.rs:
```rust
fn main() {
    println!("cargo:rustc-link-search=native=./libs");
    println!("cargo:rustc-link-lib=static=my_lib");
}
```


## 🧱 2. FFI 방식으로 .so / .dll 연동
사용자가 해야 할 일:
### 🧩 FFI 기반 바이너리 연동 구성 요약

| 구성 요소         | 역할 또는 설명                                               |
|------------------|--------------------------------------------------------------|
| `.h` + `bindgen` | C 헤더 파일을 Rust로 바인딩하기 위한 도구 (`bindgen` 사용)     |
| `.so`, `.dll`     | 공유 라이브러리 바이너리 (Linux: `.so`, Windows: `.dll`)     |
| `extern "C"`     | Rust에서 C ABI로 외부 함수 선언 (`unsafe`로 호출해야 함)     |
| `LD_LIBRARY_PATH`| 런타임에 `.so` 파일의 경로를 시스템에 알려주는 환경 변수      |


## 🧱 3. SaaS API 방식
사용자가 해야 할 일:
### 🌐 SaaS / 외부 API 연동 구성 요약
| 구성 요소       | 역할 또는 설명                                               |
|----------------|--------------------------------------------------------------|
| `reqwest`, `ureq` | HTTP 요청을 보내기 위한 Rust 클라이언트 라이브러리             |
| API 키 / 토큰    | 인증을 위한 자격 증명. 헤더 또는 쿼리 파라미터에 포함됨         |
| JSON 파서        | 응답 데이터를 처리하기 위한 구조체 또는 `serde_json` 사용        |
| 에러 처리        | 네트워크 오류, 인증 실패, 응답 형식 오류 등을 핸들링            |
| 비동기 처리       | `async/await`를 사용하여 비동기 HTTP 요청 수행 (`reqwest` 기준) |

## 🧩 바이너리 라이브러리 연동 구성 요약

| 바이너리 종류     | 빌드 설정 (`build.rs`)                      | 인터페이스 파일 | 코드 참조 방식       | 런타임 설정 또는 주의사항 |
|------------------|---------------------------------------------|------------------|----------------------|---------------------------|
| `.rlib`          | `println!("cargo:rustc-link-lib=static=...")` | `.rs`            | `extern crate`, `use`| Rust 버전/타겟 호환성 주의 |
| `.so` / `.dll`   | `println!("cargo:rustc-link-lib=dylib=...")`  | `.h` + `bindgen` | `extern "C"` + unsafe| `LD_LIBRARY_PATH` 또는 시스템 PATH 설정 필요 |

---

# rlib ?

## 🧩 `.rlib` 관련 구성 요소 요약

| 구성 요소           | 설명 또는 역할                                               |
|--------------------|--------------------------------------------------------------|
| `.rlib`            | Rust가 컴파일한 라이브러리 바이너리 파일 (`Rust Library`)     |
| `cargo build`, `rustc` | `.rlib`를 생성하는 명령어 (`--release` 옵션으로 최적화 가능) |
| `extern crate`, `use` | 다른 crate에서 `.rlib`를 참조하는 방식 (`use`로 모듈 가져오기) |
| `target/debug/deps/`, `target/release/deps/` | `.rlib` 파일이 저장되는 디렉토리 (디버그/릴리즈 빌드에 따라 다름) |



## 📁 예시 경로
```
target/release/deps/libmy_lib-abc123.rlib
```

- my_lib: crate 이름
- abc123: 해시값 (의존성 충돌 방지용)

## 🧪 생성 예시
```
cargo new my_lib --lib
cd my_lib
cargo build --release
```

- 위 명령어를 실행하면 target/release/deps/에 .rlib 파일이 생깁니다
- 이 파일은 다른 Rust 프로젝트에서 path 또는 extern crate로 참조 가능

## ⚠️ 주의사항
- .rlib는 Rust 내부 포맷이라 Rust 프로젝트 간에만 호환됩니다
- Rust 버전, 컴파일 타겟이 다르면 호환되지 않을 수 있어요
- 외부에 배포할 때는 .so, .dll, 또는 FFI 방식이 더 안정적일 수 있어요



## 🧠 .rlib 내부 구조를 확인하거나 사용하는 방법
### ✅ 1. 공개된 인터페이스를 통해 사용
- .rlib를 만든 쪽에서 공개 API를 문서화하거나 .rs 헤더 파일을 제공해야 합니다.
- 사용자는 해당 구조체와 메서드의 시그니처를 보고 use 또는 extern crate로 참조합니다.
```rust
use my_lib::MyStruct;

let obj = MyStruct::new();
obj.do_something();
```

이 방식은 마치 C에서 .h 파일만 보고 .so를 사용하는 것과 유사합니다.


### ✅ 2. cargo doc으로 문서 생성
- .rlib를 만든 프로젝트에서 cargo doc --open을 실행하면
구조체, enum, trait, impl 등 모든 공개 항목이 HTML 문서로 생성됩니다.
- 이 문서는 .rlib를 사용하는 쪽에서 API를 이해하는 데 핵심 역할을 합니다.

### ✅ 3. IDE 자동 완성 및 타입 추론
- .rlib를 참조한 프로젝트에서 IDE(Rust Analyzer 등)를 사용하면
구조체와 메서드 목록을 자동으로 보여줍니다.
- 타입 추론도 가능하므로, 구조체를 직접 인스턴스화하거나 메서드를 호출할 수 있어요.

### ✅ 4. cargo expand로 매크로 포함된 코드 확인
- 매크로나 derive를 통해 생성된 impl이 궁금하다면 cargo expand를 사용해
실제 컴파일 시점의 코드가 어떻게 펼쳐지는지 확인할 수 있습니다.

### ✅ 5. 소스 없이 .rlib만 있을 경우
- 이 경우에는 공개된 문서 또는 .rs 헤더가 반드시 필요합니다.
- 그렇지 않으면 구조체 이름이나 메서드 시그니처를 알 수 없기 때문에
.rlib를 사용할 수 없습니다.


## ⚠️ `.rlib` 사용 및 구조 확인 요약

| 구성 요소   | 역할 또는 설명                                   |
|-------------|--------------------------------------------------|
| `.rs`       | 구조체(`struct`) 및 구현체(`impl`)가 정의된 소스 파일 |
| `cargo doc` | 공개된 API 문서를 자동 생성하여 구조와 메서드 확인 가능 |
| `.rlib`     | Rust가 컴파일한 라이브러리 바이너리. 내부 구조는 숨겨짐 |

Rust는 공개된 인터페이스를 기반으로 안전하게 라이브러리를 사용하는 철학을 갖고 있어요.
그래서 .rlib를 배포할 때는 반드시 문서화 또는 헤더 제공이 필요합니다.

---


# rlib 배포

Rust에서 .rlib 바이너리를 만들고, 그와 함께 제공할 헤더 역할의 .rs 파일과 이를 사용하는 소비자 프로젝트 예제.
이 방식은 상용 라이브러리를 배포할 때 소스는 숨기고, 인터페이스만 공개하는 데 유용합니다.

## 🏗️ 1. 라이브러리 제작자 측 (my_lib)
```
📁 프로젝트 구조
my_lib/
├── src/
│   └── lib.rs
├── interface.rs   ← 사용자에게 제공할 헤더 역할의 파일
├── Cargo.toml
```

## 🔧 lib.rs (비공개)
```rust
pub struct SecretStruct {
    value: i32,
}

impl SecretStruct {
    pub fn new(v: i32) -> Self {
        SecretStruct { value: v }
    }

    pub fn double(&self) -> i32 {
        self.value * 2
    }
}
```

## 📤 interface.rs (공개 헤더 역할)
```rust
// 헤더 역할: 사용자에게 제공
pub struct SecretStruct {
    pub fn new(v: i32) -> Self;
    pub fn double(&self) -> i32;
}
```

이 파일은 실제 구현 없이 시그니처만 제공하는 문서용 .rs 파일입니다.
사용자는 이 구조를 보고 .rlib를 어떻게 사용할지 알 수 있어요.

## 🏗️ 빌드
```
cargo build --release
```

- 결과: target/release/libmy_lib.rlib

## 🧑‍💻 2. 사용자 측 프로젝트 (consumer)

📁 프로젝트 구조
```
consumer/
├── src/
│   └── main.rs
├── build.rs
├── Cargo.toml
├── libs/
│   └── libmy_lib.rlib

```

## 🔧 build.rs
```rust
fn main() {
    println!("cargo:rustc-link-search=native=./libs");
    println!("cargo:rustc-link-lib=static=my_lib");
}
```


## 📦 Cargo.toml
```
[package]
name = "consumer"
version = "0.1.0"
edition = "2021"
build = "build.rs"

[dependencies]
```

## 🚀 main.rs
```rust
extern crate my_lib;

use my_lib::SecretStruct;

fn main() {
    let s = SecretStruct::new(21);
    println!("Double: {}", s.double());
}
```

이 코드는 .rlib에 정의된 구조체와 메서드를 사용하는 예제입니다.
실제 구현은 없지만, interface.rs를 보고 사용자가 올바르게 호출할 수 있어요.



## ✅ `.rlib` 기반 라이브러리 배포 및 사용 요약

| 구성 파일       | 역할 또는 설명                                 |
|----------------|--------------------------------------------------|
| `lib.rs`       | 라이브러리의 실제 구현. 공개하지 않고 `.rlib`로 컴파일됨 |
| `interface.rs` | 사용자에게 제공할 헤더 역할의 `.rs` 파일. 구조체 및 메서드 시그니처만 포함 |
| `.rlib`        | Rust가 생성한 바이너리 라이브러리. `target/release/`에 위치 |
| `build.rs`     | `.rlib`를 링크하기 위한 설정 스크립트 (`cargo:rustc-link-lib=...`) |
| `main.rs`      | 사용자 프로젝트에서 `.rlib`를 참조하여 기능을 사용하는 코드 |


----

# 바이너리 라이브러리를 어떻게 링크 지시
Rust의 build.rs 스크립트에서 컴파일러에게 바이너리 라이브러리를 어떻게 링크할지 지시하는 명령입니다.


## 🔧 println!("cargo:rustc-link-search=native=./libs");
- 이 명령은 Rust 컴파일러에게 라이브러리를 찾을 디렉토리 경로를 추가하라는 뜻입니다.
- native=./libs는 현재 프로젝트의 libs 폴더를 링커의 검색 경로에 포함시키는 거예요.
- 즉, ./libs 안에 있는 .rlib, .a, .so, .dll 같은 파일을 찾을 수 있게 해줍니다.
### 🔍 이건 rustc -L native=./libs와 같은 효과를 줍니다.


## 🔧 println!("cargo:rustc-link-lib=static=my_lib");
- 이 명령은 Rust 컴파일러에게 my_lib라는 이름의 정적 라이브러리를 링크하라는 뜻입니다.
- static=my_lib은 libmy_lib.a 또는 libmy_lib.rlib 같은 파일을 의미합니다.
- 이 라이브러리는 앞서 지정한 ./libs 경로에서 찾게 됩니다.
### 🔍 이건 rustc -l static=my_lib와 같은 효과를 줍니다.


## 🧠 전체 동작 흐름
- build.rs가 실행됨
- cargo는 이 출력 메시지를 읽고 컴파일러에 전달
- 컴파일러는 ./libs에서 libmy_lib.rlib를 찾고 링크
- 최종적으로 사용자 코드에서 extern crate my_lib 또는 use my_lib::...로 기능을 사용할 수 있음

## ✅ `build.rs` 링크 설정 요약
| 명령어                          | 의미 또는 대상 경로/이름 |
|--------------------------------|---------------------------|
| `rustc-link-search=native=./libs` | 컴파일러가 라이브러리를 찾을 디렉토리 (`./libs`) |
| `rustc-link-lib=static=my_lib`    | 정적 라이브러리 `libmy_lib.rlib` 또는 `libmy_lib.a`를 링크 |

---



