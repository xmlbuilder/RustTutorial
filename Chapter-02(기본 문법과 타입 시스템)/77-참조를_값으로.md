# 참조를 값으로

Rust에서 &char, &str처럼 참조 타입을 받았을 때 이를 값 타입인 char, str, String으로 바꾸는 방법을 전반적으로 정리.

### 🔤 `&char` → `char` 변환 방법

| 상황                     | 방법                  | 설명                                 |
|--------------------------|-----------------------|--------------------------------------|
| 참조 해제                | `*c`                  | 가장 간단한 방법, 복사됨             |
| 명시적 복제              | `c.clone()`           | `Clone` 트레이트를 이용한 복제       |
| 소유권 복사              | `c.to_owned()`        | `char`에서는 `clone()`과 동일하게 동작 |

```rust
let c: &char = &'A';
let ch: char = *c; // 또는 c.clone()
```
- char는 Copy 타입이므로 clone()을 쓰든 to_owned()를 쓰든 모두 단순 값 복사일 뿐.

### 🧵 `&str` → `String` 변환 방법

### ✅ 가장 일반적인 변환: `&str` → `String`

| 메서드         | 반환 타입 | 설명                                      |
|----------------|-----------|-------------------------------------------|
| `.to_string()` | `String`  | 표준적인 방법, 문자열을 복제하여 소유권 획득 |
| `.to_owned()`  | `String`  | `Clone` 기반 복제, `to_string()`과 동일한 결과 |
| `.into()`      | `String`  | 타입 추론이 가능한 경우 간결하게 사용 가능   |

```rust
let s: &str = "hello";
let string1 = s.to_string();
let string2 = s.to_owned();
let string3: String = s.into();
```
### ⚠️ &str → str은 직접 불가능
- str은 unsized 타입이라서 직접 사용할 수 없습니다
- 항상 `&str` 또는 `String` 으로 다뤄야 합니다
- str은 항상 slice(&str) 또는 owned-buffer(String)으로만 사용할 수 있다.

### 📌 str이 unsized라 단독으로 사용할 수 없는 이유
- str은 UTF-8 바이트 시퀀스의 미완성 개념 타입입니다.
- 그래서 아래는 불가능합니다.
```rust
let x: str; // ❌
```
- 하지만 slice 형태는 가능:
```rust
let x: &str = "hello";
```
### 🔁 `String` → `&str` 변환 방법

| 메서드       | 반환 타입 | 설명                                 |
|--------------|------------|--------------------------------------|
| `.as_str()`  | `&str`     | `String` 내부의 문자열 참조를 반환     |
| `&s[..]`     | `&str`     | 슬라이스 문법으로 전체 문자열 참조     |

```rust
let s: String = String::from("hello");
let slice1: &str = s.as_str();
let slice2: &str = &s[..];
```

### 🔡 `char` ↔ `String` 변환 방법

| 변환 방향     | 방법                                      | 설명                                      |
|---------------|-------------------------------------------|-------------------------------------------|
| `char` → `String` | `c.to_string()`, `String::from(c)`     | 단일 문자로 구성된 문자열 생성            |
| `String` → `char` | `s.chars().next()`                     | 문자열의 첫 번째 문자를 `Option<char>`로 반환 |

```rust
let c: char = 'A';
let s: String = c.to_string();

let s2 = String::from("Z");
let maybe_char = s2.chars().next(); // Option<char>
```

### 🧠 요약 표 (Markdown)
| From      | To         | 방법                     |
|-----------|------------|--------------------------|
| `&char`   | `char`     | `*c`, `c.clone()`        |
| `&str`    | `String`   | `.to_string()`, `.to_owned()`, `.into()` |
| `String`  | `&str`     | `.as_str()`, `&s[..]`    |
| `char`    | `String`   | `.to_string()`, `String::from(c)` |
| `String`  | `char`     | `.chars().next()`        |

---

# 일반적인 경우

char, String 외에도 Rust에서는 다양한 타입에서 clone()을 사용할 수 있습니다.  
하지만 모든 경우에 무조건 clone()을 쓰는 게 정답은 아니고, 상황에 따라 더 적절한 방법이 있을 수 있음.  
아래에 일반적인 경우들을 정리.  

### ✅ 일반적으로 `clone()`을 써도 되는 경우

| 타입 예시                  | 조건 또는 설명                          |
|----------------------------|-----------------------------------------|
| `String`, `Vec<T>`         | 힙에 저장된 데이터의 복사본이 필요할 때 |
| `HashMap<K, V>`            | 전체 맵을 복제하고 싶을 때              |
| `Box<T>`                   | 힙에 있는 값을 복제하고 싶을 때         |
| `Rc<T>`, `Arc<T>`          | 참조 카운트를 증가시키고 싶을 때        |
| `Option<T>`, `Result<T, E>`| 내부 값이 `Clone`을 구현하고 있어야 함  |

```rust
let v1 = vec![1, 2, 3];
let v2 = v1.clone(); // 깊은 복사

let map1 = HashMap::new();
let map2 = map1.clone(); // 전체 복사
```

### ⚠️ `clone()`을 피해야 할 수도 있는 경우

| 상황                 | 대안       | 예시 또는 설명                         |
|----------------------|------------|----------------------------------------|
| 큰 데이터 구조 복제   | `Cow`      | 필요할 때만 복제, Copy-on-write 전략   |
| 값이 `Copy` 가능한 경우 | `Copy`     | `let b = a;`로 값 복사 가능             |
| 참조로 충분한 경우     | `&T`       | 복제 없이 참조만 넘겨도 충분한 경우     |


#### 예시:
```rust
fn print_name(name: &String) {
    println!("{}", name);
}

// 굳이 clone() 안 해도 됨
print_name(&my_name);
```

### 🧠 `Copy` vs `Clone` 요약

| 트레이트 | 특징                          | 대표 타입 예시                        |
|----------|-------------------------------|----------------------------------------|
| `Copy`   | 값이 작고 복사가 저렴함       | `i32`, `f64`, `bool`, `char`, `[T; N]` |
| `Clone`  | 힙 할당 등 복사 비용이 큼     | `String`, `Vec<T>`, `HashMap<K, V>`    |

## ✅ 결론
- `clone()` 은 값의 소유권이 필요하고, 참조로는 부족할 때 사용합니다.
- 하지만 성능에 민감한 코드에서는 남용을 피하고, 참조나 Cow(Copy-on-write) 같은 대안을 고려하는 것이 좋습니다.
- Copy 타입은 clone() 없이도 값 복사가 가능합니다.

---

