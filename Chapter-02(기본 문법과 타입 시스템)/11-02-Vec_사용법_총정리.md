# Vec 사용법 총 정리

## 🛠️ 생성 및 초기화
- `Vec::new()` : 빈 벡터 생성
- `Vec::with_capacity(n)` : 용량(capacity)을 지정하여 생성
- `vec![...]` : 매크로를 이용한 초기값 생성

### 샘플 코드
```rust
fn main() {
    let v1: Vec<i32> = Vec::new();
    let v2 = Vec::with_capacity(10);
    let v3 = vec![1, 2, 3];
    println!("{:?}", v3);
}
```

## ➕ 요소 추가
- `push(value)` : 끝에 요소 추가
- `insert(index, value)` : 지정한 위치에 요소 삽입
- `extend(iter)` : 다른 iterable의 요소들을 추가
### 샘플 코드
```rust
fn main() {
    let mut v = vec![1, 2];
    v.push(3);
    v.insert(1, 10); // [1, 10, 2, 3]
    v.extend([4, 5]);
    println!("{:?}", v);
}
```

## ➖ 요소 제거
- `pop()` : 마지막 요소 제거 및 반환
- `remove(index)` : 지정한 위치의 요소 제거
- `drain(range)` : 지정한 범위의 요소 제거 및 iterator 반환
- `clear()` : 모든 요소 제거
- `truncate(len)` : 지정한 길이 이후의 요소 제거
- `retain(f)` : 조건에 맞지 않는 요소 제거

### 샘플 코드
```rust
fn main() {
    let mut v = vec![1, 2, 3, 4, 5];
    v.pop(); // 제거된 값: Some(5) -> vec![1, 2, 3, 4]
    v.remove(1); // 제거된 값: 2 -> vec![1, 3, 4]
    v.drain(1..3); // 제거된 범위: [3, 4] -> vec![1]
    v.truncate(1); // [1] -> vec![1]
    
    v.truncate(0);
    println!("{:?}", v); // 출력: []

    v.clear(); // []
    println!("{:?}", v);
}
```

### ✅ 요약
| 호출         | 결과 벡터   |
|--------------|-------------|
| `truncate(3)`  | [1, 2, 3]   |
| `truncate(2)`  | [1, 2]      |
| `truncate(1)`  | [1]         |
| `truncate(0)`  | []          |


## 🔄 요소 접근 및 수정
- `get(index)` / `get_mut(index)` : 안전하게 요소 접근 (Option 반환)
- [] : 인덱스로 직접 접근 (panic 가능)
- `first()` / `last()` : 첫/마지막 요소 접근
- `split_at(index)` : 벡터를 두 부분으로 나눔

### 샘플 코드
```rust
fn main() {
    let mut v = vec![10, 20, 30];
    println!("{:?}", v.get(1)); // Some(20)
    if let Some(x) = v.get_mut(2) {
        *x += 5;
    }
    println!("First: {:?}, Last: {:?}", v.first(), v.last());
    let (left, right) = v.split_at(1);
    println!("Left: {:?}, Right: {:?}", left, right);
}
```

## 🔁 반복 및 변환
- `iter()` / `iter_mut()` : 반복자 반환
- `into_iter()` : 소유권을 넘기는 반복자
- `windows(n)` : n개씩 슬라이딩 윈도우
- `chunks(n)` / `chunks_mut(n)` : n개씩 나누기
- `split(|x| ...)` : 조건에 따라 나누기

### 샘플 코드
```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];
    for x in v.iter() {
        println!("Value: {}", x);
    }
    for x in v.windows(2) {
        println!("Window: {:?}", x);
    }
// Window: [1, 2]
// Window: [2, 3]
// Window: [3, 4]
// Window: [4, 5]

    for chunk in v.chunks(2) {
        println!("Chunk: {:?}", chunk);
    }
// Chunk: [1, 2]
// Chunk: [3, 4]
// Chunk: [5]

    let parts: Vec<_> = v.split(|&x| x == 3).collect();
    println!("{:?}", parts);
}
```

## 📦 용량 및 메모리 관리
- `capacity()` : 현재 할당된 용량
- `reserve(n)` / `reserve_exact(n)` : 용량 확보
- `shrink_to_fit()` : 필요 없는 용량 제거
- `len()` : 현재 요소 개수
- `is_empty()` : 비어있는지 확인

### 샘플 코드
```rust
fn main() {
    let mut v = Vec::with_capacity(5);
    println!("Capacity: {}", v.capacity());
    v.reserve(10);
    println!("New Capacity: {}", v.capacity());
    v.shrink_to_fit();
    println!("Shrunk Capacity: {}", v.capacity());
    println!("Length: {}, Empty: {}", v.len(), v.is_empty());
}

```

## 📤 이동 및 복사
- `clone()` : 복제
- `append(&mut other)` : 다른 벡터의 요소를 이동
- `split_off(index)` : 지정한 위치부터 분리하여 새 벡터 반환

### 샘플 코드
```rust
fn main() {
    let mut a = vec![1, 2];
    let mut b = vec![3, 4];
    a.append(&mut b); // b는 비워지고 a에 병합됨
    println!("a: {:?}, b: {:?}", a, b);

    let c = a.split_off(2); // a: [1, 2], c: [3, 4]
    println!("a: {:?}, c: {:?}", a, c);
}

```

## 🧪 정렬 및 검색
- `sort()` / `sort_by()` / `sort_unstable()` : 정렬
- `binary_search(&value)` : 이진 탐색
- `contains(&value)` : 포함 여부 확인
- `position(|x| ...)` : 조건에 맞는 첫 위치 반환

### 샘플 코드
```rust
fn main() {
    let mut v = vec![3, 1, 4, 2];
    v.sort();
    println!("Sorted: {:?}", v);

    let found = v.binary_search(&2);
    println!("Found 2 at index: {:?}", found);

    println!("Contains 3? {}", v.contains(&3));

    let pos = v.iter().position(|&x| x == 4);
    println!("Position of 4: {:?}", pos);
}

```

## 🧩 기타 유용한 메서드
- `reverse()` : 요소 순서 뒤집기
- `resize(new_len, value)` : 길이 조정
- `fill(value)` : 모든 요소를 지정 값으로 채움
- `dedup()` : 중복 제거
- `take()` : iterator에서 일부 요소 가져오기 (Vec 메서드는 아님, iterator 관련)

### 샘플 코드
```rust
fn main() {
    let v = vec![10, 20, 30, 40];
    let taken: Vec<_> = v.iter().take(2).collect();
    println!("Taken: {:?}", taken); // [10, 20]
}
```

# skip / take

Rust의 반복자(iterator)에도 Java의 `stream.skip(n)` 처럼 앞의 n개를 건너뛰는 기능이 있음.  
바로 `skip(n)` 메서드입니다.

## ✅ Rust의 skip(n) 사용법
```rust
fn main() {
    let v = vec![10, 20, 30, 40, 50];

    for x in v.iter().skip(2) {
        println!("{}", x); // 출력: 30, 40, 50
    }
}
```

- skip(2)은 앞의 두 요소(10, 20)를 건너뛰고 반복을 시작합니다.
- iter()는 &T를 반환하므로 x는 &i32 타입입니다.

## 🔁 take(n)과 조합도 가능
```rust
for x in v.iter().skip(1).take(2) {
    println!("{}", x); // 출력: 20, 30
}
```

- skip(1) → 20, 30, 40, 50
- take(2) → 20, 30

### 🔧 참고: Java vs Rust 비교
| 기능       | Java (`Stream`) | Rust (`Iterator`) |
|------------|------------------|-------------------|
| 건너뛰기    | `.skip(n)`        | `.skip(n)`         |
| 제한       | `.limit(n)`       | `.take(n)`         |
| 필터링     | `.filter(...)`    | `.filter(...)`     |
| 매핑       | `.map(...)`       | `.map(...)`        |

---
# 전체 적인 사용 함수 정리

## 🔧 Rust 컬렉션 메서드 정리
| 메서드           | 대상 컬렉션       | 기능 또는 역할                          | 비고 또는 특징                          |
|------------------|-------------------|------------------------------------------|------------------------------------------|
| `binary_search`  | `slice`, `Vec`    | 정렬된 컬렉션에서 이진 탐색 수행         | `Ord` 구현 필요, `Result` 반환           |
| `capacity`       | `Vec`, `String`   | 현재 할당된 용량 확인                    | `len()`과 다름                           |
| `chunk`          | `slice`           | 고정 크기 슬라이스로 나눔               | `chunks(n)` 형태                         |
| `contains`       | `slice`, `Vec`    | 특정 값 포함 여부 확인                   | `PartialEq` 필요                         |
| `dedup`          | `Vec`             | 연속된 중복 요소 제거                    | 정렬되지 않은 중복은 제거 안됨           |
| `extend`         | `Vec`, `HashSet`  | 다른 컬렉션의 요소를 뒤에 추가           | 반복자 기반 확장                         |
| `fill`           | `slice`           | 모든 요소를 지정 값으로 채움             | `fill(0)` 등                             |
| `filter`         | 반복자            | 조건에 맞는 요소만 남김                  | `iter().filter(\|x\| ...)`                 |
| `filter_map`     | 반복자            | `Option`을 걸러내며 매핑                 | `Some`만 남김                            |
| `insert`         | `Vec`, `HashMap`  | 지정 위치 또는 키에 값 삽입              | `Vec`은 인덱스 기반                      |
| `map`            | 반복자            | 요소를 변형                              | `iter().map(\|x\| ...)`                    |
| `new`            | 대부분의 컬렉션   | 빈 컬렉션 생성                           | `Vec::new()`, `HashMap::new()` 등        |
| `position`       | 반복자            | 조건을 만족하는 첫 인덱스 반환           | `Option<usize>` 반환                     |
| `push`           | `Vec`             | 요소를 뒤에 추가                         | `Vec`의 대표적 삽입 방식                 |
| `remove`         | `Vec`, `HashMap`  | 요소 제거                                | `Vec`은 인덱스, `HashMap`은 키 기반      |
| `resize`         | `Vec`             | 길이를 조정하며 새 값으로 채움           | `resize(5, 0)` 등                        |
| `reverse`        | `Vec`, `slice`    | 요소 순서를 뒤집음                       | `reverse()` 호출                         |
| `shrink_to_fit`  | `Vec`, `String`   | 용량을 현재 길이에 맞게 줄임             | 메모리 최적화                            |
| `skip`           | 반복자            | 앞의 n개 요소 건너뜀                     | `iter().skip(n)`                         |
| `split`          | `slice`, `str`    | 조건에 따라 나눔                         | `split(\|x\| ...)`, `str.split(",")` 등    |
| `take`           | 반복자            | 앞의 n개 요소만 가져옴                   | `iter().take(n)`                         |
| `truncate`       | `Vec`             | 지정 길이로 잘라냄                        | 뒤 요소 제거                             |
| `windows`        | `slice`           | 슬라이딩 윈도우로 나눔                   | `windows(n)` 형태                        |

---







