# Tuple Struct
Rust에서 구조체를 정의할 때 필드 이름 없이 순서 기반으로 필드를 정의하는 방식.  
일반적인 튜플과 비슷하지만, 타입 이름을 부여할 수 있어 더 명확한 의미를 전달할 수 있음.

## 🧩 튜플 구조체란?
```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
```

- Color와 Point는 각각 세 개의 i32 값을 가지는 튜플 구조체입니다.
- 필드 이름이 없고, .0, .1, .2처럼 인덱스로 접근합니다.
- 일반 튜플과 달리 Color, Point라는 타입 이름이 있으므로 의미를 명확히 할 수 있습니다.

```rust
fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
    println!("{} {}", black.0, origin.0);
}
```
- 핵심은 튜플처럼 사용하지만 타입 이름이 있어 의미를 부여할 수 있다는 점입니다.

## ✅ 장점
| 항목               | 설명                                                             |
|--------------------|------------------------------------------------------------------|
| 간결한 정의        | 필드 이름 없이 타입만 나열하면 되므로 코드가 짧고 명료함         |
| 의미 있는 타입 이름| Color, Point처럼 타입으로 의미를 구분할 수 있음                  |
| 튜플처럼 접근 가능 | .0, .1, .2로 인덱스 기반 접근이 가능                             |
| 타입 안전성        | 동일한 필드 구조라도 타입 이름으로 혼동을 줄일 수 있음           |

## ❌ 단점
| 항목               | 설명                                                             |
|--------------------|------------------------------------------------------------------|
| 가독성 저하        | .0, .1 같은 인덱스 접근은 필드 의미 파악이 어려움                |
| 유지보수 어려움    | 필드가 많아질수록 의미를 파악하기 어려움                         |
| 디버깅 불편        | 필드 이름이 없으므로 구조를 직관적으로 이해하기 어려움           |
| 문서화 필요        | 필드 의미를 주석이나 문서로 따로 설명해야 함                     |
| 확장성 부족        | 구조가 복잡해질 경우 명명된 구조체보다 불리함                    |

## 🔍 코드 분석
```rust
let color = Color(1, 2, 3);
let point = Point(1, 2, 3);
println!("point = {}, {}, {}", point.0, point.1, point.2);
println!("color = {}, {}, {}", color.0, color.1, color.2);
```

- Color와 Point는 같은 값을 가지지만 타입이 다름.
- 출력 결과는 동일하지만 의미는 다름.
```rust
let mut color1 = Color(4, 5, 6);
color1.0 = 9;
color1.1 = -1;
println!("color = {}, {}, {}", color1.0, color1.1, color1.2);
```
- 튜플 구조체는 `mutable` 로 선언하면 필드 값을 변경할 수 있음.

## 🎲 일반 튜플과 비교
```rust
let random_tuple = ("Here is a name", 8, vec!['a'], 'b', [8, 9, 10], 7.7);
```

- 일반 튜플은 타입 이름이 없고, 다양한 타입을 혼합할 수 있음.
- 튜플 구조체는 단일 타입 정의와 의미 있는 타입 이름을 가짐.

## 🧠 결론
튜플 구조체는 간단한 데이터 묶음에 적합하며, 의미 있는 타입 이름을 부여할 수 있다는 점에서 일반 튜플보다 더 안전하고 명확한 코드 작성이 가능합니다.  
하지만 필드 이름이 없기 때문에 가독성과 유지보수 측면에서는 일반 구조체보다 불리할 수 있습니다.
필드의 의미가 명확하지 않거나 구조가 복잡해질 경우에는 **명명된 필드 구조체(classic struct)** 를 사용하는 것이 더 바람직합니다.

---

# 실무 사용 사례 
Rust의 튜플 구조체(tuple struct)는 실무에서 주로 "newtype 패턴", 수학적 벡터 표현, 타입 안전 래핑 등에 사용됩니다.  
특히 단일 필드 래핑이나 간단한 데이터 캡슐화에 적합합니다.

## 🧠 실무에서 튜플 구조체가 쓰이는 대표 사례
### 1️⃣ Newtype 패턴 (단일 필드 래핑)
튜플 구조체는 기존 타입을 감싸서 의미를 부여하거나 타입 안전성을 높이는 데 사용됩니다.
```rust
struct UserId(u64);
struct Meters(f64);
```

- UserId와 Meters는 내부적으로 u64, f64지만 서로 다른 타입으로 취급됨
- 실수로 섞어 쓰는 것을 방지 → 타입 안전성 강화
- 실무에서 API, DB ID, 단위 표현 등에 자주 사용됨

### 2️⃣ 수학적 벡터 표현 (2D, 3D 등)
```rust
struct Vec2(f32, f32);
struct Vec3(f32, f32, f32);
```

- 게임 개발, 그래픽 처리, 물리 엔진 등에서 좌표나 방향 벡터 표현에 사용
- 필드 이름이 의미보다 위치가 중요할 때 유용

### 3️⃣ 단순한 타입 래핑 + Trait 구현
```rust
struct Password(String);

impl Password {
    fn is_strong(&self) -> bool {
        self.0.len() >= 8
    }
}
```

- String을 직접 쓰는 대신 Password로 감싸서 의미 부여
- Deref, From, Display 등 trait을 구현해 확장 가능

### 4️⃣ 타입 구분이 중요한 API 설계
```rust
struct Celsius(f64);
struct Fahrenheit(f64);
```

- 같은 f64라도 혼용되면 오류 발생 가능
- 튜플 구조체로 구분하면 컴파일러가 타입 혼동을 막아줌

### 5️⃣ 성능 최적화 및 메모리 레이아웃 제어
- 튜플 구조체는 필드 이름이 없기 때문에 메모리 접근이 빠르고 간결
- 구조체 필드 이름이 필요 없는 경우, 튜플 구조체가 더 효율적

## 📌 언제 일반 구조체보다 튜플 구조체를 쓰는가?
| 상황                         | 일반 구조체 `{ x: f32, y: f32 }` | 튜플 구조체 `(f32, f32)` 또는 `struct Wrapper(T)` |
|------------------------------|----------------------------------|---------------------------------------------------|
| 필드에 이름이 필요할 때      | ✅ 사용                          | ❌ 불편함                                          |
| 위치 기반 의미가 중요할 때   | ❌ 과도한 명명                    | ✅ 간결하고 직관적                                 |
| 단일 타입 래핑이 목적일 때   | ❌ 구조가 과함                   | ✅ `struct Wrapper(T)`로 의미 부여 가능            |
| API 타입 안전성 강화할 때    | ❌ 혼용 위험                     | ✅ 타입 구분 가능 (`UserId`, `Meters` 등)         |
| 수학적 벡터, 좌표 표현할 때  | ✅ 명확한 좌표 이름              | ✅ 간결한 벡터 표현 (`Vec2(f32, f32)`)            |


