# dereference (Defer)

Rust에서 &와 *는 참조(reference)와 역참조(dereference)를 나타내는 핵심 기호인데,  
이걸 정확히 이해하면 Rust의 메모리 모델과 안전성 철학이 훨씬 명확해짐.

## 🧭 *를 붙이는 기준: 언제 역참조가 필요한가?
### 1. 값을 직접 사용하려 할 때
```rust
let x = 5;
let y = &x;       // y는 x에 대한 참조
let z = *y;       // y를 역참조해서 실제 값 x를 가져옴
```

#### 🧠 용어 정리
| 한국어 용어     | 기호 | 영어 용어             | 설명                                                   |
|----------------|------|------------------------|--------------------------------------------------------|
| 참조           | &    | reference              | 값의 주소를 가리키는 포인터. 복사 없이 접근 가능         |
| 역참조         | *    | dereference            | 참조가 가리키는 실제 값을 꺼내는 연산                   |
| 역참조 연산자  | *    | dereference operator   | `*` 기호를 사용해 참조된 값을 가져오는 연산자           |
| Deref 트레잇   |      | Deref trait            | `*` 연산을 가능하게 하는 트레잇. 스마트 포인터에 주로 사용 |


예를 들어 Rust에서:
```rust
let x = 42;
let r = &x;     // r은 x에 대한 참조
let y = *r;     // dereference: r이 가리키는 값 x를 꺼냄
```

여기서 *r이 바로 dereference 연산이에요.

#### 📚 관련 트레잇
Rust에서는 Deref라는 트레잇이 이 동작을 정의합니다.  
Box<T>, Rc<T>, Arc<T> 같은 스마트 포인터는 이 트레잇을 구현해서 * 연산자를 사용할 수 있게 해줍니다.

- *y는 y가 가리키는 값을 꺼내는 동작입니다.
- 즉, *는 역참조(dereference) 연산자예요.

### 2. 필드 접근이나 메서드 호출 시에는 자동 deref
```rust
let s = String::from("hello");
let r = &s;
println!("{}", r.len()); // r은 &String인데 .len()은 자동 deref로 호출됨
```

- Rust는 자동 deref를 지원해서 .len()이나 .push() 같은 메서드 호출 시 `*` 를 생략할 수 있음.
- 하지만 값 자체를 복사하거나 비교하거나 연산할 때는 `*` 가 필요합니다.

### 🧩 Rust에서 *의 공식 용어
Rust에서는 `*` 를 **dereference operator (역참조 연산자)** 라고 부릅니다.  
- 이 연산자는 Deref 트레잇을 기반으로 동작합니다.
- Box<T>, Rc<T>, Arc<T> 같은 스마트 포인터도 Deref를 구현해서 *로 내부 값을 꺼낼 수 있어요.

### ✅ 정리: 언제 *를 쓰고 언제 안 쓰는가?
| 상황                     | * 필요 여부 | 설명                                      |
|--------------------------|-------------|-------------------------------------------|
| 값 자체를 꺼내서 사용       | 필요        | 참조를 역참조해서 실제 값을 가져올 때         |
| 메서드 호출 (.len(), .push()) | 불필요      | Rust가 자동 deref 수행함                    |
| 필드 접근 (r.name 등)       | 불필요      | 자동 deref로 필드 접근 가능                 |
| 비교, 연산, 복사 등         | 필요        | 값 자체가 필요하므로 명시적 deref 필요       |

## ✨ 예시 비교
```rust
let s = String::from("Rust");
let r = &s;

// 자동 deref
println!("{}", r.len()); // OK

// 명시적 deref
let s2 = *r;              // r은 &String → *r은 String
```

## 수식에서 사용

수식이나 계산식에서 *가 등장할 때는 역참조인지 곱셈인지 헷갈릴 수 있음.   
Rust에서는 이걸 문맥에 따라 다르게 해석.

## 🧠 *의 두 얼굴: 곱셈 vs 역참조
Rust에서 `*`는 문맥에 따라 두 가지 의미를 가집니다:

| 역할       | 기호 | 영어 용어           | 예시                          |
|------------|------|----------------------|-------------------------------|
| 곱셈       | *    | multiplication       | let x = 3 * 4;                |
| 역참조     | *    | dereference          | let y = *r; // r은 &i32 참조 |

📌 Rust는 **문맥(context)** 을 보고 *가 어떤 의미인지 판단합니다.


## 🔍 수식에서 혼동되는 예시
let x = 5;
let r = &x;
let y = *r + 2; // 역참조 후 덧셈


- 여기서 *r + 2는 x + 2와 같은 의미입니다.
- `*r` 이 먼저 평가되고, 그 결과에 + 2가 적용됩니다.
하지만 다음처럼 괄호 없이 쓰면 Clippy나 컴파일러가 경고할 수 있음:

```rust
let y = *r + 2 * 3;
```

이 경우 *r이 먼저 평가되고, 2 * 3은 곱셈이지만, 전체 수식이 복잡해지면서 가독성이 떨어질 수 있습니다.

### ✅ 해결 방법: 괄호로 명확하게 표현
```rust
let y = (*r) + (2 * 3);
```

### 🧩 Clippy가 경고하는 경우
Clippy는 다음과 같은 상황에서 경고를 줄 수 있음:
- `*` 가 수식 중간에 등장해서 역참조인지 곱셈인지 혼동될 수 있는 경우
- `*` 연산이 우선순위 때문에 의도와 다른 결과를 낼 수 있는 경우
  
예: let z = *a + *b * *c; → 괄호 없이 쓰면 해석이 어려워짐

## ✅ 정리: 수식에서 *를 쓸 때 주의할 점
| 상황                         | 권장 방식                          |
|------------------------------|------------------------------------|
| 역참조 후 연산               | 괄호로 명확히 표현: `(*r) + 2`     |
| 곱셈 연산                    | 그대로 사용: `2 * 3`               |
| 혼합된 수식 (`*r * *s + 1`) | 괄호로 구분: `(*r) * (*s) + 1`     |

## ✨ 보너스: 자동 deref가 안 되는 경우
- 수식에서는 자동 deref가 적용되지 않습니다.
- 메서드 호출이나 필드 접근에서는 자동 deref가 되지만, 수식에서는 명시적으로 `*` 를 써야 합니다.

---

## 🧠 Deref 트레잇이 하는 일
Deref는 Rust에서 스마트 포인터나 참조 타입이 내부 값을 꺼낼 수 있게 해주는 트레잇입니다.  
예를 들어 Box<T>는 T를 감싸는 타입인데, *box를 하면 T를 꺼낼 수 있어요.
```rust
use std::ops::Deref;

let b = Box::new(42);
let x = *b; // Deref 트레잇 덕분에 가능
```


## 🤖 자동 deref가 되는 경우
Rust는 메서드 호출이나 필드 접근에서는 Deref를 자동으로 적용. 그래서 * 없이도 잘 작동합니다.
```rust
let s = String::from("hello");
let r = &s;
println!("{}", r.len()); // r은 &String인데 .len()은 자동 deref됨
```
이건 Rust가 “아, 이 타입은 Deref를 구현. 그럼 내부 값으로 접근해도 되겠지” 하고 알아서 처리해줌.


### ❌ 자동 deref가 안 되는 경우
하지만 수식, 비교, 복사, 대입 같은 경우에는 자동 deref가 적용되지 않음.  
이럴 땐 명시적으로 *를 써야 합니다.

```rust
let r = &10;
let x = *r + 5; // OK
let y = r + 5;  // ❌ 에러: r은 &i32인데 + 연산은 i32에만 정의됨
```
이 차이 때문에 “어떤 데선 되는데, 어떤 데선 에러 납니다” 하는 혼란이 생기게 됨.


## 🧩 왜 Rust는 이렇게 했을까?
Rust는 명확성과 안전성을 중시하는 언어. 자동 deref는 편리하지만, 모든 곳에 적용하면 모호한 코드가 생길 수 있어요.  
그래서 Rust는:
- 메서드/필드 → 자동 deref 허용
- 수식/연산 → 명시적 deref 요구
이렇게 의도적으로 구분.

### ✅ 팁
- 메서드 호출, 필드 접근: 그냥 써도 됨 (자동 deref)
- 수식, 대입, 비교: 꼭 `*` 써야 함 (명시적 deref)
- 헷갈리면 괄호로 감싸서 명확하게 표현: `(*r) + 5`

---


## 🧠 Deref 없이 Box에서 값을 꺼내려면?
Box<T>는 힙에 데이터를 저장하고, 그 주소를 가지고 있는 스마트 포인터입니다.  
Deref가 없다면 *b는 컴파일 에러가 납니다. 대신, 내부 값을 꺼내려면 직접 꺼내는 메서드나 구조를 만들어야 해요.

## 🔧 직접 꺼내는 방식 (예시)
### 1. Box::into_inner() 사용 (Rust 1.65부터 안정화됨)
```rust
let b = Box::new(42);
let x = Box::into_inner(b); // b를 소비하고 내부 값 꺼냄
```
- 이 방식은 Box<T>를 소유권과 함께 소비하면서 내부 값을 꺼냅니다.
- b는 이후 사용할 수 없습니다.

### 2. *b 없이 직접 꺼내는 사용자 정의 타입 예시

```rust
struct MyBox<T>(T);

impl MyBox<i32> {
    fn get(&self) -> &i32 {
        &self.0
    }
}

let b = MyBox(42);
let x = *b.get(); // 직접 참조를 꺼낸 뒤 역참조
```

- 여기서는 Deref 없이 get() 메서드를 통해 참조를 꺼내고, 그걸 *로 역참조합니다.
- MyBox는 Box처럼 동작하지만 자동 deref는 안 됩니다.

### 🧩 왜 Deref가 중요한가?
- *b → 내부적으로 b.deref() 호출
- Deref가 없으면 * 연산이 불가능
- Rust는 Deref를 통해 스마트 포인터를 일반 참조처럼 쓸 수 있게 해줌

## ✅ 요약
| 상황               | 코드 예시                      | 설명                                 |
|--------------------|-------------------------------|--------------------------------------|
| Deref 있음         | let x = *b;                   | 자동 deref로 내부 값 꺼냄             |
| Deref 없음         | let x = Box::into_inner(b);   | 소유권을 넘기고 내부 값 꺼냄         |
| 사용자 정의 타입   | let x = *mybox.get();         | 직접 참조 꺼내고 명시적 역참조 필요  |

---


# 🧪 Deref 트레잇 직접 구현 예제
```rust
use std::ops::Deref;

// 사용자 정의 스마트 포인터
struct MyBox<T>(T);

// Deref 트레잇 구현
impl<T> Deref for MyBox<T> {
    type Target = T;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

// 사용 예
fn main() {
    let x = 5;
    let y = MyBox(x);
    // 역참조 연산자 사용 가능!
    println!("y = {}", *y); // Deref 덕분에 *y가 작동함
}
```


## 🔍 설명
- MyBox<T>는 Box<T>처럼 동작하는 튜플 구조체입니다.
- Deref 트레잇을 구현하면 `*y` 가 내부의 T를 꺼낼 수 있게 됩니다.
- type Target = T;은 `*y` 가 어떤 타입을 반환할지를 지정합니다.
- fn deref(&self) -> &T는 `*y` 가 내부 값을 참조할 때 호출되는 메서드입니다.

## ✨ 왜 이게 중요한가?
- 이걸 통해 사용자 정의 타입도 참조처럼 동작하게 만들 수 있음.
- Deref가 구현되면 Rust는 메서드 호출 시 자동으로 deref를 시도해서 더 유연한 코드가 됩니다.
- 예를 들어 &MyBox<String>을 &str처럼 사용할 수 있게 되죠.

---

Rust에서 "소비한다(consumes)"는 표현은 소유권을 넘기고, 원래 변수는 더 이상 사용할 수 없게 된다는 의미입니다.  
Box::into_inner(b)는 b의 소유권을 가져가서 내부 값을 꺼내는 함수인데, 이 과정에서 b는 무력화됩니다  
즉, 이후에 b를 다시 사용하려고 하면 컴파일 에러가 납니다.

## 🧠 왜 이런 방식이 필요한가?
Rust는 **소유권(ownership)**을 통해 메모리 안전성을 보장합니다.
Box<T>는 힙에 데이터를 저장하고 그에 대한 유일한 소유권을 갖습니다.
Box::into_inner(b)는 그 데이터를 꺼내면서 b의 소유권을 가져가므로, b는 더 이상 유효하지 않음.

## 🔍 예시로 확인해보기
```rust
fn main() {
    let b = Box::new(42);
    let x = Box::into_inner(b); // b의 소유권을 x로 이동

    println!("{}", x); // OK
    println!("{}", b); // ❌ 컴파일 에러: b는 더 이상 유효하지 않음
}
```

### 에러 메시지 예:
```
value borrowed here after move
```

## ✅ 요약
| 표현                     | 의미                                      |
|--------------------------|-------------------------------------------|
| Box::into_inner(b)       | b의 소유권을 가져가서 내부 값 반환         |
| "소비한다"               | b는 move되었고, 이후 사용할 수 없음         |
| 이후 b 사용 시           | 컴파일 에러 발생 (use after move)         |

Rust의 이런 소유권 모델은 처음엔 까다롭게 느껴질 수 있지만, 런타임 오류 없이 안전한 메모리 관리를 가능하게 해줌.

---

# String Defer

## 🧠 핵심 개념: String은 str로 Deref된다
Rust의 String 타입은 Deref 트레잇을 통해 str 타입으로 자동 변환됩니다:
```rust
impl Deref for String {
    type Target = str;

    fn deref(&self) -> &str {
        &self[..]
    }
}
```

즉, &String → &str로 자동 변환되며, str에 정의된 메서드들을 String에서도 바로 사용할 수 있게 됩니다.


## 🔍 len() 호출 흐름
```rust
let s = String::from("Rust");
let l = s.len();
```

### 이 코드의 내부 흐름은 다음과 같음:
- s.len()을 호출하려고 함
- 컴파일러는 String에 len()이 없다는 걸 확인
- Deref 트레잇을 통해 &String → &str로 강제 변환
- str::len() 메서드를 호출
즉, s.len()은 실제로는 (*s).len() → s.deref().len() → (&s[..]).len()으로 해석됩니다.

## ✅ 요약: 어떻게 포장되었는가?
| 단계            | 설명                                      |
|-----------------|-------------------------------------------|
| s.len() 호출     | String에는 len() 없음                    |
| Deref 적용       | String → str로 자동 변환                 |
| 실제 호출       | str::len() 호출됨                        |

## ✨ 보너스: 왜 이렇게 설계했을까?
- String은 힙에 저장된 UTF-8 바이트 배열을 감싸는 구조체
- str은 그 바이트 배열을 참조하는 슬라이스 타입
- Deref를 통해 String을 str처럼 사용할 수 있게 함
- 이 덕분에 String은 str의 모든 메서드를 “포장해서” 사용할 수 있음

## 자동 변환
 String 타입은 Deref 트레잇을 통해 str로 자동 변환되기 때문에,  
 우리가 String::len()이라고 쓴 것처럼 보여도 실제로는 &String → &str로 바뀐 다음 str::len()이 호출되는 것이에요.

## 🔍 다시 정리하면
let s = String::from("Rust");
let l = s.len(); // 실제로는 (&s).deref().len()

- s.len()은 String 타입에 직접 정의된 메서드가 아니라,
- Deref 트레잇 덕분에 &String이 &str로 변환되고,
- str::len()이 호출되는 거예요.

### ✅ 그래서 이렇게 말할 수 있음
“String은 str로 deref되기 때문에, 참조로 바뀐 후 len()을 바로 쓸 수 있다.”

이건 Rust의 자동 deref 시스템이 메서드 호출 시 참조 타입을 알아서 변환해주는 덕분.
그래서 *나 .deref()를 직접 쓰지 않아도 자연스럽게 동작.

---




