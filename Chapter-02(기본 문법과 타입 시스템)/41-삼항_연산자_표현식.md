# ì‚¼í•­ ì—°ì‚°ì(ternary operator) í‘œí˜„ì‹
Rustì—ëŠ” C/C++ì—ì„œ í”íˆ ì“°ëŠ” ì¡°ê±´ ? ì°¸ì¼ ë•Œ ê°’ : ê±°ì§“ì¼ ë•Œ ê°’ í˜•íƒœì˜ **ì‚¼í•­ ì—°ì‚°ì(ternary operator)**ê°€ ì—†ì§€ë§Œ,  
RustëŠ” í‘œí˜„ì‹ ê¸°ë°˜ ì–¸ì–´ì´ê¸° ë•Œë¬¸ì— if ìì²´ê°€ ê°’ìœ¼ë¡œ í‰ê°€ë˜ëŠ” í‘œí˜„ì‹.  
ê·¸ë˜ì„œ ì‚¼í•­ ì—°ì‚°ìì™€ ê°™ì€ ê¸°ëŠ¥ì„ ì•„ì£¼ ìì—°ìŠ¤ëŸ½ê²Œ êµ¬í˜„í•  ìˆ˜ ìˆìŒ.

## âœ… ì‚¼í•­ ì—°ì‚°ì ìŠ¤íƒ€ì¼ êµ¬í˜„ in Rust

### C/C++ ìŠ¤íƒ€ì¼
```cpp
int x = (a > b) ? a : b;
```

### Rust ìŠ¤íƒ€ì¼
```rust
let x = if a > b { a } else { b };
```

- ifëŠ” **í‘œí˜„ì‹(expression)**ì´ë¯€ë¡œ ê°’ì„ ë°˜í™˜í•  ìˆ˜ ìˆìŒ.
- elseëŠ” í•„ìˆ˜ì•¼. ì—†ìœ¼ë©´ () (unit type)ìœ¼ë¡œ í‰ê°€ë˜ê¸° ë•Œë¬¸ì— íƒ€ì… ë¶ˆì¼ì¹˜ê°€ ë°œìƒí•  ìˆ˜ ìˆìŒ.

## ğŸ§ª ì˜ˆì‹œ: ì‚¼í•­ ì—°ì‚°ìì²˜ëŸ¼ ì“°ê¸°
```rust
fn main() {
    let score = 85;
    let grade = if score >= 90 {
        "A"
    } else if score >= 80 {
        "B"
    } else {
        "C"
    };

    println!("Grade: {}", grade);
}
```

```rust
let y = if x > 0 { 1 } else { -1 };
let s = if flag { "on" } else { "off" };
``

- if-else if-else ì²´ì¸ë„ í‘œí˜„ì‹ìœ¼ë¡œ í‰ê°€ë¨.
- ê° ë¸”ë¡ì€ ë™ì¼í•œ íƒ€ì…ì„ ë°˜í™˜í•´ì•¼ í•¨ (&str, String, ë“±).

### âš ï¸ ì£¼ì˜í•  ì 
- if í‘œí˜„ì‹ì˜ ê° ë¶„ê¸°ì—ì„œ ë°˜í™˜ íƒ€ì…ì´ ê°™ì•„ì•¼ í•¨:
```rust
let result = if condition {
    42
} else {
    "hello" // âŒ íƒ€ì… ë¶ˆì¼ì¹˜
};
```
- íƒ€ì…ì´ ë‹¤ë¥´ë©´ ì»´íŒŒì¼ ì—ëŸ¬ ë°œìƒ. í•´ê²°í•˜ë ¤ë©´ enumì´ë‚˜ Box<dyn Any> ê°™ì€ ë°©ì‹ì´ í•„ìš”.

## Option/Resultì—ì„œì˜ ì‚¼í•­ìŠ¤ëŸ¬ìš´ ê²ƒë“¤
```rust
let out = opt.map_or(default(), |v| use_it(v));         // cond ? use_it(v) : default
let out = res.unwrap_or_else(|e| recover(e));           // Ok(x) ? x : recover(err)
let out = match cond {
    true  => Some(a()),
    false => None,
};
```

## ğŸ§© ê³ ê¸‰: í•¨ìˆ˜í˜• ìŠ¤íƒ€ì¼ë¡œ ì‚¼í•­ ì—°ì‚°ì í‰ë‚´ë‚´ê¸°
```rust
fn max(a: i32, b: i32) -> i32 {
    [a, b].into_iter().max().unwrap()
}
```

í˜¹ì€
```rust
let max = std::cmp::max(a, b);
```

- RustëŠ” ì‚¼í•­ ì—°ì‚°ì ëŒ€ì‹  í‘œí˜„ì‹ + í•¨ìˆ˜ ì¡°í•©ìœ¼ë¡œ ë” ëª…í™•í•˜ê³  ì•ˆì „í•˜ê²Œ ì²˜ë¦¬í•¨.

## ìì£¼ ì“°ëŠ” íŒ¨í„´
### 1) ëŒ€ì…/ì²´ì´ë‹
```rust
let v = if cond { foo() } else { bar() }.clamp(0, 10);
```

### 2) return ìœ„ì¹˜ì—ì„œ
```rust
return if ok { Ok(val) } else { Err("oops") };
```

### 3) async/awaitë„ ê°€ëŠ¥
```rust
let resp = if use_a { call_a().await } else { call_b().await };
```


## ğŸ”š ìš”ì•½: ì‚¼í•­ ì—°ì‚°ì ìŠ¤íƒ€ì¼ ë¹„êµ

| ì–¸ì–´     | ì‚¼í•­ ì—°ì‚°ì í‘œí˜„ì‹         | Rust ëŒ€ì²´ í‘œí˜„ì‹             |
|----------|-----------------------------|-------------------------------|
| C/C++    | `cond ? a : b`              | `if cond { a } else { b }`   |
| Python   | `a if cond else b`          | `if` í‘œí˜„ì‹ìœ¼ë¡œ ë™ì¼í•˜ê²Œ ì‚¬ìš© |
| Rust     | ì—†ìŒ                         | `if cond { a } else { b }`   |


---

# ğŸ„ Cow: Clone-on-Writeë€?

`Cow<'a, T>`ëŠ” **ì†Œìœ ëœ ê°’(T) ë˜ëŠ” ì°¸ì¡°ëœ ê°’(&'a T)**ì„ ë‹´ì„ ìˆ˜ ìˆëŠ” ì—´ê±°í˜• íƒ€ì….
```rust
enum Cow<'a, T>
where
    T: ToOwned + ?Sized,
{
    Borrowed(&'a T),
    Owned(<T as ToOwned>::Owned),
}
```

- Borrowed: ì°¸ì¡°ë§Œ í•¨ â†’ ë³µì‚¬ ì—†ìŒ
- Owned: ë³µì‚¬í•´ì„œ ì†Œìœ í•¨ â†’ í•„ìš”í•  ë•Œë§Œ ë³µì‚¬

## ğŸ§ª ì‚¼í•­ ì—°ì‚°ì ëŠë‚Œìœ¼ë¡œ Cow ì“°ê¸°
ì˜ˆë¥¼ ë“¤ì–´, ì¡°ê±´ì— ë”°ë¼ ë¬¸ìì—´ì„ ë³µì‚¬í• ì§€ ë§ì§€ë¥¼ ê²°ì •í•˜ê³  ì‹¶ì„ ë•Œ:
```rust
use std::borrow::Cow;

fn get_name<'a>(raw: &'a str, should_clone: bool) -> Cow<'a, str> {
    if should_clone {
        Cow::Owned(raw.to_string()) // ë³µì‚¬í•´ì„œ ì†Œìœ 
    } else {
        Cow::Borrowed(raw) // ì°¸ì¡°ë§Œ í•¨
    }
}
```

- should_cloneì´ trueë©´ ë³µì‚¬í•´ì„œ ì†Œìœ  (Owned)
- falseë©´ ì°¸ì¡°ë§Œ í•¨ (Borrowed)
- ë§ˆì¹˜ should_clone ? raw.to_string() : raw ê°™ì€ ëŠë‚Œ

## ğŸ” ì™œ ìœ ìš©í•œê°€?
- ì„±ëŠ¥ ìµœì í™”: í•„ìš”í•  ë•Œë§Œ ë³µì‚¬
- ìœ ì—°í•œ API ì„¤ê³„: í•¨ìˆ˜ ì¸ìë¡œ Cowë¥¼ ë°›ìœ¼ë©´ í˜¸ì¶œìê°€ ë³µì‚¬ ì—¬ë¶€ë¥¼ ê²°ì •í•  ìˆ˜ ìˆìŒ
- í‘œí˜„ì‹ ê¸°ë°˜ ì„¤ê³„: if í‘œí˜„ì‹ê³¼ Cowë¥¼ ì¡°í•©í•˜ë©´ ì‚¼í•­ ì—°ì‚°ìì²˜ëŸ¼ ê¹”ë”í•˜ê²Œ ì¡°ê±´ ë¶„ê¸° ê°€ëŠ¥

## ğŸ§© ì‹¤ì „ ì˜ˆ: íŒŒì¼ ê²½ë¡œ ì²˜ë¦¬
```rust
use std::borrow::Cow;

fn normalize_path<'a>(path: &'a str) -> Cow<'a, str> {
    if path.starts_with("~/") {
        Cow::Owned(path.replacen("~/", "/home/user/", 1))
    } else {
        Cow::Borrowed(path)
    }
}
```

```rust
fn ensure_https<'a>(url: &'a str) -> Cow<'a, str> {
    if url.starts_with("https://") {
        // ë³µì‚¬ ì—†ìŒ
        Cow::Borrowed(url)
    } else {
        // ì´ë•Œë§Œ ì†Œìœ  String ìƒì„±
        Cow::Owned(format!("https://{url}"))
    }
}

let a = ensure_https("https://example.com"); // Borrowed(&str)
let b = ensure_https("example.com");         // Owned(String)

```

- ~/ë¡œ ì‹œì‘í•˜ë©´ ê²½ë¡œë¥¼ ë°”ê¿”ì„œ ì†Œìœ 
- ì•„ë‹ˆë©´ ê·¸ëŒ€ë¡œ ì°¸ì¡°
- ì‚¼í•­ ì—°ì‚°ì ëŠë‚Œ ê·¸ëŒ€ë¡œ!

## âœ… ìš”ì•½: Rustì—ì„œ ì‚¼í•­ ì—°ì‚°ìì²˜ëŸ¼ `Cow` í™œìš©í•˜ê¸°
| ìƒí™©                     | í‘œí˜„ ë°©ì‹                                      |
|--------------------------|------------------------------------------------|
| ê°’ ë³µì‚¬ ì—¬ë¶€ ì¡°ê±´ë¶€ ê²°ì • | `Cow::Owned` / `Cow::Borrowed`                |
| ì‚¼í•­ ì—°ì‚°ì ìŠ¤íƒ€ì¼ êµ¬í˜„ | `if cond { Cow::Owned(val) } else { Cow::Borrowed(val) }` |




