# 삼항 연산자(ternary operator) 표현식
Rust에는 C/C++에서 흔히 쓰는 조건 ? 참일 때 값 : 거짓일 때 값 형태의 **삼항 연산자(ternary operator)**가 없지만,  
Rust는 표현식 기반 언어이기 때문에 if 자체가 값으로 평가되는 표현식.  
그래서 삼항 연산자와 같은 기능을 아주 자연스럽게 구현할 수 있음.

## ✅ 삼항 연산자 스타일 구현 in Rust

### C/C++ 스타일
```cpp
int x = (a > b) ? a : b;
```

### Rust 스타일
```rust
let x = if a > b { a } else { b };
```

- if는 **표현식(expression)**이므로 값을 반환할 수 있음.
- else는 필수야. 없으면 () (unit type)으로 평가되기 때문에 타입 불일치가 발생할 수 있음.

## 🧪 예시: 삼항 연산자처럼 쓰기
```rust
fn main() {
    let score = 85;
    let grade = if score >= 90 {
        "A"
    } else if score >= 80 {
        "B"
    } else {
        "C"
    };

    println!("Grade: {}", grade);
}
```

```rust
let y = if x > 0 { 1 } else { -1 };
let s = if flag { "on" } else { "off" };
``

- if-else if-else 체인도 표현식으로 평가됨.
- 각 블록은 동일한 타입을 반환해야 함 (&str, String, 등).

### ⚠️ 주의할 점
- if 표현식의 각 분기에서 반환 타입이 같아야 함:
```rust
let result = if condition {
    42
} else {
    "hello" // ❌ 타입 불일치
};
```
- 타입이 다르면 컴파일 에러 발생. 해결하려면 enum이나 Box<dyn Any> 같은 방식이 필요.

## Option/Result에서의 삼항스러운 것들
```rust
let out = opt.map_or(default(), |v| use_it(v));         // cond ? use_it(v) : default
let out = res.unwrap_or_else(|e| recover(e));           // Ok(x) ? x : recover(err)
let out = match cond {
    true  => Some(a()),
    false => None,
};
```

## 🧩 고급: 함수형 스타일로 삼항 연산자 흉내내기
```rust
fn max(a: i32, b: i32) -> i32 {
    [a, b].into_iter().max().unwrap()
}
```

혹은
```rust
let max = std::cmp::max(a, b);
```

- Rust는 삼항 연산자 대신 표현식 + 함수 조합으로 더 명확하고 안전하게 처리함.

## 자주 쓰는 패턴
### 1) 대입/체이닝
```rust
let v = if cond { foo() } else { bar() }.clamp(0, 10);
```

### 2) return 위치에서
```rust
return if ok { Ok(val) } else { Err("oops") };
```

### 3) async/await도 가능
```rust
let resp = if use_a { call_a().await } else { call_b().await };
```


## 🔚 요약: 삼항 연산자 스타일 비교

| 언어     | 삼항 연산자 표현식         | Rust 대체 표현식             |
|----------|-----------------------------|-------------------------------|
| C/C++    | `cond ? a : b`              | `if cond { a } else { b }`   |
| Python   | `a if cond else b`          | `if` 표현식으로 동일하게 사용 |
| Rust     | 없음                         | `if cond { a } else { b }`   |


---

# 🐄 Cow: Clone-on-Write란?

`Cow<'a, T>`는 **소유된 값(T) 또는 참조된 값(&'a T)**을 담을 수 있는 열거형 타입.
```rust
enum Cow<'a, T>
where
    T: ToOwned + ?Sized,
{
    Borrowed(&'a T),
    Owned(<T as ToOwned>::Owned),
}
```

- Borrowed: 참조만 함 → 복사 없음
- Owned: 복사해서 소유함 → 필요할 때만 복사

## 🧪 삼항 연산자 느낌으로 Cow 쓰기
예를 들어, 조건에 따라 문자열을 복사할지 말지를 결정하고 싶을 때:
```rust
use std::borrow::Cow;

fn get_name<'a>(raw: &'a str, should_clone: bool) -> Cow<'a, str> {
    if should_clone {
        Cow::Owned(raw.to_string()) // 복사해서 소유
    } else {
        Cow::Borrowed(raw) // 참조만 함
    }
}
```

- should_clone이 true면 복사해서 소유 (Owned)
- false면 참조만 함 (Borrowed)
- 마치 should_clone ? raw.to_string() : raw 같은 느낌

## 🔍 왜 유용한가?
- 성능 최적화: 필요할 때만 복사
- 유연한 API 설계: 함수 인자로 Cow를 받으면 호출자가 복사 여부를 결정할 수 있음
- 표현식 기반 설계: if 표현식과 Cow를 조합하면 삼항 연산자처럼 깔끔하게 조건 분기 가능

## 🧩 실전 예: 파일 경로 처리
```rust
use std::borrow::Cow;

fn normalize_path<'a>(path: &'a str) -> Cow<'a, str> {
    if path.starts_with("~/") {
        Cow::Owned(path.replacen("~/", "/home/user/", 1))
    } else {
        Cow::Borrowed(path)
    }
}
```

```rust
fn ensure_https<'a>(url: &'a str) -> Cow<'a, str> {
    if url.starts_with("https://") {
        // 복사 없음
        Cow::Borrowed(url)
    } else {
        // 이때만 소유 String 생성
        Cow::Owned(format!("https://{url}"))
    }
}

let a = ensure_https("https://example.com"); // Borrowed(&str)
let b = ensure_https("example.com");         // Owned(String)

```

- ~/로 시작하면 경로를 바꿔서 소유
- 아니면 그대로 참조
- 삼항 연산자 느낌 그대로!

## ✅ 요약: Rust에서 삼항 연산자처럼 `Cow` 활용하기
| 상황                     | 표현 방식                                      |
|--------------------------|------------------------------------------------|
| 값 복사 여부 조건부 결정 | `Cow::Owned` / `Cow::Borrowed`                |
| 삼항 연산자 스타일 구현 | `if cond { Cow::Owned(val) } else { Cow::Borrowed(val) }` |




