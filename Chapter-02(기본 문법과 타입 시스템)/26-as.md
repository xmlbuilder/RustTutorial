# as
Rustμ as ν‚¤μ›λ“λ” **νƒ€μ… μΊμ¤ν…(type casting)** μ„ λ…μ‹μ μΌλ΅ μν–‰ν•  λ• μ‚¬μ©λλ©°, νΉν κΈ°λ³Έ νƒ€μ… κ°„μ λ³€ν™μ—μ„ μμ£Ό μ“°μ…λ‹λ‹¤.  
ν•μ§€λ§ asλ” λ‹¨μν•λ©΄μ„λ„ μ£Όμν•  μ μ΄ λ§μ€ λ„κµ¬.

## π§  as ν‚¤μ›λ“λ€?
- Rustλ” μ•”λ¬µμ  νƒ€μ… λ³€ν™μ„ ν—μ©ν•μ§€ μ•μ
- asλ” λ…μ‹μ  νƒ€μ… λ³€ν™μ„ μν–‰ν•λ” ν‚¤μ›λ“
- μ£Όλ΅ μ«μ νƒ€μ… κ°„ λ³€ν™, char β†’ u32, ν¬μΈν„° λ³€ν™ λ“±μ— μ‚¬μ©λ¨

## π” μμ  λ¶„μ„
```rust
fn string_to_digit(input: String) -> i32 {
    let mut ret = 0;
    for c in input.chars() {
        ret = ret * 10;
        ret += c as i32 - '0' as i32;
    }
    ret
}
```

### λ™μ‘ μ›λ¦¬
- c as i32: char νƒ€μ…μ„ i32λ΅ λ³€ν™ β†’ μ λ‹μ½”λ“ μ½”λ“ ν¬μΈνΈ κ°’μ„ λ°ν™
- '0' as i32: λ¬Έμ '0'μ μ½”λ“ ν¬μΈνΈλ” 48
- λ”°λΌμ„ '5' as i32 - '0' as i32λ” 53 - 48 = 5

## λ¬Έμ μ 
```
let str = String::from("jhjeong");
```

- μ΄ λ¬Έμμ—΄μ€ μ«μκ°€ μ•„λ‹ λ¬Έμλ΅ κµ¬μ„±λμ–΄ μμ
- μ: 'j' as i32 - '0' as i32 = 106 - 48 = 58 β†’ μλ„ν• μ«μ λ³€ν™μ΄ μ•„λ‹
- κ²°κ³Όμ μΌλ΅ string_to_digit("jhjeong")λ” μλ―Έ μ—†λ” μ«μλ¥Ό λ°ν™ν•¨

## β οΈ as μ‚¬μ© μ‹ μ£Όμμ‚¬ν•­
| ν•­λ©                      | μ„¤λ…                                      |
|---------------------------|-------------------------------------------|
| `as`                      | λ…μ‹μ  νƒ€μ… λ³€ν™ ν‚¤μ›λ“                    |
| `300u32 as u8 = 44`       | μ¤λ²„ν”λ΅μ° λ°μƒ β†’ 300μ€ u8 λ²”μ„ μ΄κ³Ό, κ°’ μλ¦Ό |
| `f64 as i32`              | μ†μμ  μ΄ν• μλ¦Ό β†’ λ°μ¬λ¦Ό μ•„λ‹             |
| `char as i32`             | μ λ‹μ½”λ“ μ½”λ“ ν¬μΈνΈλ΅ λ³€ν™λ¨              |
| `as` vs `From/Into/TryFrom` | `as`λ” μ•μ „μ„± λ‚®μ, `TryFrom`μ€ μ¤λ¥ μ²λ¦¬ κ°€λ¥ |


### β… μ•μ „ν• λ€μ• ( `u32::try_from` )
- `TryFrom` / `TryInto` λ¥Ό μ‚¬μ©ν•λ©΄ λ²”μ„ μ²΄ν¬μ™€ μ¤λ¥ μ²λ¦¬ κ°€λ¥:
```rust
use std::convert::TryFrom;

fn safe_char_to_digit(c: char) -> Option<u32> {
    if c.is_ascii_digit() {
        Some(u32::try_from(c as u32 - '0' as u32).ok()?)
    } else {
        None
    }
}
```

### κ°μ„ μ•
```rust
fn string_to_digit(input: &str) -> i32 {
    let mut ret = 0;
    for c in input.chars() {
        if c.is_ascii_digit() {
            ret = ret * 10 + (c as i32 - '0' as i32);
        }
    }
    ret
}

fn main() {
    let input = "12a4";
    let result = string_to_digit(input);
    println!("Parsed number: {}", result); // μ¶λ ¥: 124
}
```


## π“ ν•µμ‹¬ μ”μ•½
| ν‘ν„           | νƒ€μ… λλ” κΈ°λ¥     | κ²°κ³Ό λλ” μ„¤λ…     |
|----------------|--------------------|---------------------|
| `c as i32`     | `char`             | `'5'` β†’ `53` (μ λ‹μ½”λ“ μ½”λ“ ν¬μΈνΈ) |
| `'0' as i32`   | `char`             | `'0'` β†’ `48`        |
| `as`           | λ…μ‹μ  νƒ€μ… λ³€ν™   | μ•μ „μ„± λ‚®μ, μ¤λ²„ν”λ΅μ° κ°€λ¥μ„± μμ |
| `TryFrom`      | μ•μ „ν• νƒ€μ… λ³€ν™   | `Result` λ°ν™, μ¤λ¥ μ²λ¦¬ κ°€λ¥ |

---

## κ°μ²΄ λ³€ν™ 
νƒ€μ… μΊμ¤ν…μ΄λ‚ νΈλ μ΄νΈ κ°μ²΄ λ³€ν™ λ“±μ—μ„ λ§¤μ° μ μ©ν•κ² μ‚¬μ©λ©λ‹λ‹¤.  
νΉν asλ” νƒ€μ… λ³€ν™, νΈλ μ΄νΈ κ°μ²΄ μ—…μΊμ¤ν…, ν¬μΈν„° λ³€ν™ λ“±μ— ν™μ©λ©λ‹λ‹¤.

## π§  as ν‚¤μ›λ“μ μ£Όμ” μ©λ„
| ν‚¤μ›λ“ | μ©λ„ μ„¤λ…                              |
|--------|-----------------------------------------|
| as     | νƒ€μ… λ³€ν™ (μ •μ, ν¬μΈν„°, νΈλ μ΄νΈ κ°μ²΄) |
|        | `&T as &dyn Trait`                        |
|        | `Box<T> as Box<dyn Trait>`                |
|        | `*const T as usize` (ν¬μΈν„° β†’ μ •μ)       |
|        | `u32 as f64` (μ •μ β†’ λ¶€λ™μ†μμ )          |

## π” μμ‹ μ„¤λ…
- `&T as &dyn Trait`: μ •μ  νƒ€μ…μ„ νΈλ μ΄νΈ κ°μ²΄λ΅ μ—…μΊμ¤ν… β†’ λ‹¤ν•μ„± κµ¬ν„
- `Box<T> as Box<dyn Trait>`: ν™μ— μλ” κµ¬μ΅°μ²΄λ¥Ό νΈλ μ΄νΈ κ°μ²΄λ΅ λ³€ν™
- `u8 as u32`: νƒ€μ… ν¬κΈ° ν™•μ¥
- `*const T as usize`: ν¬μΈν„°λ¥Ό μ •μλ΅ λ³€ν™ β†’ FFIλ‚ μ €μμ¤€ μ‘μ—…μ—μ„ μ‚¬μ©


## β… κΈ°λ³Έ μμ : νƒ€μ… μΊμ¤ν…
```rust
fn main() {
    let x: u8 = 10;
    let y = x as u32; // u8 β†’ u32λ΅ λ³€ν™
    println!("y: {}", y);
}

```

## β… νΈλ μ΄νΈ κ°μ²΄ λ³€ν™ μμ 
```rust
trait Animal {
    fn speak(&self);
}

struct Dog;
impl Animal for Dog {
    fn speak(&self) {
        println!("Woof!");
    }
}

fn main() {
    let dog = Dog;
    let animal: &dyn Animal = &dog as &dyn Animal; // μ—…μΊμ¤ν…
    animal.speak();
}
```

- &dog as &dyn Animalμ€ Dogλ¥Ό Animal νΈλ μ΄νΈ κ°μ²΄λ΅ λ³€ν™
- μ΄ λ°©μ‹μ€ **λ‹¤ν•μ„±(polymorphism)** μ„ κµ¬ν„ν•  λ• ν•µμ‹¬

## π§© μ‹¤μ „ μμ : κµ¬μ΅°μ²΄ + νΈλ μ΄νΈ κ°μ²΄ + Box
```rust

trait Drawable {
    fn draw(&self);
}

struct Circle;

impl Drawable for Circle {
    fn draw(&self) {
        println!("Drawing a circle");
    }
}

struct Canvas {
    items: Vec<Box<dyn Drawable>>,
}

fn main() {
    let circle = Circle;
    let boxed: Box<dyn Drawable> = Box::new(circle) as Box<dyn Drawable>; // Box μ—…μΊμ¤ν…

    let mut canvas = Canvas { items: vec![] };
    canvas.items.push(boxed);

    for item in &canvas.items {
        item.draw();
    }
}
```

- Box<Circle>μ„ Box<dyn Drawable>λ΅ λ³€ν™
- κµ¬μ΅°μ²΄ Canvasλ” λ‹¤μ–‘ν• Drawable κ°μ²΄λ¥Ό μ €μ¥ κ°€λ¥

## β οΈ μ£Όμμ‚¬ν•­
- asλ” μ•μ „ν• λ³€ν™λ§ ν—μ©ν•©λ‹λ‹¤. μλ¥Ό λ“¤μ–΄ f64 as u8μ€ κ°€λ¥ν•μ§€λ§, μ†μ‹¤μ΄ λ°μƒν•  μ μμ
- νΈλ μ΄νΈ κ°μ²΄λ΅ λ³€ν™ν•  λ•λ” νΈλ μ΄νΈκ°€ `dyn` μΌλ΅ λ…μ‹λΌμ•Ό ν•¨
- κµ¬μ΅°μ²΄ λ‚΄λ¶€μ—μ„λ” asλ¥Ό μ§μ ‘ μ“°κΈ°λ³΄λ‹¤λ” μ™Έλ¶€μ—μ„ ν•„λ“λ‚ μΈμ¤ν„΄μ¤λ¥Ό λ³€ν™ν•λ” λ° μ‚¬μ©λ¨


---



