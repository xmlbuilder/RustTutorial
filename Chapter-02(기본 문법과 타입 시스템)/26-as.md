# as
Rustμ `as` ν‚¤μ›λ“λ” **νƒ€μ… μΊμ¤ν…(type casting)** μ„ λ…μ‹μ μΌλ΅ μν–‰ν•  λ• μ‚¬μ©λλ©°, νΉν κΈ°λ³Έ νƒ€μ… κ°„μ λ³€ν™μ—μ„ μμ£Ό μ“°μ…λ‹λ‹¤.  
ν•μ§€λ§ `as` λ” λ‹¨μν•λ©΄μ„λ„ μ£Όμν•  μ μ΄ λ§μ€ λ„κµ¬.

## π§  as ν‚¤μ›λ“λ€?
- Rustλ” μ•”λ¬µμ  νƒ€μ… λ³€ν™μ„ ν—μ©ν•μ§€ μ•μ
- asλ” λ…μ‹μ  νƒ€μ… λ³€ν™μ„ μν–‰ν•λ” ν‚¤μ›λ“
- μ£Όλ΅ μ«μ νƒ€μ… κ°„ λ³€ν™, char β†’ u32, ν¬μΈν„° λ³€ν™ λ“±μ— μ‚¬μ©λ¨

## π” μμ  λ¶„μ„
```rust
fn string_to_digit(input: String) -> i32 {
    let mut ret = 0;
    for c in input.chars() {
        ret = ret * 10;
        ret += c as i32 - '0' as i32;
    }
    ret
}
```

### λ™μ‘ μ›λ¦¬
- c as i32: char νƒ€μ…μ„ i32λ΅ λ³€ν™ β†’ μ λ‹μ½”λ“ μ½”λ“ ν¬μΈνΈ κ°’μ„ λ°ν™
- '0' as i32: λ¬Έμ '0'μ μ½”λ“ ν¬μΈνΈλ” 48
- λ”°λΌμ„ '5' as i32 - '0' as i32λ” 53 - 48 = 5

## λ¬Έμ μ 
```
let str = String::from("jhjeong");
```

- μ΄ λ¬Έμμ—΄μ€ μ«μκ°€ μ•„λ‹ λ¬Έμλ΅ κµ¬μ„±λμ–΄ μμ
- μ: 'j' as i32 - '0' as i32 = 106 - 48 = 58 β†’ μλ„ν• μ«μ λ³€ν™μ΄ μ•„λ‹
- κ²°κ³Όμ μΌλ΅ string_to_digit("jhjeong")λ” μλ―Έ μ—†λ” μ«μλ¥Ό λ°ν™ν•¨

## β οΈ as μ‚¬μ© μ‹ μ£Όμμ‚¬ν•­
| ν•­λ©                      | μ„¤λ…                                      |
|---------------------------|-------------------------------------------|
| `as`                      | λ…μ‹μ  νƒ€μ… λ³€ν™ ν‚¤μ›λ“                    |
| `300u32 as u8 = 44`       | μ¤λ²„ν”λ΅μ° λ°μƒ β†’ 300μ€ u8 λ²”μ„ μ΄κ³Ό, κ°’ μλ¦Ό |
| `f64 as i32`              | μ†μμ  μ΄ν• μλ¦Ό β†’ λ°μ¬λ¦Ό μ•„λ‹             |
| `char as i32`             | μ λ‹μ½”λ“ μ½”λ“ ν¬μΈνΈλ΅ λ³€ν™λ¨              |
| `as` vs `From/Into/TryFrom` | `as`λ” μ•μ „μ„± λ‚®μ, `TryFrom`μ€ μ¤λ¥ μ²λ¦¬ κ°€λ¥ |


### β… μ•μ „ν• λ€μ• ( `u32::try_from` )
- `TryFrom` / `TryInto` λ¥Ό μ‚¬μ©ν•λ©΄ λ²”μ„ μ²΄ν¬μ™€ μ¤λ¥ μ²λ¦¬ κ°€λ¥:
```rust
use std::convert::TryFrom;

fn safe_char_to_digit(c: char) -> Option<u32> {
    if c.is_ascii_digit() {
        Some(u32::try_from(c as u32 - '0' as u32).ok()?)
    } else {
        None
    }
}
```

### κ°μ„ μ•
```rust
fn string_to_digit(input: &str) -> i32 {
    let mut ret = 0;
    for c in input.chars() {
        if c.is_ascii_digit() {
            ret = ret * 10 + (c as i32 - '0' as i32);
        }
    }
    ret
}

fn main() {
    let input = "12a4";
    let result = string_to_digit(input);
    println!("Parsed number: {}", result); // μ¶λ ¥: 124
}
```


## π“ ν•µμ‹¬ μ”μ•½
| ν‘ν„           | νƒ€μ… λλ” κΈ°λ¥     | κ²°κ³Ό λλ” μ„¤λ…     |
|----------------|--------------------|---------------------|
| `c as i32`     | `char`             | `'5'` β†’ `53` (μ λ‹μ½”λ“ μ½”λ“ ν¬μΈνΈ) |
| `'0' as i32`   | `char`             | `'0'` β†’ `48`        |
| `as`           | λ…μ‹μ  νƒ€μ… λ³€ν™   | μ•μ „μ„± λ‚®μ, μ¤λ²„ν”λ΅μ° κ°€λ¥μ„± μμ |
| `TryFrom`      | μ•μ „ν• νƒ€μ… λ³€ν™   | `Result` λ°ν™, μ¤λ¥ μ²λ¦¬ κ°€λ¥ |

---

## κ°μ²΄ λ³€ν™ 
νƒ€μ… μΊμ¤ν…μ΄λ‚ νΈλ μ΄νΈ κ°μ²΄ λ³€ν™ λ“±μ—μ„ λ§¤μ° μ μ©ν•κ² μ‚¬μ©λ©λ‹λ‹¤.  
νΉν asλ” νƒ€μ… λ³€ν™, νΈλ μ΄νΈ κ°μ²΄ μ—…μΊμ¤ν…, ν¬μΈν„° λ³€ν™ λ“±μ— ν™μ©λ©λ‹λ‹¤.

## π§  as ν‚¤μ›λ“μ μ£Όμ” μ©λ„
| ν‚¤μ›λ“ | μ©λ„ μ„¤λ…                              |
|--------|-----------------------------------------|
| as     | νƒ€μ… λ³€ν™ (μ •μ, ν¬μΈν„°, νΈλ μ΄νΈ κ°μ²΄) |
|        | `&T as &dyn Trait`                        |
|        | `Box<T> as Box<dyn Trait>`                |
|        | `*const T as usize` (ν¬μΈν„° β†’ μ •μ)       |
|        | `u32 as f64` (μ •μ β†’ λ¶€λ™μ†μμ )          |

## π” μμ‹ μ„¤λ…
- `&T as &dyn Trait`: μ •μ  νƒ€μ…μ„ νΈλ μ΄νΈ κ°μ²΄λ΅ μ—…μΊμ¤ν… β†’ λ‹¤ν•μ„± κµ¬ν„
- `Box<T> as Box<dyn Trait>`: ν™μ— μλ” κµ¬μ΅°μ²΄λ¥Ό νΈλ μ΄νΈ κ°μ²΄λ΅ λ³€ν™
- `u8 as u32`: νƒ€μ… ν¬κΈ° ν™•μ¥
- `*const T as usize`: ν¬μΈν„°λ¥Ό μ •μλ΅ λ³€ν™ β†’ FFIλ‚ μ €μμ¤€ μ‘μ—…μ—μ„ μ‚¬μ©


## β… Box<T> as Box<dyn Trait>
```
struct MyStruct;
impl MyTrait for MyStruct {}

let boxed: Box<MyStruct> = Box::new(MyStruct);
let trait_box: Box<dyn MyTrait> = boxed as Box<dyn MyTrait>;
```
- μ΄ μ½”λ“μ—μ„ asλ” `Box<MyStruct>` λ¥Ό `Box<dyn MyTrait>` λ΅ μ—…μΊμ¤ν…ν•λ” μ—­ν• .
- μ¦‰, κµ¬μ΅°μ²΄λ¥Ό ν™μ— μ¬λ¦° ν›„ νΈλ μ΄νΈ κ°μ²΄λ΅ λ³€ν™.


## β… κΈ°λ³Έ μμ : νƒ€μ… μΊμ¤ν…
```rust
fn main() {
    let x: u8 = 10;
    let y = x as u32; // u8 β†’ u32λ΅ λ³€ν™
    println!("y: {}", y);
}
```

## β… νΈλ μ΄νΈ κ°μ²΄ λ³€ν™ μμ 
```rust
trait Animal {
    fn speak(&self);
}

struct Dog;
impl Animal for Dog {
    fn speak(&self) {
        println!("Woof!");
    }
}

fn main() {
    let dog = Dog;
    let animal: &dyn Animal = &dog as &dyn Animal; // μ—…μΊμ¤ν…
    animal.speak();
}
```

- &dog as &dyn Animalμ€ Dogλ¥Ό Animal νΈλ μ΄νΈ κ°μ²΄λ΅ λ³€ν™
- μ΄ λ°©μ‹μ€ **λ‹¤ν•μ„±(polymorphism)** μ„ κµ¬ν„ν•  λ• ν•µμ‹¬

## π§© μ‹¤μ „ μμ : κµ¬μ΅°μ²΄ + νΈλ μ΄νΈ κ°μ²΄ + Box
```rust

trait Drawable {
    fn draw(&self);
}

struct Circle;

impl Drawable for Circle {
    fn draw(&self) {
        println!("Drawing a circle");
    }
}

struct Canvas {
    items: Vec<Box<dyn Drawable>>,
}

fn main() {
    let circle = Circle;
    let boxed: Box<dyn Drawable> = Box::new(circle) as Box<dyn Drawable>; // Box μ—…μΊμ¤ν…

    let mut canvas = Canvas { items: vec![] };
    canvas.items.push(boxed);

    for item in &canvas.items {
        item.draw();
    }
}
```

- Box<Circle>μ„ Box<dyn Drawable>λ΅ λ³€ν™
- κµ¬μ΅°μ²΄ Canvasλ” λ‹¤μ–‘ν• Drawable κ°μ²΄λ¥Ό μ €μ¥ κ°€λ¥

## β οΈ μ£Όμμ‚¬ν•­
- asλ” μ•μ „ν• λ³€ν™λ§ ν—μ©ν•©λ‹λ‹¤. μλ¥Ό λ“¤μ–΄ f64 as u8μ€ κ°€λ¥ν•μ§€λ§, μ†μ‹¤μ΄ λ°μƒν•  μ μμ
- νΈλ μ΄νΈ κ°μ²΄λ΅ λ³€ν™ν•  λ•λ” νΈλ μ΄νΈκ°€ `dyn` μΌλ΅ λ…μ‹λΌμ•Ό ν•¨
- κµ¬μ΅°μ²΄ λ‚΄λ¶€μ—μ„λ” asλ¥Ό μ§μ ‘ μ“°κΈ°λ³΄λ‹¤λ” μ™Έλ¶€μ—μ„ ν•„λ“λ‚ μΈμ¤ν„΄μ¤λ¥Ό λ³€ν™ν•λ” λ° μ‚¬μ©λ¨

---

# π§  *const T as usizeλ€?
- *const Tλ” μ–΄λ–¤ νƒ€μ… Tμ— λ€ν• λ¶λ³€ ν¬μΈν„°
- as usizeλ” κ·Έ ν¬μΈν„°λ¥Ό μ •μ μ£Όμ†κ°’μΌλ΅ λ³€ν™ν•λ” κ²ƒ
- μ¦‰, λ©”λ¨λ¦¬ μ£Όμ†λ¥Ό μ«μ ν•νƒλ΅ λ‹¤λ£¨κ³  μ‹¶μ„ λ• μ‚¬μ©

## π§ μ‚¬μ© μμ‹
### 1. μ£Όμ† κΈ°λ° ν•΄μ‹ κ³„μ‚°
```rust
use std::collections::HashSet;

struct MyType;

fn main() {
    let a = MyType;
    let b = MyType;

    let ptr_a = &a as *const MyType as usize;
    let ptr_b = &b as *const MyType as usize;

    let mut set = HashSet::new();
    set.insert(ptr_a);
    set.insert(ptr_b);

    println!("Unique addresses: {:?}", set);
}
```
- π“ μ΄ μμ‹λ” MyType μΈμ¤ν„΄μ¤μ λ©”λ¨λ¦¬ μ£Όμ†λ¥Ό μ •μλ΅ λ³€ν™ν•΄μ„ ν•΄μ‹μ…‹μ— μ €μ¥ν•λ” λ°©μ‹. κ°μ²΄μ κ³ μ μ„±μ„ μ£Όμ† κΈ°λ°μΌλ΅ νλ‹¨ν•  λ• μ μ©.

## 2. μ •λ ¬λ ν¬μΈν„° λΉ„κµ (μ£Όμ† μμ„)
```rust
let a = &10;
let b = &20;

let addr_a = a as *const i32 as usize;
let addr_b = b as *const i32 as usize;

if addr_a < addr_b {
    println!("a comes before b in memory");
}
```
- π“ ν¬μΈν„°λΌλ¦¬ μ§μ ‘ λΉ„κµν•λ” λ€μ‹ , μ •μ μ£Όμ†κ°’μΌλ΅ λ³€ν™ν•΄μ„ λ©”λ¨λ¦¬ μμ„λ¥Ό νλ‹¨ν•λ” λ°©μ‹μ΄μ—μ”.

## 3. Unsafeν• λ©”λ¨λ¦¬ μ—°μ‚°μ΄λ‚ λ””λ²„κΉ…μ© μ¶λ ¥
```rust
fn debug_address<T>(val: &T) {
    let addr = val as *const T as usize;
    println!("Address: 0x{:x}", addr);
}
```
- π“ λ””λ²„κΉ…ν•  λ• κ°μ²΄μ μ‹¤μ  λ©”λ¨λ¦¬ μ„μΉλ¥Ό ν™•μΈν•κ³  μ‹¶μ„ λ• μ‚¬μ©ν•΄μ”.

### β οΈ μ£Όμμ‚¬ν•­
- μ΄ μΊμ¤ν…μ€ unsafeκ°€ μ•„λ‹μ§€λ§, μ£Όμ†κ°’μ„ μ§μ ‘ λ‹¤λ£¨λ” κ±΄ μ„ν—ν•  μ μμ
- λ€λ¶€λ¶„μ κ²½μ° μ•μ „ν• μ¶”μƒν™”λ΅ ν•΄κ²°ν•  μ μμΌλ―€λ΅, κΌ­ ν•„μ”ν• κ²½μ°μ—λ§ μ‚¬μ©ν•΄μ•Ό ν•¨
- μ£Όμ†κ°’μ€ μ¬λ°°μΉλ  μ μμΌλ―€λ΅, μ¥κΈ° μ €μ¥ν•κ±°λ‚ λΉ„κµμ— μ‚¬μ©ν•  λ• μ£Όμκ°€ ν•„μ”

## μμ : μ£Όμ†λ¥Ό μ €μ¥ν•κ³  λ‹¤μ‹ μ°Ύμ•„κ°€μ„ μμ •ν•κΈ°
```rust
fn main() {
    let mut value: i32 = 10;

    // 1. ν¬μΈν„°λ¥Ό usizeλ΅ μ €μ¥
    let addr: usize = &value as *const i32 as usize;
    println!("Original address: 0x{:x}", addr);

    // 2. λ‚μ¤‘μ— μ£Όμ†λ¥Ό λ‹¤μ‹ ν¬μΈν„°λ΅ λ³€ν™ν•μ—¬ μμ •
    unsafe {
        let ptr: *mut i32 = addr as *mut i32;
        *ptr = 42;
    }
    // 3. κ²°κ³Ό ν™•μΈ
    println!("Modified value: {}", value);
}
```

### π” μ„¤λ…
- &value as *const i32 β†’ usize: μ£Όμ†λ¥Ό μ •μλ΅ μ €μ¥
- addr as *mut i32: λ‹¤μ‹ ν¬μΈν„°λ΅ λ³µμ›
- *ptr = 42: ν•΄λ‹Ή μ£Όμ†μ κ°’μ„ μμ •
- unsafe λΈ”λ΅ μ•μ—μ„λ§ ν¬μΈν„°λ¥Ό μ—­μ°Έμ΅°ν•  μ μμ

### β οΈ μ£Όμμ‚¬ν•­
- μ΄ μμ λ” valueκ°€ μ—¬μ „ν μ ν¨ν• λ©”λ¨λ¦¬μ— μ΅΄μ¬ν•λ‹¤λ” μ „μ  ν•μ— μ•μ „ν•κ² μ‘λ™ν•©λ‹λ‹¤.
- λ§μ•½ addrμ„ μ¤λ μ €μ¥ν•κ±°λ‚, ν•΄λ‹Ή λ©”λ¨λ¦¬κ°€ ν•΄μ λκ±°λ‚ μ΄λ™λλ©΄ undefined behaviorκ°€ λ°μƒν•  μ μμµλ‹λ‹¤.
- Rustλ” μ΄λ° μ‘μ—…μ„ κΈ°λ³Έμ μΌλ΅ κΈμ§€ν•μ§€ μ•μ§€λ§, ν”„λ΅κ·Έλλ¨Έκ°€ μ±…μ„μ§€κ³  μ•μ „μ„±μ„ λ³΄μ¥ν•΄μ•Ό ν•©λ‹λ‹¤.

---

# π§  μ™ dynμ„ λ¶™μ—¬μ•Ό ν• κΉ?
Rustμ—μ„ dyn Traitλ” **λ™μ  λ””μ¤ν¨μΉ(dynamic dispatch)** λ¥Ό μλ―Έν•©λ‹λ‹¤.  
μ¦‰, λ°νƒ€μ„μ— μ–΄λ–¤ νƒ€μ…μ λ©”μ„λ“λ¥Ό νΈμ¶ν• μ§€ κ²°μ •ν•λ” λ°©μ‹.
```rust
let animal: &dyn Animal = &dog as &dyn Animal;
```
μ—¬κΈ°μ„ dyn Animalμ€ **μ΄ νƒ€μ…μ€ Animal νΈλ μ΄νΈλ¥Ό κµ¬ν„ν• μ–΄λ–¤ νƒ€μ…μ΄μ§€λ§, μ •ν™•ν μ–΄λ–¤ νƒ€μ…μΈμ§€λ” λ¨λ¦„. λ€μ‹  λ°νƒ€μ„μ— κ²°μ •** λΌλ” λ».

## π” λ‹¤λ¥Έ μ–Έμ–΄μ™€μ λΉ„κµ

| μ–Έμ–΄   | μ½”λ“ μμ‹                                 | νƒ€μ… μ„¤λ…                                |
|--------|--------------------------------------------|-------------------------------------------|
| Java   | `Animal animal = new Dog();`              | `Animal`μ€ μΈν„°νμ΄μ¤, `Dog`λ” κµ¬ν„μ²΄     |
| C++    | `Animal* animal = new Dog();`             | `Animal`μ€ μ¶”μƒ ν΄λμ¤, `Dog`λ” μ„λΈν΄λμ¤ |
| Rust   | `let animal: &dyn Animal = &dog;`         | `dyn Animal`μ€ νΈλ μ΄νΈ κ°μ²΄, `dog`λ” κµ¬ν„μ²΄ |

Rustμ—μ„λ” νΈλ μ΄νΈ κ°μ²΄λ¥Ό λ…μ‹μ μΌλ΅ dyn Traitλ΅ μ¨μ•Ό μ»΄νμΌλ¬κ°€ λ™μ  λ””μ¤ν¨μΉλ¥Ό μν–‰ν•  μ μμ. μ΄κ±΄ μλ„λ¥Ό λ…ν™•ν ν‘ν„ν•κΈ° μ„ν• μ„¤κ³„μ…λ‹λ‹¤.

## β… μ •λ¦¬
- dyn Traitλ” νΈλ μ΄νΈ κ°μ²΄λ¥Ό μλ―Έν•λ©°, λ°νƒ€μ„μ— νƒ€μ…μ΄ κ²°μ •λ¨
- &dyn Trait, Box<dyn Trait> λ“±μΌλ΅ μ‚¬μ©
- dynμ„ λ¶™μ΄λ” μ΄μ λ” λ™μ  λ””μ¤ν¨μΉλ¥Ό λ…μ‹μ μΌλ΅ ν‘ν„ν•κΈ° μ„ν•΄μ„


## β… dyn μ—†μ΄ λλ” κ²½μ°: μ •μ  λ””μ¤ν¨μΉ
### 1. μ λ„¤λ¦­ νƒ€μ…μ— νΈλ μ΄νΈ λ°”μ΄λ“
```rust
fn speak<T: Animal>(animal: &T) {
    animal.speak();
}
```
- μ—¬κΈ°μ„ T: Animalμ€ Animal νΈλ μ΄νΈλ¥Ό κµ¬ν„ν• νƒ€μ…μ„ μλ―Έ
- dyn μ—†μ΄λ„ animal.speak() νΈμ¶ κ°€λ¥
- μ»΄νμΌ νƒ€μ„μ— νƒ€μ…μ΄ κ²°μ •λλ―€λ΅ λΉ λ¥΄κ³  μ•μ „ν•¨

### 2. impl Trait μ‚¬μ©
```rust
fn get_animal() -> impl Animal {
    Dog {}
}
```
- impl Traitμ€ λ°ν™ νƒ€μ…μ΄ Animalμ„ κµ¬ν„ν•λ‹¤λ” λ»
- dyn μ—†μ΄λ„ νΈλ μ΄νΈ κΈ°λ°μ μ¶”μƒν™” κ°€λ¥
- μ—¬μ „ν μ •μ  λ””μ¤ν¨μΉ λ°©μ‹

### 3. κµ¬ν„μ²΄ λ‚΄λ¶€μ—μ„ μ§μ ‘ μ‚¬μ©
```rust
struct Dog;

impl Animal for Dog {
    fn speak(&self) {
        println!("Woof!");
    }
}

fn main() {
    let dog = Dog;
    dog.speak(); // dyn μ—†μ΄ μ§μ ‘ νΈμ¶
}
```

- Dogλ” Animalμ„ κµ¬ν„ν–κΈ° λ•λ¬Έμ— dyn μ—†μ΄λ„ λ©”μ„λ“ νΈμ¶ κ°€λ¥

## π” μ–Έμ  dynμ΄ ν•„μ”ν•κ°€?
- λ°νƒ€μ„μ— μ—¬λ¬ κµ¬ν„μ²΄λ¥Ό λ‹¤λ¤„μ•Ό ν•  λ•
- νΈλ μ΄νΈ κ°μ²΄λ¥Ό μ°Έμ΅°ν•κ±°λ‚ λ°•μ‹±ν•  λ•
```rust
let animals: Vec<Box<dyn Animal>> = vec![Box::new(Dog {}), Box::new(Cat {})];
```

## π§  μ”μ•½: Rustμ—μ„ `dyn` μ‚¬μ© μ—¬λ¶€μ™€ λ””μ¤ν¨μΉ λ°©μ‹
| ν‘ν„ λ°©μ‹       | `dyn` μ‚¬μ© | λ””μ¤ν¨μΉ λ°©μ‹     | μ„¤λ…                                      |
|----------------|------------|-------------------|-------------------------------------------|
| `T: Trait`     | β         | μ •μ  λ””μ¤ν¨μΉ     | μ λ„¤λ¦­ νƒ€μ…μ— νΈλ μ΄νΈ λ°”μ΄λ“ μ μ©       |
| `impl Trait`   | β         | μ •μ  λ””μ¤ν¨μΉ     | λ°ν™ νƒ€μ… λλ” μΈμλ΅ νΈλ μ΄νΈ μ¶”μƒν™”    |
| `Box<dyn T>`   | β…         | λ™μ  λ””μ¤ν¨μΉ     | ν™μ— μ €μ¥λ νΈλ μ΄νΈ κ°μ²΄                 |
| `&dyn Trait`   | β…         | λ™μ  λ””μ¤ν¨μΉ     | μ°Έμ΅°ν• νΈλ μ΄νΈ κ°μ²΄                      |

---




