# as
Rust의 `as` 키워드는 **타입 캐스팅(type casting)** 을 명시적으로 수행할 때 사용되며, 특히 기본 타입 간의 변환에서 자주 쓰입니다.  
하지만 `as` 는 단순하면서도 주의할 점이 많은 도구.

## 🧠 as 키워드란?
- Rust는 암묵적 타입 변환을 허용하지 않음
- as는 명시적 타입 변환을 수행하는 키워드
- 주로 숫자 타입 간 변환, char → u32, 포인터 변환 등에 사용됨

## 🔍 예제 분석
```rust
fn string_to_digit(input: String) -> i32 {
    let mut ret = 0;
    for c in input.chars() {
        ret = ret * 10;
        ret += c as i32 - '0' as i32;
    }
    ret
}
```

### 동작 원리
- c as i32: char 타입을 i32로 변환 → 유니코드 코드 포인트 값을 반환
- '0' as i32: 문자 '0'의 코드 포인트는 48
- 따라서 '5' as i32 - '0' as i32는 53 - 48 = 5

## 문제점
```
let str = String::from("jhjeong");
```

- 이 문자열은 숫자가 아닌 문자로 구성되어 있음
- 예: 'j' as i32 - '0' as i32 = 106 - 48 = 58 → 의도한 숫자 변환이 아님
- 결과적으로 string_to_digit("jhjeong")는 의미 없는 숫자를 반환함

## ⚠️ as 사용 시 주의사항
| 항목                      | 설명                                      |
|---------------------------|-------------------------------------------|
| `as`                      | 명시적 타입 변환 키워드                    |
| `300u32 as u8 = 44`       | 오버플로우 발생 → 300은 u8 범위 초과, 값 잘림 |
| `f64 as i32`              | 소수점 이하 잘림 → 반올림 아님             |
| `char as i32`             | 유니코드 코드 포인트로 변환됨              |
| `as` vs `From/Into/TryFrom` | `as`는 안전성 낮음, `TryFrom`은 오류 처리 가능 |


### ✅ 안전한 대안 ( `u32::try_from` )
- `TryFrom` / `TryInto` 를 사용하면 범위 체크와 오류 처리 가능:
```rust
use std::convert::TryFrom;

fn safe_char_to_digit(c: char) -> Option<u32> {
    if c.is_ascii_digit() {
        Some(u32::try_from(c as u32 - '0' as u32).ok()?)
    } else {
        None
    }
}
```

### 개선안
```rust
fn string_to_digit(input: &str) -> i32 {
    let mut ret = 0;
    for c in input.chars() {
        if c.is_ascii_digit() {
            ret = ret * 10 + (c as i32 - '0' as i32);
        }
    }
    ret
}

fn main() {
    let input = "12a4";
    let result = string_to_digit(input);
    println!("Parsed number: {}", result); // 출력: 124
}
```


## 📌 핵심 요약
| 표현           | 타입 또는 기능     | 결과 또는 설명     |
|----------------|--------------------|---------------------|
| `c as i32`     | `char`             | `'5'` → `53` (유니코드 코드 포인트) |
| `'0' as i32`   | `char`             | `'0'` → `48`        |
| `as`           | 명시적 타입 변환   | 안전성 낮음, 오버플로우 가능성 있음 |
| `TryFrom`      | 안전한 타입 변환   | `Result` 반환, 오류 처리 가능 |

---

## 객체 변환 
타입 캐스팅이나 트레이트 객체 변환 등에서 매우 유용하게 사용됩니다.  
특히 as는 타입 변환, 트레이트 객체 업캐스팅, 포인터 변환 등에 활용됩니다.

## 🧠 as 키워드의 주요 용도
| 키워드 | 용도 설명                              |
|--------|-----------------------------------------|
| as     | 타입 변환 (정수, 포인터, 트레이트 객체) |
|        | `&T as &dyn Trait`                        |
|        | `Box<T> as Box<dyn Trait>`                |
|        | `*const T as usize` (포인터 → 정수)       |
|        | `u32 as f64` (정수 → 부동소수점)          |

## 🔍 예시 설명
- `&T as &dyn Trait`: 정적 타입을 트레이트 객체로 업캐스팅 → 다형성 구현
- `Box<T> as Box<dyn Trait>`: 힙에 있는 구조체를 트레이트 객체로 변환
- `u8 as u32`: 타입 크기 확장
- `*const T as usize`: 포인터를 정수로 변환 → FFI나 저수준 작업에서 사용


## ✅ Box<T> as Box<dyn Trait>
```
struct MyStruct;
impl MyTrait for MyStruct {}

let boxed: Box<MyStruct> = Box::new(MyStruct);
let trait_box: Box<dyn MyTrait> = boxed as Box<dyn MyTrait>;
```
- 이 코드에서 as는 `Box<MyStruct>` 를 `Box<dyn MyTrait>` 로 업캐스팅하는 역할.
- 즉, 구조체를 힙에 올린 후 트레이트 객체로 변환.


## ✅ 기본 예제: 타입 캐스팅
```rust
fn main() {
    let x: u8 = 10;
    let y = x as u32; // u8 → u32로 변환
    println!("y: {}", y);
}
```

## ✅ 트레이트 객체 변환 예제
```rust
trait Animal {
    fn speak(&self);
}

struct Dog;
impl Animal for Dog {
    fn speak(&self) {
        println!("Woof!");
    }
}

fn main() {
    let dog = Dog;
    let animal: &dyn Animal = &dog as &dyn Animal; // 업캐스팅
    animal.speak();
}
```

- &dog as &dyn Animal은 Dog를 Animal 트레이트 객체로 변환
- 이 방식은 **다형성(polymorphism)** 을 구현할 때 핵심

## 🧩 실전 예제: 구조체 + 트레이트 객체 + Box
```rust

trait Drawable {
    fn draw(&self);
}

struct Circle;

impl Drawable for Circle {
    fn draw(&self) {
        println!("Drawing a circle");
    }
}

struct Canvas {
    items: Vec<Box<dyn Drawable>>,
}

fn main() {
    let circle = Circle;
    let boxed: Box<dyn Drawable> = Box::new(circle) as Box<dyn Drawable>; // Box 업캐스팅

    let mut canvas = Canvas { items: vec![] };
    canvas.items.push(boxed);

    for item in &canvas.items {
        item.draw();
    }
}
```

- Box<Circle>을 Box<dyn Drawable>로 변환
- 구조체 Canvas는 다양한 Drawable 객체를 저장 가능

## ⚠️ 주의사항
- as는 안전한 변환만 허용합니다. 예를 들어 f64 as u8은 가능하지만, 손실이 발생할 수 있음
- 트레이트 객체로 변환할 때는 트레이트가 `dyn` 으로 명시돼야 함
- 구조체 내부에서는 as를 직접 쓰기보다는 외부에서 필드나 인스턴스를 변환하는 데 사용됨

---

# 🧠 *const T as usize란?
- *const T는 어떤 타입 T에 대한 불변 포인터
- as usize는 그 포인터를 정수 주소값으로 변환하는 것
- 즉, 메모리 주소를 숫자 형태로 다루고 싶을 때 사용

## 🧪 사용 예시
### 1. 주소 기반 해시 계산
```rust
use std::collections::HashSet;

struct MyType;

fn main() {
    let a = MyType;
    let b = MyType;

    let ptr_a = &a as *const MyType as usize;
    let ptr_b = &b as *const MyType as usize;

    let mut set = HashSet::new();
    set.insert(ptr_a);
    set.insert(ptr_b);

    println!("Unique addresses: {:?}", set);
}
```
- 📌 이 예시는 MyType 인스턴스의 메모리 주소를 정수로 변환해서 해시셋에 저장하는 방식. 객체의 고유성을 주소 기반으로 판단할 때 유용.

## 2. 정렬된 포인터 비교 (주소 순서)
```rust
let a = &10;
let b = &20;

let addr_a = a as *const i32 as usize;
let addr_b = b as *const i32 as usize;

if addr_a < addr_b {
    println!("a comes before b in memory");
}
```
- 📌 포인터끼리 직접 비교하는 대신, 정수 주소값으로 변환해서 메모리 순서를 판단하는 방식이에요.

## 3. Unsafe한 메모리 연산이나 디버깅용 출력
```rust
fn debug_address<T>(val: &T) {
    let addr = val as *const T as usize;
    println!("Address: 0x{:x}", addr);
}
```
- 📌 디버깅할 때 객체의 실제 메모리 위치를 확인하고 싶을 때 사용해요.

### ⚠️ 주의사항
- 이 캐스팅은 unsafe가 아니지만, 주소값을 직접 다루는 건 위험할 수 있음
- 대부분의 경우 안전한 추상화로 해결할 수 있으므로, 꼭 필요한 경우에만 사용해야 함
- 주소값은 재배치될 수 있으므로, 장기 저장하거나 비교에 사용할 땐 주의가 필요

## 예제: 주소를 저장하고 다시 찾아가서 수정하기
```rust
fn main() {
    let mut value: i32 = 10;

    // 1. 포인터를 usize로 저장
    let addr: usize = &value as *const i32 as usize;
    println!("Original address: 0x{:x}", addr);

    // 2. 나중에 주소를 다시 포인터로 변환하여 수정
    unsafe {
        let ptr: *mut i32 = addr as *mut i32;
        *ptr = 42;
    }
    // 3. 결과 확인
    println!("Modified value: {}", value);
}
```

### 🔍 설명
- &value as *const i32 → usize: 주소를 정수로 저장
- addr as *mut i32: 다시 포인터로 복원
- *ptr = 42: 해당 주소의 값을 수정
- unsafe 블록 안에서만 포인터를 역참조할 수 있음

### ⚠️ 주의사항
- 이 예제는 value가 여전히 유효한 메모리에 존재한다는 전제 하에 안전하게 작동합니다.
- 만약 addr을 오래 저장하거나, 해당 메모리가 해제되거나 이동되면 undefined behavior가 발생할 수 있습니다.
- Rust는 이런 작업을 기본적으로 금지하지 않지만, 프로그래머가 책임지고 안전성을 보장해야 합니다.

---

# 🧠 왜 dyn을 붙여야 할까?
Rust에서 dyn Trait는 **동적 디스패치(dynamic dispatch)** 를 의미합니다.  
즉, 런타임에 어떤 타입의 메서드를 호출할지 결정하는 방식.
```rust
let animal: &dyn Animal = &dog as &dyn Animal;
```
여기서 dyn Animal은 **이 타입은 Animal 트레이트를 구현한 어떤 타입이지만, 정확히 어떤 타입인지는 모름. 대신 런타임에 결정** 라는 뜻.

## 🔍 다른 언어와의 비교

| 언어   | 코드 예시                                 | 타입 설명                                |
|--------|--------------------------------------------|-------------------------------------------|
| Java   | `Animal animal = new Dog();`              | `Animal`은 인터페이스, `Dog`는 구현체     |
| C++    | `Animal* animal = new Dog();`             | `Animal`은 추상 클래스, `Dog`는 서브클래스 |
| Rust   | `let animal: &dyn Animal = &dog;`         | `dyn Animal`은 트레이트 객체, `dog`는 구현체 |

Rust에서는 트레이트 객체를 명시적으로 dyn Trait로 써야 컴파일러가 동적 디스패치를 수행할 수 있음. 이건 의도를 명확히 표현하기 위한 설계입니다.

## ✅ 정리
- dyn Trait는 트레이트 객체를 의미하며, 런타임에 타입이 결정됨
- &dyn Trait, Box<dyn Trait> 등으로 사용
- dyn을 붙이는 이유는 동적 디스패치를 명시적으로 표현하기 위해서


## ✅ dyn 없이 되는 경우: 정적 디스패치
### 1. 제네릭 타입에 트레이트 바운드
```rust
fn speak<T: Animal>(animal: &T) {
    animal.speak();
}
```
- 여기서 T: Animal은 Animal 트레이트를 구현한 타입을 의미
- dyn 없이도 animal.speak() 호출 가능
- 컴파일 타임에 타입이 결정되므로 빠르고 안전함

### 2. impl Trait 사용
```rust
fn get_animal() -> impl Animal {
    Dog {}
}
```
- impl Trait은 반환 타입이 Animal을 구현한다는 뜻
- dyn 없이도 트레이트 기반의 추상화 가능
- 여전히 정적 디스패치 방식

### 3. 구현체 내부에서 직접 사용
```rust
struct Dog;

impl Animal for Dog {
    fn speak(&self) {
        println!("Woof!");
    }
}

fn main() {
    let dog = Dog;
    dog.speak(); // dyn 없이 직접 호출
}
```

- Dog는 Animal을 구현했기 때문에 dyn 없이도 메서드 호출 가능

## 🔍 언제 dyn이 필요한가?
- 런타임에 여러 구현체를 다뤄야 할 때
- 트레이트 객체를 참조하거나 박싱할 때
```rust
let animals: Vec<Box<dyn Animal>> = vec![Box::new(Dog {}), Box::new(Cat {})];
```

## 🧠 요약: Rust에서 `dyn` 사용 여부와 디스패치 방식
| 표현 방식       | `dyn` 사용 | 디스패치 방식     | 설명                                      |
|----------------|------------|-------------------|-------------------------------------------|
| `T: Trait`     | ❌         | 정적 디스패치     | 제네릭 타입에 트레이트 바운드 적용       |
| `impl Trait`   | ❌         | 정적 디스패치     | 반환 타입 또는 인자로 트레이트 추상화    |
| `Box<dyn T>`   | ✅         | 동적 디스패치     | 힙에 저장된 트레이트 객체                 |
| `&dyn Trait`   | ✅         | 동적 디스패치     | 참조형 트레이트 객체                      |

---




