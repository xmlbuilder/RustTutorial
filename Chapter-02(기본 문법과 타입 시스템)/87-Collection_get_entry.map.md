# Vec, HashMap, HashSetì˜ get/entry ë¹„êµ ì •ë¦¬

## 1. ê³µí†µì ìœ¼ë¡œ getì´ í•˜ëŠ” ì¼
- ì„¸ ìë£Œêµ¬ì¡° ëª¨ë‘:
    - ì¡´ì¬í•  ìˆ˜ë„ ìˆê³ , ì—†ì„ ìˆ˜ë„ ìˆëŠ” ê°’ì„ ì•ˆì „í•˜ê²Œ êº¼ë‚´ê¸° ìœ„í•´
    - íŒ¨ë‹‰ ì—†ì´ ê°’ì„ ê°€ì ¸ì˜¤ë ¤ê³  getì„ ì“´ë‹¤.
    - ê³µí†µ ì‹œê·¸ë‹ˆì²˜:
```rust
fn get(â€¦ ) -> Option<&T>  // ë˜ëŠ” Option<&V>
```

- ì¦‰, í•­ìƒ Optionì„ ëŒë ¤ì£¼ê³ ,
    - Some(â€¦) â†’ ê°’ì´ ìˆìŒ
    - None â†’ ì—†ìŒ
- ê·¸ë˜ì„œ ë³´í†µ ì´ë ‡ê²Œ íŒ¨í„´ ë§¤ì¹­í•´ì„œ ì“´ë‹¤:
```rust
match collection.get(key_or_index) {
    Some(v) => { /* ì‚¬ìš© */ }
    None => { /* ì—†ì„ ë•Œ ì²˜ë¦¬ */ }
}
```


## 2. Vec<T>::get 
- ì¸ë±ìŠ¤ë¡œ ê°€ì ¸ì˜¤ê¸°
  - ì‹œê·¸ë‹ˆì²˜ì™€ ì˜ë¯¸
  ```rust
  impl<T> Vec<T> {
      fn get(&self, index: usize) -> Option<&T>;
      fn get_mut(&mut self, index: usize) -> Option<&mut T>;
  }
  ```
  
  - ì¸ë±ìŠ¤(0, 1, 2, â€¦)ë¡œ ì ‘ê·¼.
  - ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ë©´ Noneì„ ë°˜í™˜ â†’ ì ˆëŒ€ íŒ¨ë‹‰í•˜ì§€ ì•ŠìŒ.
  - v[index] ì¸ë±ì‹±ì€ ë²”ìœ„ ë°–ì´ë©´ ë°”ë¡œ íŒ¨ë‹‰.
- ì‚¬ìš© ì˜ˆì‹œ
```rust
let v = vec![10, 20, 30, 40];

let third = match v.get(2) {
    Some(x) => x,
    None => {
        println!("ì„¸ ë²ˆì§¸ ì›ì†Œê°€ ì—†ìŠµë‹ˆë‹¤.");
        return;
    }
};

println!("ì„¸ ë²ˆì§¸ ì›ì†Œ: {}", third);
```

- ì–¸ì œ v[i] ëŒ€ì‹  v.get(i)?
    - ì¸ë±ìŠ¤ê°€ í•­ìƒ ìœ íš¨í•˜ë‹¤ê³  ë³´ì¥ ëª»í•  ë•Œ  
        (ì˜ˆ: ì‚¬ìš©ì ì…ë ¥, ê³„ì‚°ëœ ì¸ë±ìŠ¤)
    - ë¼ì´ë¸ŒëŸ¬ë¦¬/ì„œë²„ ì½”ë“œì²˜ëŸ¼ íŒ¨ë‹‰ì´ ê³§ ì¥ì• ê°€ ë  ìˆ˜ ìˆì„ ë•Œ
    - Option íë¦„(map, and_then, ? ë“±)ì— ìì—°ìŠ¤ëŸ½ê²Œ ì„ì–´ì„œ ì“°ê³  ì‹¶ì„ ë•Œ

## 3. HashMap<K, V>::get 
- í‚¤ë¡œ ê°’ ê°€ì ¸ì˜¤ê¸°
  - ì‹œê·¸ë‹ˆì²˜ì™€ ì˜ë¯¸
  ```rust
  use std::collections::HashMap;
  
  impl<K, V> HashMap<K, V> {
      fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>
      where
          K: std::borrow::Borrow<Q>,
          Q: std::hash::Hash + Eq;
      
      fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>
      where
          K: std::borrow::Borrow<Q>,
          Q: std::hash::Hash + Eq;
  }
  ```
  
  - í‚¤ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê°’(&V)ì„ ê°€ì ¸ì˜´.
  - í‚¤ê°€ ì—†ìœ¼ë©´ None.
- ì‚¬ìš© ì˜ˆì‹œ
```rust
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team = String::from("Blue");
let score = scores.get(&team).copied().unwrap_or(0);

println!("Blue ì ìˆ˜: {}", score);
```

- ì—¬ê¸°ì„œ:
    - scores.get(&team) â†’ Option<&i32>
    - copied() â†’ Option<i32>ë¡œ ë³µì‚¬
    - unwrap_or(0) â†’ ì—†ìœ¼ë©´ 0 ê¸°ë³¸ê°’ìœ¼ë¡œ
- ì–¸ì œ ì“°ë‚˜?
    - ë§µì—ì„œ ê°’ì„ ì½ê³  ì‹¶ì„ ë•Œ ê°€ì¥ ê¸°ë³¸ì ì¸ ë°©ì‹.
    - ê°’ì´ ì—†ì„ ìˆ˜ ìˆëŠ” ìƒí™©ì—ì„œ,
    - ë°”ë¡œ unwrap()ìœ¼ë¡œ í„°ëœ¨ë¦¬ê¸°ë³´ë‹¨ unwrap_or, unwrap_or_elseë¡œ ê¸°ë³¸ê°’ ì§€ì •ì´ í”í•œ íŒ¨í„´.

## 4. HashSet<T>::get 
- **ê°™ì€ ê°’** ì„ ê¸°ì¤€ìœ¼ë¡œ ì›ë³¸ ê°’ ì°¸ì¡° ê°€ì ¸ì˜¤ê¸°
  - HashSet<T>ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ HashMap<T, ()> ë˜í¼ë¼ì„œ, í‚¤(=ì›ì†Œ)ë§Œ ê´€ë¦¬í•˜ëŠ” HashMapì´ë¼ê³  ë³´ë©´ ë¨.
  - ì‹œê·¸ë‹ˆì²˜
  ```rust
  use std::collections::HashSet;
  
  impl<T> HashSet<T> {
      fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>
      where
          T: std::borrow::Borrow<Q>,
          Q: std::hash::Hash + Eq;
  }
  ```
  
  - valueì™€ ë™ë“±í•œ `(Hash + Eq)` ì›ì†Œê°€ ì…‹ ì•ˆì— ìˆìœ¼ë©´, ê·¸ ì›ë˜ ì €ì¥ë˜ì–´ ìˆëŠ” Tì— ëŒ€í•œ ì°¸ì¡°(&T) ë¥¼ ëŒë ¤ì¤Œ.
- ê°„ë‹¨ ì˜ˆì‹œ
```rust
use std::collections::HashSet;

#[derive(Hash, Eq, PartialEq, Debug)]
struct User {
    id: u32,
    name: String,
}

let mut set = HashSet::new();
set.insert(User { id: 1, name: "Alice".into() });

// ê°™ì€ id, nameì„ ê°€ì§€ì§€ë§Œ ë‹¤ë¥¸ ì¸ìŠ¤í„´ìŠ¤
let query = User { id: 1, name: "Alice".into() };

if let Some(u) = set.get(&query) {
    // ì—¬ê¸°ì„œ uëŠ” "ì…‹ì— ì‹¤ì œë¡œ ì €ì¥ëœ" User ì°¸ì¡°
    println!("found user in set: {:?}", u);
}
```

- ì´ê²Œ containsì™€ ë‹¤ë¥¸ ì :
    - contains(&value) â†’ ìˆëƒ ì—†ëƒë§Œ boolë¡œ ì•Œë ¤ì¤Œ.
    - get(&value) â†’ ì‹¤ì œ ì €ì¥ëœ ì›ë³¸ ê°’ ì°¸ì¡°ë¥¼ ëŒë ¤ì¤Œ.
- ì–¸ì œ ìœ ìš©í•˜ëƒ?
    - ì–´ë–¤ ê¸°ì¤€ìœ¼ë¡œ ë™ë“±í•œ ê°’ì„ ì…‹ì— ë„£ì–´ë‘ê³ , ë‚˜ì¤‘ì— **ê·¸ì™€ ê°™ì€ ê°’** ì„ ë˜ì¡Œì„ ë•Œ
- ì…‹ ì•ˆì— ìºì‹œëœ/ê³µìœ ëœ ì›ë³¸ ê°ì²´ë¥¼ ë‹¤ì‹œ ì–»ê³  ì‹¶ì„ ë•Œ.
- ì˜ˆë¥¼ ë“¤ì–´:
    - ë¬¸ìì—´ interning,
    - ì¤‘ë³µ ì œê±°ëœ êµ¬ì¡°ì²´ ëª¨ìŒì—ì„œ **ì´ë¯¸ ìˆë˜ ê·¸ ê°ì²´** ë¥¼ ì¬ì‚¬ìš©í•˜ê³  ì‹¶ì„ ë•Œ.

## 5. ê° getì˜ ìš©ë„ ë¹„êµ ì •ë¦¬
| ì»¬ë ‰ì…˜    | ê¸°ì¤€               | ë°˜í™˜ íƒ€ì…    | ì—†ì„ ë•Œ | ëŒ€í‘œì ì¸ ìš©ë„                         |
|-----------|--------------------|--------------|---------|----------------------------------------|
| Vec<T>    | ì¸ë±ìŠ¤ (usize)     | Option<&T>   | None    | ì•ˆì „í•œ ì¸ë±ìŠ¤ ì ‘ê·¼, ë²”ìœ„ ì²´í¬          |
| HashMap   | í‚¤ (&K í˜¹ì€ &Q)    | Option<&V>   | None    | í‚¤â†’ê°’ ì¡°íšŒ, ê¸°ë³¸ê°’ ì²˜ë¦¬               |
| HashSet   | ê°’ê³¼ ë™ë“±í•œ ê²ƒ(&Q) | Option<&T>   | None    | ì¡´ì¬ í™•ì¸ + ì‹¤ì œ ì €ì¥ëœ ê°’ ì°¸ì¡° ì–»ê¸° |

- ìš”ì•½í•˜ë©´:
    - íŒ¨ë‹‰ ì—†ì´ ê°€ì ¸ì˜¤ê³  ì‹¶ì„ ë•Œ â†’ ì–¸ì œë‚˜ get.
    - Vecì—ì„œëŠ” ì¸ë±ìŠ¤ ì•ˆì „ ì ‘ê·¼.
    - HashMapì—ì„œëŠ” í‚¤ ê¸°ë°˜ ì¡°íšŒ.
    - HashSetì—ì„œëŠ” ë‹¨ìˆœ ì¡´ì¬ í™•ì¸ì´ë©´ contains, **ê·¸ ê°’ ìì²´ë¥¼ ì“°ê³  ì‹¶ë‹¤** ë©´ get.

---

## HashMap entry APIì™€ì˜ ì°¨ì´ì  ì •ë¦¬
- getì€ ì¡°íšŒ(read), 
- entryëŠ” ì¡°íšŒ + ì‚½ì…/ê°±ì‹ (write) íë¦„ì„ ë‹¤ë£¨ëŠ” APIë¼ê³  ì—­í• .
- Vecì—ëŠ” entryê°€ ì—†ìŒ

## ğŸ§© í•µì‹¬ ì°¨ì´ ìš”ì•½
| ë©”ì„œë“œ  | ëª©ì                      | ë°˜í™˜ê°’                     | ì—†ì„ ë•Œ ë™ì‘                     | ëŒ€í‘œì  ì‚¬ìš© ìƒí™© |
|---------|---------------------------|-----------------------------|----------------------------------|------------------|
| get     | ê°’ ì¡°íšŒ(Read)            | Option<&V> ë˜ëŠ” Option<&T> | None ë°˜í™˜                        | ì•ˆì „í•œ ì¡°íšŒ      |
| entry   | ì¡°íšŒ + ì‚½ì…/ê°±ì‹ (Read/Write) | Entry<K, V> enum            | Vacantìœ¼ë¡œ ë¶„ê¸° â†’ ì‚½ì… ê°€ëŠ¥      | ì¹´ìš´íŒ…, ëˆ„ì , ê¸°ë³¸ê°’ ìƒì„± |


## 1. get â€” ê°’ì„ ì½ê¸°ë§Œ í•  ë•Œ
- íŠ¹ì§•
    - ì½ê¸° ì „ìš©
    - ê°’ì´ ì—†ìœ¼ë©´ None
    - ì»¬ë ‰ì…˜ì„ ë³€ê²½í•˜ì§€ ì•ŠìŒ
    - ë‹¨ìˆœ ì¡°íšŒì— ê°€ì¥ ì í•©
- ì˜ˆì‹œ
```rust
let map = HashMap::from([("a", 1), ("b", 2)]);

if let Some(v) = map.get("a") {
    println!("a = {}", v);
}
```

- ì–¸ì œ ì“°ë‚˜
    - ê°’ì´ ìˆì„ ìˆ˜ë„ ì—†ì„ ìˆ˜ë„ ìˆê³ , ì—†ìœ¼ë©´ ê·¸ëƒ¥ None ì²˜ë¦¬í•˜ë©´ ë˜ëŠ” ìƒí™©
    - ì»¬ë ‰ì…˜ì„ ìˆ˜ì •í•  í•„ìš”ê°€ ì—†ì„ ë•Œ

## 2. entry â€” ì—†ìœ¼ë©´ ë§Œë“¤ê³ , ìˆìœ¼ë©´ ìˆ˜ì •í•˜ëŠ” íë¦„
- íŠ¹ì§•
    - ì½ê¸° + ì“°ê¸° ëª¨ë‘ ê°€ëŠ¥
    - ê°’ì´ ì—†ìœ¼ë©´ Vacant, ìˆìœ¼ë©´ Occupied
    - or_insert, or_default, and_modify ê°™ì€ íŒ¨í„´ìœ¼ë¡œ ê°•ë ¥í•œ ì¡°ì‘ ê°€ëŠ¥
- ê¸°ë³¸ íŒ¨í„´
```rust
map.entry(key).or_insert(default_value);
```       

- ì˜ˆì‹œ 1: ì¹´ìš´íŒ…(ì „í˜•ì ì¸ entry ì‚¬ìš©)
```rust
let mut counts = HashMap::new();

for ch in "banana".chars() {
    *counts.entry(ch).or_insert(0) += 1;
}

println!("{:?}", counts); // {'b':1, 'a':3, 'n':2}
```

- ì˜ˆì‹œ 2: ê°’ì´ ìˆì„ ë•Œë§Œ ìˆ˜ì •
```rust
map.entry("score").and_modify(|v| *v += 10);
```

- ì–¸ì œ ì“°ë‚˜
    - ì—†ìœ¼ë©´ ìƒì„±í•˜ê³  ì‹¶ì„ ë•Œ
    - ìˆìœ¼ë©´ ìˆ˜ì •í•˜ê³  ì‹¶ì„ ë•Œ
    - ì¹´ìš´íŒ…, ëˆ„ì , ìºì‹±, lazy initialization

## 3. get vs entry ë¹„êµë¥¼ ì½”ë“œë¡œ ë³´ë©´ ë” ëª…í™•í•´ì§
- âŒ getë§Œìœ¼ë¡œëŠ” ì‚½ì…/ê°±ì‹ ì´ ë¶ˆí¸í•¨
```rust
// ê°’ì´ ì—†ìœ¼ë©´ 0ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ê³  ì¦ê°€ì‹œí‚¤ê³  ì‹¶ë‹¤
let mut map = HashMap::new();

let v = map.get("a"); // Option<&i32>

if v.is_none() {
    map.insert("a", 0);
}

*map.get_mut("a").unwrap() += 1;
```

- ì½”ë“œê°€ ê¸¸ê³ 
- ì¡°íšŒë¥¼ ë‘ ë²ˆ í•´ì•¼ í•˜ê³ 
- race condition ìœ„í—˜ë„ ìˆìŒ(ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½)
- âœ… entryëŠ” í•œ ë²ˆì— í•´ê²°
```rust
*map.entry("a").or_insert(0) += 1;
```

- ê¹”ë”í•˜ê³  ì•ˆì „í•˜ê³  ë¹ ë¥´ë‹¤.

## 4. HashSetì—ì„œë„ entryê°€ í•„ìš”í• ê¹Œ?
- HashSetì—ëŠ” entryê°€ ì—†ë‹¤.
- ì™œëƒí•˜ë©´ HashSetì€ ê°’ ìì²´ê°€ í‚¤ë¼ì„œ, ì‚½ì…/ê°±ì‹  íŒ¨í„´ì´ í¬ê²Œ í•„ìš”í•˜ì§€ ì•Šê¸° ë•Œë¬¸.
- HashSetì—ì„œ "ê°’ì´ ì—†ìœ¼ë©´ ë„£ê³ , ìˆìœ¼ë©´ ê·¸ ê°’ì„ ê°€ì ¸ì˜¤ê³  ì‹¶ë‹¤"ë©´:
    - ì¡´ì¬ ì—¬ë¶€ë§Œ í•„ìš” â†’ contains
    - ì‹¤ì œ ì €ì¥ëœ ê°’ì„ ì–»ê³  ì‹¶ë‹¤ â†’ get

## 5. ìµœì¢… ìš”ì•½
| ìƒí™© | ì¶”ì²œ ë©”ì„œë“œ |
|------|-------------|
| ê°’ì´ ìˆëŠ”ì§€ í™•ì¸ë§Œ í•˜ê³  ì‹¶ë‹¤ | get |
| ê°’ì´ ìˆìœ¼ë©´ ì½ê³ , ì—†ìœ¼ë©´ None ì²˜ë¦¬ | get |
| ê°’ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ì„ ë„£ê³  ì‹¶ë‹¤ | entry |
| ê°’ì´ ìˆìœ¼ë©´ ìˆ˜ì •í•˜ê³  ì‹¶ë‹¤ | entry |
| ì¹´ìš´íŒ…/ëˆ„ì /ì§‘ê³„ | entry |
| ìºì‹±(lazy insert) | entry |

---

# HashMap Entry API ì™„ì „ ì •ë³µ: OccupiedEntryì™€ VacantEntry


- APIì˜ ì§„ì§œ í˜ì€ OccupiedEntryì™€ VacantEntryë¥¼ ì§ì ‘ ë‹¤ë£¨ëŠ” ë°ì„œ ë‚˜ì˜´.
- Rustê°€ í•´ì‹œ í…Œì´ë¸” ë‚´ë¶€ ë²„í‚·ì„ í•œ ë²ˆë§Œ ì°¾ê³ , ê·¸ ê²°ê³¼ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì‚½ì…/ê°±ì‹ /êµì²´ë¥¼ ë§¤ìš° íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬í•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” êµ¬ì¡°.
- ì•„ë˜ì—ì„œ ê°œë… â†’ íŠ¹ì§• â†’ ì½”ë“œ ì˜ˆì‹œ â†’ ì–¸ì œ ì“°ëŠ”ì§€ê¹Œì§€ ê¹”ë”í•˜ê²Œ ì •ë¦¬.

## ğŸ§± Entry APIì˜ ë‘ ê°€ì§€ ë¶„ê¸°
- map.entry(key)ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ë‘ ê°€ì§€ ì¤‘ í•˜ë‚˜ë¥¼ ë°˜í™˜:
    - OccupiedEntry: ì´ë¯¸ í•´ë‹¹ í‚¤ê°€ ì¡´ì¬í•¨
    - VacantEntry: í•´ë‹¹ í‚¤ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŒ
- ì´ ë‘˜ì€ ê°ê° ë‹¤ë¥¸ ë©”ì„œë“œë¥¼ ì œê³µí•´ì„œ, ìƒí™©ì— ë§ê²Œ ê°’ì„ ì¡°ì‘í•  ìˆ˜ ìˆìŒ.

## 1. VacantEntry â€” í‚¤ê°€ ì—†ì„ ë•Œ
- í•µì‹¬ ê°œë…
    - **ì´ í‚¤ëŠ” ì•„ì§ ì—†ìŒ**
    - ìƒˆ ê°’ì„ ì‚½ì…í•  ìˆ˜ ìˆëŠ” ìë¦¬ë¥¼ ë‚˜íƒ€ëƒ„
    - ì‚½ì… ì‹œ í•´ì‹œ ê³„ì‚°ê³¼ ë²„í‚· íƒìƒ‰ì„ ë‹¤ì‹œ í•˜ì§€ ì•ŠìŒ â†’ ë§¤ìš° íš¨ìœ¨ì 
- ì£¼ìš” ë©”ì„œë“œ
    - insert(value) â†’ ê°’ì„ ì‚½ì…í•˜ê³  &mut V ë°˜í™˜
    - key() â†’ ì‚½ì…ë  í‚¤ ì°¸ì¡°
- ì˜ˆì‹œ
```rust
use std::collections::HashMap;

let mut map = HashMap::new();

match map.entry("apple") {
    std::collections::hash_map::Entry::Vacant(v) => {
        v.insert(1); // apple: 1 ì‚½ì…
    }
    _ => {}
}

println!("{:?}", map); // {"apple": 1}
```

- ì–¸ì œ ì“°ë‚˜
    - ê°’ì´ ì—†ì„ ë•Œ ì´ˆê¸°ê°’ì„ ë„£ê³  ì‹¶ì„ ë•Œ
    - or_insertê°€ ë‚´ë¶€ì ìœ¼ë¡œ í•˜ëŠ” ì¼ì„ ì§ì ‘ ì œì–´í•˜ê³  ì‹¶ì„ ë•Œ
    - ì‚½ì… ì‹œì ì— ì¶”ê°€ ë¡œì§ì´ í•„ìš”í•  ë•Œ  
        (ì˜ˆ: ë¡œê·¸ ì¶œë ¥, ê°’ ê²€ì¦, ë‹¤ë¥¸ êµ¬ì¡°ì²´ ìƒì„± ë“±)

## 2. OccupiedEntry â€” í‚¤ê°€ ì´ë¯¸ ìˆì„ ë•Œ
- í•µì‹¬ ê°œë…
    - **ì´ í‚¤ëŠ” ì´ë¯¸ ì¡´ì¬í•¨**
    - ê¸°ì¡´ ê°’ì„ ì½ê±°ë‚˜ ìˆ˜ì •í•˜ê±°ë‚˜ êµì²´í•˜ê±°ë‚˜ ì œê±°í•  ìˆ˜ ìˆìŒ
    - ë§ˆì°¬ê°€ì§€ë¡œ í•´ì‹œ íƒìƒ‰ì„ ë‹¤ì‹œ í•˜ì§€ ì•ŠìŒ
- ì£¼ìš” ë©”ì„œë“œ
    - get() / get_mut() â†’ ê¸°ì¡´ ê°’ ì°¸ì¡°
    - into_mut() â†’ &mut Vë¡œ ë°”ë¡œ ì ‘ê·¼
    - insert(value) â†’ ê¸°ì¡´ ê°’ì„ ìƒˆ ê°’ìœ¼ë¡œ êµì²´í•˜ê³  ì´ì „ ê°’ì„ ë°˜í™˜
    - remove() â†’ ê°’ì„ ì œê±°í•˜ê³  ë°˜í™˜
    - key() â†’ í‚¤ ì°¸ì¡°
- ì˜ˆì‹œ
```rust
use std::collections::HashMap;

let mut map = HashMap::from([("apple", 1)]);

match map.entry("apple") {
    std::collections::hash_map::Entry::Occupied(mut o) => {
        *o.get_mut() += 10; // ê¸°ì¡´ ê°’ ìˆ˜ì •
    }
    _ => {}
}

println!("{:?}", map); // {"apple": 11}
```

- ì–¸ì œ ì“°ë‚˜
    - ê°’ì´ ì´ë¯¸ ìˆì„ ë•Œ ìˆ˜ì •/ê°±ì‹ ì´ í•„ìš”í•  ë•Œ
    - ê¸°ì¡´ ê°’ì„ êµì²´í•˜ê±°ë‚˜ ì‚­ì œí•´ì•¼ í•  ë•Œ
    - ê°’ì˜ ì†Œìœ ê¶Œì„ ê°€ì ¸ì™€ì•¼ í•  ë•Œ

## 3. ë‘ Entryë¥¼ ë¹„êµí•œ í‘œ
| Entry íƒ€ì…      | ì˜ë¯¸                 | ê°€ëŠ¥í•œ ì‘ì—…                                   | ëŒ€í‘œ ë©”ì„œë“œ                          |
|------------------|----------------------|-----------------------------------------------|---------------------------------------|
| VacantEntry      | í‚¤ê°€ ì—†ìŒ            | ìƒˆ ê°’ ì‚½ì…, í‚¤ í™•ì¸                           | insert, key                           |
| OccupiedEntry    | í‚¤ê°€ ì´ë¯¸ ì¡´ì¬í•¨     | ê°’ ì½ê¸°, ìˆ˜ì •, êµì²´, ì‚­ì œ, í‚¤ í™•ì¸           | get, get_mut, insert, remove, key     |


## 4. ì‹¤ì „ ì˜ˆì œ: ê°’ì´ ìˆìœ¼ë©´ ìˆ˜ì •, ì—†ìœ¼ë©´ ìƒì„±
- entry ì—†ì´ í•˜ë©´ ë³µì¡í•¨
```rust
let mut map = HashMap::new();

if map.contains_key("a") {
    *map.get_mut("a").unwrap() += 1;
} else {
    map.insert("a", 1);
}
```

- entry + matchë¡œ ê¹”ë”
```rust
match map.entry("a") {
    Entry::Occupied(mut o) => {
        *o.get_mut() += 1;
    }
    Entry::Vacant(v) => {
        v.insert(1);
    }
}
```

- ë” ê¹”ë”í•œ íŒ¨í„´: or_insert
```rust
*map.entry("a").or_insert(0) += 1;
```


## 5. ê³ ê¸‰ íŒ¨í„´: ê°’ì˜ ì†Œìœ ê¶Œ ì´ë™
- OccupiedEntry::remove_entry()ëŠ” í‚¤ì™€ ê°’ ëª¨ë‘ë¥¼ ì†Œìœ ê¶Œê³¼ í•¨ê»˜ ë°˜í™˜ í•¨.
```rust
if let Entry::Occupied(o) = map.entry("apple") {
    let (k, v) = o.remove_entry();
    println!("removed: {} -> {}", k, v);
}
```

- ì´ê±´ ì¼ë°˜ì ì¸ remove()ë¡œëŠ” í•  ìˆ˜ ì—†ëŠ” ì‘ì—…ì´ì•¼.

## 6. ìµœì¢… ìš”ì•½
- get â†’ ì¡°íšŒë§Œ
- entry â†’ ì¡°íšŒ + ì‚½ì…/ê°±ì‹ /ì‚­ì œê¹Œì§€ í•œ ë²ˆì— ì²˜ë¦¬

- VacantEntry â†’ ê°’ì´ ì—†ì„ ë•Œ, ì‚½ì… ì¤‘ì‹¬
- OccupiedEntry â†’ ê°’ì´ ìˆì„ ë•Œ, ìˆ˜ì •/êµì²´/ì‚­ì œ ì¤‘ì‹¬

---





