# Vector try_reserve
try_reserve는 Rust의 Vec에서 메모리를 미리 확보할 때, 실패 가능성을 고려해 안전하게 처리할 수 있도록 도와주는 메서드입니다.  
메모리 부족 등으로 인해 할당이 실패하면 Result를 반환합니다.

## 🧠 Vec::try_reserve란?
Rust의 Vec은 동적 배열로, 요소를 추가할 때 내부적으로 메모리를 재할당합니다.  
이때 미리 충분한 공간을 확보하고 싶다면 reserve()를 사용할 수 있지만, reserve()는 메모리 할당 실패 시 panic을 발생시킵니다.  
반면, try_reserve()는 panic 대신 Result를 반환하여 실패를 안전하게 처리할 수 있습니다.
```rust
let mut vec = Vec::new();
match vec.try_reserve(10_000_000_000) {
    Ok(_) => println!("메모리 확보 성공"),
    Err(e) => println!("메모리 확보 실패: {:?}", e),
}
```


## 📌 주요 특징
- 메모리 확보 실패 시 panic 대신 오류 반환
- 반환 타입: Result<(), CollectionAllocErr>
- 실패 원인: 메모리 부족, 용량 초과, 시스템 제한 등
- 사용 시점: 대량의 데이터를 추가하기 전에 미리 공간 확보할 때

## 🔍 관련 메서드 비교

| 메서드              | 설명               | 실패 시 행동   |
|---------------------|--------------------|----------------|
| `reserve()`         | 용량 확보          | panic 발생     |
| `try_reserve()`     | 용량 확보          | `Err` 반환     |
| `reserve_exact()`   | 정확한 용량 확보   | panic 발생     |
| `try_reserve_exact()` | 정확한 용량 확보 | `Err` 반환     |


## ✅ 언제 사용하나요?
- 안정성이 중요한 시스템 (예: 서버, 임베디드 환경)
- 대량의 데이터를 처리할 때 미리 메모리 확보
- panic을 피하고 싶을 때 예외 상황을 직접 처리

---

# resize

Rust에서 기존 메모리의 내용을 유지하면서 Vec의 크기를 조절하는 메서드는 바로 입니다.

## 🧩 Vec::resize 개요
```rust
fn resize(&mut self, new_len: usize, value: T)
```

- 기존 요소는 그대로 유지하면서 Vec의 길이를 변경합니다.
- new_len이 현재 길이보다 크면 value를 복제해서 추가합니다.
- new_len이 현재 길이보다 작으면 뒤쪽 요소들을 제거합니다.

## ✅ 예제
```rust
fn main() {
    let mut vec = vec![1, 2, 3];
    vec.resize(5, 0); // 길이를 늘림
    println!("{:?}", vec); // [1, 2, 3, 0, 0]

    vec.resize(2, 0); // 길이를 줄임
    println!("{:?}", vec); // [1, 2]
}
```


## 📌 특징 요약
| 동작 유형       | 설명                                      | 요구 사항         |
|----------------|-------------------------------------------|-------------------|
| 길이 증가       | 지정된 `value`를 복제하여 새 요소 채움     | `value: Clone` 필요 |
| 길이 감소       | 뒤쪽 요소 제거                            | 없음              |
| 기존 요소 유지  | 앞쪽 요소는 그대로 유지됨                 | 없음              |


🧠 관련 메서드
- truncate(n): 뒤쪽 요소를 제거하여 길이를 n으로 줄임
- clear(): 모든 요소 제거
- resize_with(n, f): f()를 호출해 새 요소 생성

---
# with_capacity / try_reserve_exact / shrink_to_fit

## 🧠 Rust Vec 메모리 관리 메서드 비교
| 메서드                | 용도 설명                          | 실패 시 행동     | 메모리 증가 | 메모리 감소 |
|-----------------------|------------------------------------|------------------|--------------|--------------|
| `with_capacity(n)`    | 초기 용량 `n`으로 벡터 생성         | `panic` 발생     | ✅           | ❌           |
| `try_reserve_exact(n)`| 정확히 `n`만큼 메모리 확보 시도     | `Err` 반환       | ✅           | ❌           |
| `shrink_to_fit()`     | 현재 요소 수에 맞게 메모리 축소     | 없음              | ❌           | ✅           |


## 🔹 with_capacity(n)
```rust
let mut vec = Vec::with_capacity(100);
```

- Vec를 생성할 때 미리 100개의 요소를 담을 수 있는 공간 확보
- 성능 최적화에 유리 (재할당 줄임)
- 실패 시 panic 발생 가능 (메모리 부족 등)

## 🔹 try_reserve_exact(n)
```rust
let mut vec = Vec::new();
match vec.try_reserve_exact(1_000_000_000) {
    Ok(_) => println!("메모리 확보 성공"),
    Err(e) => println!("실패: {:?}", e),
}
```

- 정확히 n개의 요소를 위한 메모리 확보 시도
- 실패 시 Err(CollectionAllocErr) 반환
- reserve_exact()와 유사하지만 panic 대신 오류 처리 가능

## 🔹 shrink_to_fit()
```rust
let mut vec = vec![1, 2, 3];
vec.reserve(100); // 여유 공간 확보
vec.shrink_to_fit(); // 실제 요소 수에 맞게 메모리 축소
```

- 벡터의 현재 길이에 맞게 메모리 줄임
- 여유 공간 제거 → 메모리 절약
- 실패 시 아무 일도 일어나지 않음 (안전함)

### 🧩 언제 어떤 걸 써야 할까?

| 상황                                | 추천 메서드             |
|-------------------------------------|--------------------------|
| 벡터 생성 시 미리 용량을 확보하고 싶을 때 | `with_capacity(n)`       |
| 안전하게 대량 메모리를 확보하고 싶을 때 | `try_reserve_exact(n)`   |
| 불필요한 여유 메모리를 줄이고 싶을 때   | `shrink_to_fit()`        |

---

## trancate
Rust의 Vec::truncate 메서드는 벡터의 길이를 줄이는 데 사용하는 안전한 메서드입니다.

## ✂️ Vec::truncate란?
```rust
fn truncate(&mut self, len: usize)
```

- 벡터의 길이를 len으로 줄입니다.
- 현재 길이가 len보다 크면, 뒤쪽 요소들을 제거합니다.
- 현재 길이가 len보다 작거나 같으면 아무 일도 일어나지 않습니다.
- 메모리는 해제되지 않지만 요소는 drop됩니다.

## ✅ 예제
```rust
fn main() {
    let mut vec = vec![10, 20, 30, 40, 50];
    vec.truncate(3);
    println!("{:?}", vec); // 출력: [10, 20, 30]
}
```

- vec의 길이를 3으로 줄이면, [40, 50]은 제거됨
- vec.truncate(10)처럼 현재 길이보다 큰 값을 넣으면 아무 변화 없음

## 📌 Vec::truncate 특징 요약
| 동작 유형       | 설명                                      | 부가 효과         |
|----------------|-------------------------------------------|-------------------|
| 길이 감소       | 지정한 길이보다 큰 요소는 제거됨           | 제거된 요소는 `Drop` 처리됨 |
| 길이 증가       | 불가능 (추가 요소는 생성되지 않음)        | 없음              |
| 안전성          | panic 발생하지 않음                       | 안정적 동작       |
| 메모리 해제     | 하지 않음 (용량은 유지됨)                 | 메모리는 그대로   |
| 요소 유지       | 앞쪽 요소는 그대로 유지됨                 | 그대로 유지됨     |


## 🧠 언제 사용하나요?
- 벡터의 일부만 남기고 나머지를 제거하고 싶을 때
- 메모리는 유지하되, 요소만 줄이고 싶을 때
- resize와 달리 새 요소를 추가하지 않고 단순히 잘라내고 싶을 때

---

## resize / truncate

Vec::resize와 Vec::truncate는 둘 다 벡터의 길이를 줄일 수 있지만, 의도와 동작 방식에 차이가 있습니다.

## 🔍 `resize` vs `truncate` 차이점

| 항목             | `resize(new_len, value)`                  | `truncate(new_len)`               |
|------------------|-------------------------------------------|-----------------------------------|
| 길이 증가        | `value.clone()`으로 새 요소 추가           | ❌ 불가능                          |
| 길이 감소        | 뒤쪽 요소 제거                             | 뒤쪽 요소 제거                     |
| 요소 추가 시 요구 | `value: Clone` 필요                        | 없음                              |
| 안전성           | panic 없음                                 | panic 없음                         |
| 메모리 해제      | 하지 않음 (용량 유지됨)                    | 하지 않음 (용량 유지됨)            |
| 목적             | 길이 조절 + 새 요소 추가 가능              | 단순히 잘라내기                    |
| 사용 의도        | 유연한 길이 조절                           | 빠르고 간단한 요소 제거            |


## ✅ 핵심 차이 요약
- resize는 길이를 늘릴 수도 있고 줄일 수도 있음. 늘릴 때는 value.clone()을 사용해 새 요소를 채움.
- truncate는 길이를 줄이는 데만 사용. 새 요소를 추가하지 않음.
- resize는 유연한 조절이 가능하지만, Clone 제약이 있음.
- truncate는 빠르고 단순한 잘라내기에 적합함.

## 🧪 예제 비교
```rust
let mut vec = vec![1, 2, 3, 4, 5];
vec.resize(3, 0); // [1, 2, 3]
vec.resize(6, 9); // [1, 2, 3, 9, 9, 9]

let mut vec2 = vec![1, 2, 3, 4, 5];
vec2.truncate(3); // [1, 2, 3]
// vec2.truncate(6); // 아무 변화 없음
```

## 요약:
- resize는 "길이를 조절하면서 새 요소도 넣고 싶을 때"
- truncate는 "그냥 뒤쪽을 잘라내고 싶을 때"

---

## retain / drain

Rust의 Vec에서 자주 사용되는 두 메서드인 retain과 drain에 대한 설명입니다.  
둘 다 벡터의 요소를 선택적으로 제거하는 데 사용되지만, 목적과 방식이 다릅니다.

## 🧹 Vec::retain
```rust
fn retain<F>(&mut self, f: F)
where
    F: FnMut(&T) -> bool
```

- 조건을 만족하는 요소만 남기고 나머지를 제거합니다.
- f는 각 요소에 대해 true를 반환하면 유지, false면 제거합니다.
- 제자리에서 필터링하며, 순서를 유지합니다.

## ✅ 예제
```rust
let mut vec = vec![1, 2, 3, 4, 5];
vec.retain(|&x| x % 2 == 0);
println!("{:?}", vec); // [2, 4]
```


## 🧺 Vec::drain
```rust
fn drain<R>(&mut self, range: R) -> Drain<T>
where
    R: RangeBounds<usize>
```

- 지정한 범위의 요소를 제거하면서 동시에 반환합니다.
- 반환된 Drain은 Iterator로 사용 가능 → 제거된 요소를 순회하거나 수집 가능
- 부분 제거 + 소비가 목적

## ✅ 예제
```rust
let mut vec = vec![10, 20, 30, 40, 50];
let drained: Vec<_> = vec.drain(1..4).collect();
println!("{:?}", vec);     // [10, 50]
println!("{:?}", drained); // [20, 30, 40]
```


## 🔍 `retain` vs `drain` 차이점 요약
| 항목           | `retain`                                 | `drain`                                |
|----------------|-------------------------------------------|-----------------------------------------|
| 제거 방식      | 조건 기반 필터링                          | 범위 기반 제거                          |
| 반환값         | 없음                                      | 제거된 요소를 `Iterator`로 반환         |
| 사용 목적      | 유지할 요소를 선택                        | 제거할 요소를 추출                      |
| 순서 유지      | ✅ 유지됨                                 | ✅ 유지됨 (남은 요소 기준)              |
| 메모리 해제    | 제거된 요소는 drop 처리됨                 | 제거된 요소는 drop 처리됨               |
| 사용 예시      | `vec.retain(|x| 조건)`                    | `vec.drain(시작..끝).collect()`         |

---


