# 함수 호출 스타일 
```rust
let i1u = (std::cmp::min)((std::cmp::max)(i1, 0) as usize, m - 1);
```


- 이 문법, Rust에서 정상적으로 가능하고 꽤 자주 쓰이는 패턴.
- 처음 보면 **뭐야 이 괄호 괴물…** 같지만, 구조를 이해하면 되게 단순.

## 1. 이 표현식이 실제로 하는 일
- 코드를 단계별로 뜯으면:
```rust
(std::cmp::min)(
    (std::cmp::max)(i1, 0) as usize,
    m - 1,
);
```

- 의미는:
    - std::cmp::max(i1, 0)
    - i1과 0 중 더 큰 값을 고른다.
    - 그 값을 usize로 캐스팅
    - as usize
    - std::cmp::min(…, m - 1)
    - 위 값과 m - 1 중 더 작은 값을 고른다.
- 즉, 정수 i1을 [0, m-1] 범위로 clamp 하는 코드.
- 보통은 이렇게 쓰임:
```rust
let x = i1.clamp(0, m - 1);        // 최신 Rust (i32 같은 정수 타입)
let x = std::cmp::min(std::cmp::max(i1, 0), m - 1); // equivalent
```


## 2. 왜 (std::cmp::min)(…) 처럼 쓰나?
- 핵심은:
    - std::cmp::min 이 함수 이름
    - 괄호 (std::cmp::min) 는 **이걸 값으로서의 함수라고 생각해라** 라고 명시하는 것
- Rust에선:
```rust
let f = std::cmp::min; // 함수 포인터/참조
let x = f(1, 2);
```
- 이게 가능해.
- 그걸 **직접 호출** 하듯 쓰면:
```rust
(std::cmp::min)(a, b);
```

- 이거랑 똑같음:
```rust
std::cmp::min(a, b);
```

- 즉, 괄호는 의미를 바꾸지는 않고,
    - 타입 추론 헷갈릴 때
    - 매크로랑 이름이 충돌할 때
    - 함수 포인터로 넘기거나 사용할 때
- 등에 쓰기 좋음.
- 여기선 그냥 **함수로 취급해서 호출하는** 형태일 뿐.

### 3. 왜 이런 스타일이 생기냐?
- 예를 들어, 매크로 이름과 함수 이름이 같을 수 있음:
```rust
macro_rules! min { /* ... */ }
use std::cmp::min;

min!(1, 2);            // 매크로 호출
std::cmp::min(1, 2);   // 함수 호출
(std::cmp::min)(1, 2); // 함수 호출 (더 명시적)
```

- 또는 제네릭 함수에 함수 포인터를 넘기고 싶을 때:
```rust
fn apply2<F>(a: i32, b: i32, f: F) -> i32
where
    F: Fn(i32, i32) -> i32,
{
    f(a, b)
}

let r = apply2(3, 5, std::cmp::min);        // OK
let r2 = apply2(3, 5, std::cmp::max);
```

- 불러다 쓸 때도:
```rust
let f = std::cmp::min;
let x = f(1, 2);
let y = (std::cmp::min)(1, 2);
```

- 모두 동일.

##  4. 이렇게 쓸 수 있는 다른 함수들
- 이 패턴은 “함수 경로(path)”면 전부 가능.
- 예:
```rust
(std::f64::min)(a, b);
(f64::max)(a, b);
(core::cmp::max)(x, y);
(std::mem::swap)(&mut a, &mut b);
(std::mem::replace)(&mut x, new_x);
(std::ptr::drop_in_place)(&mut value);
```

- 또한 내가 만든 함수도 가능:
```rust
mod util {
    pub fn foo(x: i32) -> i32 { x + 1 }
}

let x = (crate::util::foo)(10);
```


## 5. 실전에서 유용한 패턴들
### 5.1 클램프 대체 (구버전 / f64 등)
- 정수에 .clamp() 없거나 f64에 clamp 쓰고 싶을 때:
```rust
let v = 10.5;
let lo = 0.0;
let hi = 1.0;

let clamped = (std::f64::min)((std::f64::max)(v, lo), hi);
```

- 혹은:
```rust
let clamped = v.max(lo).min(hi);
```


### 5.2 정렬용 비교 함수 전달
```rust
let mut v = vec![3, 1, 4];
v.sort_by(std::cmp::Ord::cmp);           // 메서드 경로
v.sort_by(|a, b| std::cmp::Ord::cmp(a,b));
```
- 여기서도 std::cmp::Ord::cmp 는 함수 값처럼 쓰는 것.

### 5.3 Iterator에 함수 넘기기
```rust
let nums = vec![1, 2, 3, 4];
let squares: Vec<_> = nums.iter().map(|x| x * x).collect();

fn is_even(x: &i32) -> bool { x % 2 == 0 }

let evens: Vec<_> = nums.iter().copied().filter(is_even).collect();
let evens2: Vec<_> = nums.iter().copied().filter(|x| (is_even)(x)).collect();
```

- 이것도 (is_even)(x) 처럼 쓸 수 있지만 보통은 그냥 is_even(x)로 씀.

## 6. 요약
- (std::cmp::min)(a, b) 는 완전히 합법이고, std::cmp::min(a, b) 와 동일.
- 괄호를 씌우는 이유:
    - 함수 값으로 다루기 쉽게
    - 매크로/이름 충돌 피해가기
    - 타입/경로를 명확히 하기
- 이 패턴은 모든 함수 경로에 적용 가능:
    - std::cmp::min, std::cmp::max
    - std::mem::swap, std::mem::replace
    - std::ptr::drop_in_place
    - 사용자 정의 함수 경로 등


---


## ✅ 1) min_by, max_by, clamp까지 엮은 유틸 함수 모음
- Rust에는 기본적으로:
    - std::cmp::min
    - std::cmp::max
    - Ord::min, Ord::max
    - Iterator::min_by, Iterator::max_by
    - .clamp(min, max) (정수/float 일부 타입)
- 이런 기능들이 있는데,
    - 기하 알고리즘에서는 값을 특정 범위로 제한(clamp) 하거나
    - 특정 기준으로 최소/최대 선택하는 일이 매우 많음.
- 그래서 보통 아래처럼 유틸 함수 모음을 만들어두면 편함.

### ✅ 실전용 유틸 함수 모음 (Rust)
```rust
pub fn clamp<T: PartialOrd>(x: T, lo: T, hi: T) -> T {
    if x < lo { lo }
    else if x > hi { hi }
    else { x }
}
```

```rust
pub fn min_by<T, F>(a: T, b: T, cmp: F) -> T
where
    F: Fn(&T, &T) -> std::cmp::Ordering,
{
    if cmp(&a, &b) == std::cmp::Ordering::Greater { b } else { a }
}
```

```rust
pub fn max_by<T, F>(a: T, b: T, cmp: F) -> T
where
    F: Fn(&T, &T) -> std::cmp::Ordering,
{
    if cmp(&a, &b) == std::cmp::Ordering::Less { b } else { a }
}
```


## ✅ 사용 예시
### ✅ 1) clamp
```rust
let x = clamp(15.0, 0.0, 10.0);
assert_eq!(x, 10.0);
```

### ✅ 2) min_by / max_by (예: 점과 기준점의 거리 비교)
```rust
use std::cmp::Ordering;

let p0 = Point3D::new(1.0, 2.0, 3.0);
let p1 = Point3D::new(5.0, 1.0, 0.0);
let origin = Point3D::origin();

let nearest = min_by(p0, p1, |a, b| {
    a.distance(&origin)
        .partial_cmp(&b.distance(&origin))
        .unwrap_or(Ordering::Equal)
});
```

- 이런 패턴은 Arc.closest_param_to, Circle.closest_point_to 같은 곳에서 매우 유용.

---


## ✅ 1) **전부 함수 값으로만 다루는 스타일** 예제
- Rust에서는 함수도 값(value) 이기 때문에, 다른 함수에 넘기거나 변수에 저장하거나,
- 심지어 (std::cmp::min)(a, b) 처럼 괄호로 감싸서 호출할 수도 있음.
- 이걸 적극적으로 활용하면 완전 함수형 스타일로 코드를 짤 수 있음.

### ✅ 예제 1 — 함수들을 값으로 저장해서 쓰기
```rust
let f_min = std::cmp::min;
let f_max = std::cmp::max;

let a = f_min(3, 10);
let b = f_max(3, 10);
```


### ✅ 예제 2 — 함수 배열을 만들어 순차 적용
```rust
let funcs: Vec<fn(i32) -> i32> = vec![
    |x| x + 1,
    |x| x * 2,
    |x| x - 3,
];
```
```
let mut v = 10;
for f in funcs {
    v = f(v);
}
assert_eq!(v, ((10 + 1) * 2) - 3);
```


### ✅ 예제 3 — min/max를 함수 값으로 넘기기
```rust
fn apply2<F>(a: i32, b: i32, f: F) -> i32
where
    F: Fn(i32, i32) -> i32,
{
    f(a, b)
}

let r1 = apply2(3, 7, std::cmp::min);
let r2 = apply2(3, 7, std::cmp::max);
```

### ✅ 예제 4 — 함수 포인터를 이용한 clamp 구성
```rust
let f_min = std::cmp::min;
let f_max = std::cmp::max;

let clamp_fn = |x, lo, hi| f_min(f_max(x, lo), hi);

let v = clamp_fn(15, 0, 10);
assert_eq!(v, 10);
```

- 이건 사실상:
```rust
clamp(x, lo, hi)
```

- 와 동일하지만, 전부 함수 값으로만 조합해서 만든 clamp 라는 점이 포인트.

### ✅ 예제 5 — 기하 알고리즘에서 함수형 스타일 적용
- 예를 들어 Circle에서 t를 [0, 2π]로 정규화할 때:
```rust
let wrap = |t: f64| (std::f64::min)((std::f64::max)(t, 0.0), TAU);
```

- 또는:
```rust
let wrap = |t: f64| clamp(t, 0.0, TAU);
```

- 이런 식으로 함수 조합으로 기하 알고리즘을 구성하면 코드가 더 수학적이고 깔끔.

## ✅ 마무리
- 정리하면:
    - ✅ min_by, max_by, clamp는 기하 알고리즘에서 매우 자주 쓰이는 핵심 유틸
    - ✅ Rust에서는 함수도 값이므로 (std::cmp::min)(a, b) 같은 호출이 가능
    - ✅ 함수형 스타일로 조합하면 기하 커널 코드가 더 깔끔하고 안정적
    - ✅ Circle/Arc/Plane 같은 구조에서도 이런 패턴이 매우 잘 맞음

---
