# 2D ê¸°í•˜ ì—°ì‚° í•¨ìˆ˜
ì´ ì½”ë“œë“¤ì€ 2D/3D ê³µê°„ì—ì„œì˜ ê¸°í•˜ ì—°ì‚°ì„ ë‹¤ë£¨ë©°, ê° í•¨ìˆ˜ëŠ” ìˆ˜í•™ì ìœ¼ë¡œ ëª…í™•í•œ ëª©ì ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.  
ì•„ë˜ì— í•¨ìˆ˜ë³„ ìˆ˜í•™ì  ì˜ë¯¸ì™€ ì•Œê³ ë¦¬ì¦˜ íë¦„ì„ ë‹¨ê³„ì ìœ¼ë¡œ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤.

## ğŸ“¦ í•¨ìˆ˜ ìš”ì•½ í‘œ

| í•¨ìˆ˜ ì´ë¦„                          | ì£¼ìš” ê¸°ëŠ¥ ì„¤ëª…                              | ìˆ˜í•™ì /ê¸°í•˜í•™ì  ì˜ë¯¸ ë˜ëŠ” ì•Œê³ ë¦¬ì¦˜ í•µì‹¬             |
|-----------------------------------|---------------------------------------------|-----------------------------------------------------|
| `on_get_sampling_2d`              | 2D ì  ì§‘í•©ì—ì„œ ê· ì¼ ìƒ˜í”Œë§                   | $k = 4 + \sqrt[3]{n}$, ë“±ê°„ê²© ì¶”ì¶œ              |
| `on_get_sampling_3d`              | 3D ì  ì§‘í•©ì—ì„œ ê· ì¼ ìƒ˜í”Œë§                   | ë™ì¼ ë°©ì‹ìœ¼ë¡œ 3D ì  ìƒ˜í”Œë§                          |
| `on_offset_point`                | ë‘ ì  ì‚¬ì´ ë°©í–¥ìœ¼ë¡œ ê±°ë¦¬ë§Œí¼ ì—°ì¥ëœ ì  ê³„ì‚° | ë‹¨ìœ„ ë²¡í„° ë°©í–¥ìœ¼ë¡œ ê±°ë¦¬ë§Œí¼ ì´ë™                    |
| `on_sort_doubles`                | ì‹¤ìˆ˜ ë°°ì—´ ì •ë ¬                               | `total_cmp` ê¸°ë°˜ ì•ˆì •ì  ì •ë ¬                        |
| `on_cull_doubles`                | ì‹¤ìˆ˜ ë°°ì—´ì—ì„œ ê·¼ì ‘ê°’ ì œê±°                    | $|a_i - a_{i-1}| < \text{tol}$ ì œê±°              |
| `on_is_point_on_segment_2d`      | ì ì´ ì„ ë¶„ ìœ„ì— ìˆëŠ”ì§€ íŒë³„                   | íˆ¬ì˜ ë¹„ìœ¨ $t \in [0,1]$, ê±°ë¦¬ < TOL             |
| `on_point_in_rectangle`          | ì ì´ ì§ì‚¬ê°í˜• ë‚´ë¶€/ì™¸ë¶€/ë³€ ìœ„ì¸ì§€ íŒë³„       | ì‚¬ê°í˜• ë³€ ìœ„ ì²´í¬ + ë‚´ë¶€ ì¢Œí‘œ ë²”ìœ„ ì¡°ê±´             |
| `on_point_in_triangle_2d_scalars`| ì ì´ ì‚¼ê°í˜• ë‚´ë¶€ì— ìˆëŠ”ì§€ íŒë³„               | ë²¡í„° ë‚´ì  ê¸°ë°˜ $u, v$ ê³„ì‚°                      |
| `on_is_polygon_convex`           | ë‹¤ê°í˜•ì´ ë³¼ë¡í•œì§€ íŒë³„                       | ì™¸ì  ë¶€í˜¸ ì¼ê´€ì„± í™•ì¸                              |
| `on_is_point_inside_box`         | 3D ë°•ìŠ¤ ë‚´ë¶€ì— ì ì´ ìˆëŠ”ì§€ íŒë³„              | ì—´ë¦°/ë‹«íŒ ì¡°ê±´ì— ë”°ë¼ ì¢Œí‘œ ë²”ìœ„ ë¹„êµ                |
| `on_determinant3_vectors`         | ì •ìœ¡ë©´ì²´ì˜ ë¶€í”¼           | ì²´ì ì„ ê³„ì‚°í•¨                |
## ğŸ“Œ 1. on_get_sampling_2d / on_get_sampling_3d
### âœ³ï¸ ëª©ì 
- í° ì  ì§‘í•©ì—ì„œ ê· ì¼í•˜ê²Œ ìƒ˜í”Œë§ëœ ì¼ë¶€ ì ì„ ì¶”ì¶œ
### ğŸ“ ìˆ˜í•™ì  ì›ë¦¬
- ì „ì²´ ê°œìˆ˜ nì—ì„œ ìƒ˜í”Œ ê°œìˆ˜ $k=4+\sqrt[3]{n}$
- ê°„ê²© $r=\lfloor n/k\rfloor$ 
- $i\in [0,k)$ ì— ëŒ€í•´ $\mathrm{sample}[i]=\mathrm{data}[i\cdot r]$

## ğŸ“Œ 2. on_offset_point
### âœ³ï¸ ëª©ì 
- ë‘ ì  ì‚¬ì´ ë°©í–¥ìœ¼ë¡œ ì¼ì • ê±°ë¦¬ë§Œí¼ ì—°ì¥ëœ ì  ê³„ì‚°
### ğŸ“ ìˆ˜ì‹
- ë²¡í„° $\vec {v}=p_2-p_1$
- ë‹¨ìœ„ ë²¡í„° $\hat {v}=\frac{\vec {v}}{|\vec {v}|}$
- ê²°ê³¼ $p=p_2+\mathrm{length}\cdot \hat {v}$

## ğŸ“Œ 3. on_sort_doubles
### âœ³ï¸ ëª©ì 
- ì‹¤ìˆ˜ ë°°ì—´ì„ ì˜¤ë¦„ì°¨ìˆœ ë˜ëŠ” ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
### ğŸ“ ìˆ˜í•™ì  ì˜ë¯¸
- ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì€ O(n\log n) ë³µì¡ë„
- total_cmpëŠ” IEEE-754 ê¸°ì¤€ìœ¼ë¡œ NaN, Â±0 ë“±ë„ ì•ˆì •ì ìœ¼ë¡œ ë¹„êµ

## ğŸ“Œ 4. on_cull_doubles
### âœ³ï¸ ëª©ì 
- ì‹¤ìˆ˜ ë°°ì—´ì—ì„œ ê·¼ì ‘í•œ ê°’ ì œê±° (ì¤‘ë³µ ì œê±°)
### ğŸ“ ìˆ˜í•™ì  ì›ë¦¬
- ì •ë ¬ í›„ ì¸ì ‘í•œ ê°’ $|a_i-a_{i-1}|<\mathrm{tol}$ ì œê±°
- $\mathrm{tol}\geq \sqrt{\epsilon }$ (ìˆ˜ì¹˜ ì•ˆì •ì„± í™•ë³´)

## ğŸ“Œ 5. on_is_point_on_segment_2d
### âœ³ï¸ ëª©ì 
- ì ì´ ì„ ë¶„ ìœ„ì— ìˆëŠ”ì§€ íŒë³„
### ğŸ“ ìˆ˜ì‹
- ì„ ë¶„ ë°©í–¥ ë²¡í„° $\vec {a}=p_1-p_0$
- íˆ¬ì˜ ë¹„ìœ¨ $t=\frac{(p-p_0)\cdot \vec {a}}{|\vec {a}|^2}$
- $t\in [0,1]$ ì´ê³ , ê±°ë¦¬ $\frac{||p-\mathrm{proj}||}{|\vec {a}|}<\mathrm{TOL}$

## ğŸ“Œ 6. on_point_in_rectangle
### âœ³ï¸ ëª©ì 
- ì ì´ ì§ì‚¬ê°í˜• ë‚´ë¶€, ì™¸ë¶€, ë˜ëŠ” ë³€ ìœ„ì— ìˆëŠ”ì§€ íŒë³„
### ğŸ“ ìˆ˜í•™ì  ì›ë¦¬
- ë³€ ìœ„ íŒë³„: on_is_point_on_segment_2d
- ë‚´ë¶€ íŒë³„: $x\in (x_{\mathrm{min}},x_{\mathrm{max}}),y\in (y_{\mathrm{min}},y_{\mathrm{max}})$

## ğŸ“Œ 7. on_point_in_triangle_2d_scalars
### âœ³ï¸ ëª©ì 
- ì ì´ ì‚¼ê°í˜• ë‚´ë¶€ì— ìˆëŠ”ì§€ íŒë³„ (ë²¡í„° ë°©ì‹)
### ğŸ“ ìˆ˜ì‹
- ë²¡í„° $\vec {v_0}=A_3-A_1$, $\vec {v_1}=A_2-A_1$, $\vec {v_2}=P-A_1$
- ë‚´ì  ê¸°ë°˜ìœ¼ë¡œ u,v ê³„ì‚°:

$$
u=\frac{(v_1\cdot v_1)(v_0\cdot v_2)-(v_0\cdot v_1)(v_1\cdot v_2)}{\mathrm{denom}},\quad v=\frac{(v_0\cdot v_0)(v_1\cdot v_2)-(v_0\cdot v_1)(v_0\cdot v_2)}{\mathrm{denom}}
$$

- ì¡°ê±´: $u>0,v>0,u+v<1$

## ğŸ“Œ 8. on_is_polygon_convex
### âœ³ï¸ ëª©ì 
- ë‹¤ê°í˜•ì´ ë³¼ë¡í•œì§€ íŒë³„
### ğŸ“ ìˆ˜í•™ì  ì›ë¦¬
- ê° ê¼­ì§“ì ì—ì„œ ì™¸ì  $\vec {u}\times \vec {v}$ ì˜ ë¶€í˜¸ê°€ ì¼ì •í•´ì•¼ í•¨
- ì™¸ì : $u_xv_y-u_yv_x$
- ë¶€í˜¸ê°€ ë°”ë€Œë©´ ì˜¤ëª©

## ğŸ“Œ 9. on_is_point_inside_box
### âœ³ï¸ ëª©ì 
- 3D ë°•ìŠ¤ ë‚´ë¶€ì— ì ì´ ìˆëŠ”ì§€ íŒë³„
### ğŸ“ ìˆ˜í•™ì  ì›ë¦¬
- ì—´ë¦° ë°•ìŠ¤: $p_i>\mathrm{min_{\mathnormal{i}}}-\mathrm{inflate}\wedge p_i<\mathrm{max_{\mathnormal{i}}}+\mathrm{inflate}$
- ë‹«íŒ ë°•ìŠ¤: $p_i\geq \mathrm{min_{\mathnormal{i}}}-\mathrm{inflate}\wedge p_i\leq \mathrm{max_{\mathnormal{i}}}+\mathrm{inflate}$


## ğŸ“Œ 10. on_determinant3_vectors
### ğŸ“ ìˆ˜í•™ì  ì •ì˜
### ğŸ”¢ í–‰ë ¬ êµ¬ì„±
ì„¸ ë²¡í„° $\vec {v}_1$, $\vec {v}_2$, $\vec {v}_3$ ë¥¼ ê°ê° í–‰ìœ¼ë¡œ ê°–ëŠ” 3Ã—3 í–‰ë ¬:

$$
M=\left[ \begin{matrix}v_1.x&v_1.y&v_1.z\\ , v_2.x&v_2.y&v_2.z\\ , v_3.x&v_3.y&v_3.z\end{matrix}\right]
$$

- ì´ í•¨ìˆ˜ëŠ” ì´ í–‰ë ¬ì˜ í–‰ë ¬ì‹ì„ ê³„ì‚°í•©ë‹ˆë‹¤.

### âœ³ï¸ í–‰ë ¬ì‹ ê³µì‹
3Ã—3 í–‰ë ¬ì˜ í–‰ë ¬ì‹ì€ ë‹¤ìŒê³¼ ê°™ì´ ê³„ì‚°ë©ë‹ˆë‹¤:  

$$
\mathrm{det}(M)=v_1.x\cdot (v_2.y\cdot v_3.z-v_2.z\cdot v_3.y)-v_1.y\cdot (v_2.x\cdot v_3.z-v_2.z\cdot v_3.x)+v_1.z\cdot (v_2.x\cdot v_3.y-v_2.y\cdot v_3.x)
$$

ì´ ì‹ì€ ì •í™•íˆ í•¨ìˆ˜ ë‚´ë¶€ì˜ ì—°ì‚°ê³¼ ì¼ì¹˜í•©ë‹ˆë‹¤.

### ğŸ“Œ ê¸°í•˜í•™ì  ì˜ë¯¸
- ì´ í–‰ë ¬ì‹ì€ ì„¸ ë²¡í„°ê°€ ë§Œë“œëŠ” í‰í–‰ìœ¡ë©´ì²´ì˜ ë¶€í”¼ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
- ì ˆëŒ“ê°’ì´ 0ì´ë©´ ì„¸ ë²¡í„°ê°€ ê°™ì€ í‰ë©´ì— ìˆìŒ â†’ ì„ í˜• ì¢…ì†
- ì–‘ìˆ˜/ìŒìˆ˜ëŠ” **ì˜¤ë¦¬ì—”í…Œì´ì…˜(ë°©í–¥ì„±)**ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤

### ğŸ§ª ì˜ˆì‹œ
```rust
let v1 = Point::new(1.0, 0.0, 0.0);
let v2 = Point::new(0.0, 1.0, 0.0);
let v3 = Point::new(0.0, 0.0, 1.0);
let det = on_determinant3_vectors(v1, v2, v3); // ê²°ê³¼: 1.0
```
- ë‹¨ìœ„ ë²¡í„° 3ê°œë¡œ êµ¬ì„±ëœ ì •ìœ¡ë©´ì²´ì˜ ë¶€í”¼ëŠ” 1

---

## í…ŒìŠ¤íŠ¸ ì½”ë“œ
```rust
#[cfg(test)]
mod tests {
    use nurbslib::core::basis::on_binomial;
    use nurbslib::core::geom::Point2;
    use nurbslib::core::maths::{on_determinant3_vectors, on_cull_doubles, on_cull_doubles_keep_canonical, on_factorial, on_get_sampling_2d, on_get_sampling_3d, on_offset_point, on_sort_doubles};
    use nurbslib::core::polygon2d::{on_is_point_inside_box, on_is_point_on_segment_2d, on_is_point_on_segment_2d_with_domain, on_is_polygon_convex, on_monotone_chain_2d, on_point_in_rectangle, on_point_in_triangle_2d, on_point_in_triangle_2d_scalars, on_quick_hull_2d, PointStatus};
    use nurbslib::core::prelude::Point;

    #[test]
    fn test_on_get_sampling_2d() {
        let points: Vec<Point2> = (0..100)
            .map(|i| Point2 { x: i as f64, y: i as f64 })
            .collect();
        let sampled = on_get_sampling_2d(&points);
        assert!(sampled.len() >= 4);
        assert!(sampled.len() <= points.len());
        println!("points len: {}", points.len());

    }
```
```rust
    #[test]
    fn test_on_get_sampling_3d() {
        let points: Vec<Point> = (0..100)
            .map(|i| Point::new(i as f64, i as f64, i as f64))
            .collect();
        let sampled = on_get_sampling_3d(&points);
        assert!(sampled.len() >= 4);
        assert!(sampled.len() <= points.len());
    }
```
```rust
    #[test]
    fn test_on_offset_point() {
        let p1 = Point::new(0.0, 0.0, 0.0);
        let p2 = Point::new(1.0, 0.0, 0.0);
        let offset = on_offset_point(p1, p2, 1.0);
        assert_eq!(offset.x, 2.0);
        assert_eq!(offset.y, 0.0);
        assert_eq!(offset.z, 0.0);
    }
```
```rust
    #[test]
    fn test_on_sort_doubles() {
        let mut arr = vec![3.0, 1.0, 2.0];
        on_sort_doubles(&mut arr, true);
        assert_eq!(arr, vec![1.0, 2.0, 3.0]);
        on_sort_doubles(&mut arr, false);
        assert_eq!(arr, vec![3.0, 2.0, 1.0]);
    }
```
```rust
    #[test]
    fn test_on_cull_doubles() {
        let mut arr = vec![1.0000000001, 1.0,  2.0, 2.0000000001];
        let len = on_cull_doubles_keep_canonical(&mut arr, 1e-6);
        assert_eq!(len, 2);
        println!("{:?}", arr);
        assert!(arr.contains(&1.0));
        assert!(arr.contains(&2.0));
    }
```
```rust
    #[test]
    fn test_on_is_point_on_segment_2d() {
        let p0 = Point2::new(0.0, 0.0);
        let p1 = Point2::new(2.0, 0.0);
        let test = Point2::new(1.0, 0.0);
        assert!(on_is_point_on_segment_2d_with_domain(&test, &p0, &p1, 2.0));
    }
```
```rust
    #[test]
    fn test_on_point_in_rectangle() {
        let ll = Point2::new(0.0, 0.0);
        let ur = Point2::new(2.0, 2.0);
        let inside = Point2::new(1.0, 1.0);
        let edge = Point2::new(0.0, 1.0);
        let outside = Point2::new(3.0, 3.0);

        assert_eq!(on_point_in_rectangle(inside, ll, ur), PointStatus::Inside);
        assert_eq!(on_point_in_rectangle(edge, ll, ur), PointStatus::Onto);
        assert_eq!(on_point_in_rectangle(outside, ll, ur), PointStatus::Outside);
    }
```
```rust
    #[test]
    fn test_on_point_in_triangle_2d_scalars() {
        let inside = on_point_in_triangle_2d_scalars(0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);
        let outside = on_point_in_triangle_2d_scalars(1.5, 1.5, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);
        assert!(inside, "Expected point to be inside triangle");
        assert!(!outside, "Expected point to be outside triangle");
    }
```
```rust
    #[test]
    fn test_on_is_polygon_convex() {
        let convex = vec![
            Point2::new(0.0, 0.0),
            Point2::new(1.0, 0.0),
            Point2::new(1.0, 1.0),
            Point2::new(0.0, 1.0),
        ];
        let concave = vec![
            Point2::new(0.0, 0.0),
            Point2::new(1.0, 0.0),
            Point2::new(0.5, 0.5),
            Point2::new(1.0, 1.0),
            Point2::new(0.0, 1.0),
        ];
        assert!(on_is_polygon_convex(&convex));
        assert!(!on_is_polygon_convex(&concave));
    }
```
```rust
    #[test]
    fn test_on_is_point_inside_box() {
        let min = Point::new(0.0, 0.0, 0.0);
        let max = Point::new(1.0, 1.0, 1.0);
        let p_inside = Point::new(0.5, 0.5, 0.5);
        let p_outside = Point::new(2.0, 2.0, 2.0);

        assert!(on_is_point_inside_box(p_inside, min, max, 0.0, false));
        assert!(!on_is_point_inside_box(p_outside, min, max, 0.0, false));
    }
```
```rust
    #[test]
    fn test_get_sampling_2d_basic() {
        let src: Vec<Point2> = (0..27).map(|i| Point2::new(i as f64, 0.0)).collect();
        let got = on_get_sampling_2d(&src);
        // length ~= 4 + cbrt(27) = 4 + 3 = 7
        assert_eq!(got.len(), 7);
        // ë“±ê°„ê²© ìƒ˜í”Œë§ì¸ì§€ (ì •í™• ë“±ê°„ê²©ì€ ì•„ë‹ ìˆ˜ ìˆìœ¼ë‚˜ íŒ¨í„´ í™•ì¸)
        assert_eq!(got.first().unwrap().x, 0.0);
        assert!(got.last().unwrap().x <= 26.0);
    }
```
```rust
    #[test]
    fn test_get_sampling_3d_basic() {
        let src: Vec<Point> = (0..64).map(|i| Point::new(i as f64, 0.0, 0.0)).collect();
        let got = on_get_sampling_3d(&src);
        // 4 + cbrt(64) = 4 + 4 = 8
        assert_eq!(got.len(), 8);
    }
```
```rust
    #[test]
    fn test_offset_point() {
        let a = Point::new(0.0, 0.0, 0.0);
        let b = Point::new(1.0, 0.0, 0.0);
        let o = on_offset_point(a, b, 2.5);
        assert!((o.x - 3.5).abs() < 1e-12);
        assert_eq!(o.y, 0.0);
        assert_eq!(o.z, 0.0);
    }
```
```rust
    #[test]
    fn test_sort_and_cull_doubles() {
        let mut v = vec![3.0, 1.0, 2.0, 2.00000000000001, 1.0];
        on_sort_doubles(&mut v, true);
        assert_eq!(v, vec![1.0, 1.0, 2.0, 2.00000000000001, 3.0]);

        let mut v2 = vec![0.0, 1.0, 1.0 + 1e-16, 2.0, 2.0 + 1e-16];
        let n = on_cull_doubles(&mut v2, 1e-12);
        assert_eq!(n, 3);
        assert_eq!(v2, vec![0.0, 1.0, 2.0]);
    }
```
```rust
    #[test]
    fn test_is_point_on_segment_2d() {
        let a = Point2::new(0.0, 0.0);
        let b = Point2::new(2.0, 0.0);
        assert!(on_is_point_on_segment_2d(&Point2::new(1.0, 0.0), &a, &b, ));
        assert!(!on_is_point_on_segment_2d(&Point2::new(2.1, 0.0), &a, &b));
        assert!(!on_is_point_on_segment_2d(&Point2::new(1.0, 1e-3), &a, &b));
    }
```
```rust
    #[test]
    fn test_point_in_rectangle() {
        let ll = Point2::new(0.0, 0.0);
        let ur = Point2::new(2.0, 1.0);

        assert_eq!(
            on_point_in_rectangle(Point2::new(1.0, 0.5), ll, ur),
            PointStatus::Inside
        );
        assert_eq!(on_point_in_rectangle(Point2::new(0.0, 0.5), ll, ur), PointStatus::Onto);
        assert_eq!(on_point_in_rectangle(Point2::new(2.0, 0.5), ll, ur), PointStatus::Onto);
        assert_eq!(
            on_point_in_rectangle(Point2::new(1.0, 1.5), ll, ur),
            PointStatus::Outside
        );
    }
```
```rust
    #[test]
    fn test_point_in_triangle_2d() {
        let a = Point2::new(0.0, 0.0);
        let b = Point2::new(2.0, 0.0);
        let c = Point2::new(0.0, 2.0);

        assert!(on_point_in_triangle_2d(Point2::new(0.2, 0.2), a, b, c));
        assert!(!on_point_in_triangle_2d(Point2::new(2.0, 2.0), a, b, c));

        // Near barycentric boundary
        assert!(on_point_in_triangle_2d_scalars(
            0.49, 0.49, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0
        ));
        assert!(!on_point_in_triangle_2d_scalars(
            0.6, 0.6, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0
        ));
    }
```
```rust
    #[test]
    fn test_polygon_convex() {
        // Simple square (no distinct start or end point)
        let poly = vec![
            Point2::new(0.0, 0.0),
            Point2::new(1.0, 0.0),
            Point2::new(1.0, 1.0),
            Point2::new(0.0, 1.0),
            Point2::new(0.0, 0.0),
        ];
        assert!(on_is_polygon_convex(&poly));
        // Example of a concave polygon
        let concave = vec![
            Point2::new(0.0, 0.0),
            Point2::new(2.0, 0.0),
            Point2::new(1.0, 0.5),
            Point2::new(2.0, 1.0),
            Point2::new(0.0, 1.0),
            Point2::new(0.0, 0.0),
        ];
        assert!(!on_is_polygon_convex(&concave));
    }
```
```rust
    #[test]
    fn test_quickhull_and_monotone_chain() {
        // Square with interior points
        let pts = vec![
            Point2::new(0.0, 0.0),
            Point2::new(1.0, 0.0),
            Point2::new(1.0, 1.0),
            Point2::new(0.0, 1.0),
            Point2::new(0.5, 0.2),
            Point2::new(0.3, 0.7),
            Point2::new(0.6, 0.6),
        ];

        let hull_qh = on_quick_hull_2d(pts.clone());
        let hull_mc = on_monotone_chain_2d(pts.clone());

        // ë‘ ì•Œê³ ë¦¬ì¦˜ ëª¨ë‘ ì™¸ê³½ 4ê°œ ê¼­ì§“ì ë§Œ ë°˜í™˜í•´ì•¼ í•¨(ìˆœì„œëŠ” ë‹¤ë¥¼ ìˆ˜ ìˆìŒ)
        let mut hq = hull_qh.clone();
        hq.sort_by(|a, b| {
            a.x.partial_cmp(&b.x)
                .unwrap()
                .then(a.y.partial_cmp(&b.y).unwrap())
        });
        let mut hm = hull_mc.clone();
        hm.sort_by(|a, b| {
            a.x.partial_cmp(&b.x)
                .unwrap()
                .then(a.y.partial_cmp(&b.y).unwrap())
        });
        let mut expected = vec![Point2::new(0.0, 0.0), Point2::new(0.0, 1.0), Point2::new(1.0, 0.0), Point2::new(1.0, 1.0)];
        expected.sort_by(|a, b| {
            a.x.partial_cmp(&b.x)
                .unwrap()
                .then(a.y.partial_cmp(&b.y).unwrap())
        });

        assert_eq!(hq, expected);
        assert_eq!(hm, expected);
    }
```
```rust
    #[test]
    fn test_factorial_binomial() {
        assert_eq!(on_factorial(0), 1);
        assert_eq!(on_factorial(5), 120);
        // ì†Œìˆ˜ ì˜¤ì°¨ ê³ ë ¤í•´ì„œ ë¹„êµ
        let c = on_binomial(5, 2) as f64;
        assert!((c - 10.0).abs() < 1e-12);
    }
```
```rust
    #[test]
    fn test_determinant3_vectors() {
        // í‘œì¤€ ê¸°ì €ì˜ det = 1
        let e1 = Point::new(1.0, 0.0, 0.0);
        let e2 = Point::new(0.0, 1.0, 0.0);
        let e3 = Point::new(0.0, 0.0, 1.0);
        assert!((on_determinant3_vectors(e1, e2, e3) - 1.0).abs() < 1e-12);

        // ë™ì¼ í‰ë©´(ì„ í˜• ì¢…ì†) â†’ det = 0
        let v1 = Point::new(1.0, 2.0, 3.0);
        let v2 = Point::new(2.0, 4.0, 6.0);
        let v3 = Point::new(-3.0, -6.0, -9.0);
        assert!(on_determinant3_vectors(v1, v2, v3).abs() < 1e-12);
    }
```
```rust
    #[test]
    fn test_is_point_inside_box() {
        let min = Point::new(-1.0, -1.0, -1.0);
        let max = Point::new(1.0, 1.0, 1.0);

        assert!(on_is_point_inside_box(Point::new(0.0, 0.0, 0.0), min, max, 0.0, false));
        assert!(!on_is_point_inside_box(
            Point::new(2.0, 0.0, 0.0),
            min,
            max,
            0.0,
            false
        ));
        // open intervals
        assert!(on_is_point_inside_box(Point::new(1.0, 0.0, 0.0), min, max, 0.1, true));
    }
}
```
---

