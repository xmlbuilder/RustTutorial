# ìˆ˜ì¹˜ í•´ì„ ì„ í˜•ëŒ€ìˆ˜, ê¸°í•˜, ë¯¸ì ë¶„ ê¸°ë³¸

ì•„ë˜ëŠ” ì£¼ì–´ì§„ í•¨ìˆ˜ë“¤ì˜ ìˆ˜í•™ì  ì˜ë¯¸ë¥¼ ìˆ˜ì‹ê³¼ í•¨ê»˜ ì„¤ëª…í•˜ê³ , ê¸°ëŠ¥ë³„ë¡œ ì •ë¦¬í•œ í‘œë„ í•¨ê»˜ ì œê³µí•©ë‹ˆë‹¤.  
ì´ í•¨ìˆ˜ë“¤ì€ ì„ í˜•ëŒ€ìˆ˜, ê¸°í•˜, ë¯¸ì ë¶„, ìˆ˜ì¹˜í•´ì„ì˜ í•µì‹¬ ì•Œê³ ë¦¬ì¦˜ì„ êµ¬í˜„í•œ ê³ ê¸‰ ìˆ˜í•™ ë„êµ¬ì…ë‹ˆë‹¤.

##  ìˆ˜í•™ì  ì„¤ëª… ìš”ì•½
### 1. ì„ í˜• ì‹œìŠ¤í…œ í•´ë²• (LU ë¶„í•´ ê¸°ë°˜)
- ë¬¸ì œ: $AX=B$
- í•´ë²•: $A=LU$ ë¡œ ë¶„í•´ í›„,
- $LY=B$ (ì „ì§„ ëŒ€ì…)
- $UX=Y$ (í›„ì§„ ëŒ€ì…)

$$
X=U^{-1}L^{-1}B
$$

### 2. 3D ì§ì„  êµì°¨ì  ë° ìµœì†Œ ê±°ë¦¬
- ë‘ ì§ì„ :

$$
L_1(s)=p_1+s\cdot d_1,
L_2(t)=p_2+t\cdot d_2
$$

- êµì°¨ì  ì¡°ê±´:

$$
\mathrm{minimize\  }\| (p_1+sd_1)-(p_2+td_2)\| ^2
$$

- í•´ë²•:

$$
a=dâ‚Â·dâ‚, \quad b=dâ‚Â·dâ‚‚, \quad c=dâ‚‚Â·dâ‚‚
$$

$$
e=dâ‚Â·(pâ‚‚âˆ’pâ‚), \quad f=dâ‚‚Â·(pâ‚‚âˆ’pâ‚)
$$

$$
D=acâˆ’bÂ²
$$

$$
s=(ecâˆ’fb)/D, \quad t=(ebâˆ’fa)/D
$$

### 3. ë‹¨ìœ„ ë²¡í„° ë„í•¨ìˆ˜
- ë¬¸ì œ:

$$
\frac{d}{dt}\left( \frac{\vec {v}}{|\vec {v}|}\right) 
$$

- í•´ë²•:

$$
\left( \frac{\vec {v}}{|\vec {v}|}\right) '=\frac{\vec {v}'\cdot |\vec {v}|-\vec {v}\cdot (\vec {v}'\cdot \vec {v})/|\vec {v}|}{\vec {v}\cdot \vec {v}}
$$


### 4. ì ì‘í˜• ì‹¬í”„ìŠ¨ ì ë¶„
- ê¸°ë³¸ ì‹¬í”„ìŠ¨ ê³µì‹:

$$
\int _a^bf(x)\, dx\approx \frac{b-a}{6}\left[ f(a)+4f\left( \frac{a+b}{2}\right) +f(b)\right]
$$ 

- ì ì‘í˜•:
ë°˜ë³µì ìœ¼ë¡œ ì¤‘ê°„ì ì„ ì¶”ê°€í•˜ë©° ì˜¤ì°¨ê°€ ê¸°ì¤€ ì´í•˜ê°€ ë  ë•Œê¹Œì§€ ë°˜ë³µ

5. ë‹¤í•­ì‹ ë° ë„í•¨ìˆ˜ (Horner ë°©ì‹)
- ë‹¤í•­ì‹:

$$
f(u)=a_0+a_1u+a_2u^2+\dots +a_nu^n
$$

- ë„í•¨ìˆ˜:

$$
f'(u)=a_1+2a_2u+3a_3u^2+\dots +na_nu^{n-1}
$$

- Horner ë°©ì‹:

$$
f(u)=(((a_nu+a_{n-1})u+\dots )u+a_0)
$$

## ğŸ“Š ê¸°ëŠ¥ë³„ ì •ë¦¬ í‘œ

| í•¨ìˆ˜ ì´ë¦„                    | ê¸°ëŠ¥ ìš”ì•½         | ìˆ˜í•™ì  í•µì‹¬ ë˜ëŠ” ìˆ˜ì‹ ìš”ì•½                                 |
|-----------------------------|-------------------|------------------------------------------------------------|
| `solve_linear_system`       | AX = B í•´ë²•       | $A = LU \Rightarrow LY = B, UX = Y \Rightarrow X$     |
| `solve_linear_system_vec`   | Ax = b í•´ë²•       | LU ë¶„í•´ + ì „ì§„/í›„ì§„ ëŒ€ì…                                   |
| `on_intersect_3d_lines_option` | 3D ì§ì„  êµì°¨ì    | $s, t$ ê³„ì‚° â†’ $p_1 + s d_1 = p_2 + t d_2$          |
| `closest_points_of_3d_lines` | 3D ì§ì„  ìµœì†Œ ê±°ë¦¬ | $P(s), Q(t)$ â†’ ë‘ ì§ì„ ì˜ ìµœê·¼ì ‘ì                       |
| `unitized_derivative`       | ë‹¨ìœ„ ë²¡í„° ë„í•¨ìˆ˜  | $\left( \frac{\vec{v}}{|\vec{v}|} \right)'$            |
| `on_integrate_simpson`      | ìˆ˜ì¹˜ ì ë¶„         | $\int_a^b f(x)\,dx \approx \frac{b-a}{6}[f(a)+4f(m)+f(b)]$ |
| `on_polynomial_f_df`        | ë‹¤í•­ì‹ ë° ë„í•¨ìˆ˜  | $f(u), f'(u)$ â†’ Horner ë°©ì‹ìœ¼ë¡œ ê³„ì‚°                   |


---


## ì†ŒìŠ¤ ì½”ë“œ

```rust
/// ì™¸ë¶€ API: AX=B -> X
pub fn solve_linear_system(a: &Matrix, b: &Matrix) -> Result<Matrix, &'static str> {
    if a.row_count() != a.col_count() {
        return Err("square A required");
    }
    if a.col_count() != b.row_count() {
        return Err("A cols must equal B rows");
    }

    let mut alu = a.clone();
    let piv = on_mat_lu_decompose_partial(&mut alu)?;
    lu_solve(&alu, &piv, b)
}
```
```rust
pub fn solve_linear_system_vec(a: &mut Matrix, b: &mut [f64]) -> bool {
    let n = a.row_count();
    if a.col_count() != n || b.len() != n {
        return false;
    }

    // LU ë¶„í•´ (ë¶€ë¶„ í”¼ë²—, Doolittle). í–‰ ìŠ¤ì™‘ ì‹œ bë„ ê°™ì´ ìŠ¤ì™‘.
    for k in 0..n {
        // pivot row ì°¾ê¸° (|a[p,k]| ìµœëŒ€)
        let mut piv = k;
        let mut max_abs = a.at(k as i32, k as i32).abs();
        for i in (k + 1)..n {
            let v = a.at(i as i32, k as i32).abs();
            if v > max_abs {
                max_abs = v;
                piv = i;
            }
        }
        // pivot ì´ ë„ˆë¬´ ì‘ìœ¼ë©´ ì‹¤íŒ¨
        if max_abs <= 1e-30 {
            return false;
        }

        // í–‰ ìŠ¤ì™‘ (A, b ë™ì‹œ)
        if piv != k {
            for j in 0..n {
                let v_p = { *a.at(piv as i32, j as i32) };
                let v_k = { *a.at(k as i32, j as i32) };
                *a.at_mut(piv as i32, j as i32) = v_k;
                *a.at_mut(k as i32, j as i32) = v_p;
            }
            b.swap(piv, k);
        }
        // ì•„ë˜ ì‚¼ê° (L) ê°±ì‹  + trailing ìƒì‚¼ê°(U) ì—…ë°ì´íŠ¸
        let akk = a.at(k as i32, k as i32);
        if akk.abs() <= 1e-30 {
            return false;
        }

        let akk = { *a.at(k as i32, k as i32) };

        for i in (k + 1)..n {
            // A[i,k]ë„ ê°’ìœ¼ë¡œ ë³µì‚¬
            let aik = { *a.at(i as i32, k as i32) };
            let lik = aik / akk;

            // ì°¸ì¡°ê°€ ëª¨ë‘ ë“œë¡­ëœ ë’¤ì— ì“´ë‹¤
            {
                *a.at_mut(i as i32, k as i32) = lik;
            }

            // A(i, j) -= L(i,k) * U(k, j)  (j >= k+1)
            for j in (k + 1)..n {
                // ì½ê¸°ëŠ” ì „ë¶€ ê°’ ë³µì‚¬ë¡œ
                let aij = { *a.at(i as i32, j as i32) };
                let ukj = { *a.at(k as i32, j as i32) };
                let new_val = aij - lik * ukj;
                // ì“°ê¸°ëŠ” ë³„ë„ ë¸”ë¡ì—ì„œ
                {
                    *a.at_mut(i as i32, j as i32) = new_val;
                }
            }
        }
    }

    // ì „ì§„ ëŒ€ì…: L y = b  (Lì˜ ëŒ€ê°ì€ 1ë¡œ ê°€ì •)
    for i in 0..n {
        let mut s = b[i];
        for j in 0..i {
            s -= a.at(i as i32, j as i32) * b[j];
        }
        b[i] = s; // y ì €ì¥(ê·¸ëŒ€ë¡œ bì—)
    }

    // í›„ì§„ ëŒ€ì…: U x = y
    for i in (0..n).rev() {
        let mut s = b[i];
        for j in (i + 1)..n {
            s -= a.at(i as i32, j as i32) * b[j];
        }
        let uii = a.at(i as i32, i as i32);
        if uii.abs() <= 1e-30 {
            return false;
        }
        b[i] = s / uii;
    }

    true
}
```
```rust
pub fn on_intersect_3d_lines_option(
    p1: Vector,
    d1: Vector,
    p2: Vector,
    d2: Vector,
) -> Option<(f64, f64, Vector)> {
    let a = d1.dot(&d1);
    let b = d1.dot(&d2);
    let c = d2.dot(&d2);
    let delta = p2 - p1;
    let e = d1.dot(&delta);
    let f = d2.dot(&delta);
    let denom = a * c - b * b;
    if denom.abs() <= 1e-15 * a.max(1.0) {
        return None;
    }
    let s = (e * c - f * b) / denom;
    let t = (e * b - f * a) / denom;
    let ip = p1 + d1.scale(s);
    Some((s, t, ip))
}
```
```rust
pub fn closest_points_of_3d_lines(
    p1: Vector,
    d1: Vector,
    p2: Vector,
    d2: Vector,
) -> Result<(f64, f64, Vector, Vector), &'static str> {
    let a = d1.dot(&d1);
    let b = d1.dot(&d2);
    let c = d2.dot(&d2);
    let w0 = p1 - p2;
    let d = d1.dot(&w0);
    let e = d2.dot(&w0);

    let denom = a * c - b * b;
    if denom.abs() < 1e-30 {
        return Err("parallel or nearly parallel");
    }
    let s = (b * e - c * d) / denom;
    let t = (a * e - b * d) / denom;

    let ps = p1 + d1.scale(s);
    let qt = p2 + d2.scale(t);
    Ok((s, t, ps, qt))
}
```
```rust
pub fn unitized_derivative(v: &Self, v1: &Self) -> Self {
    // (v/|v|)' = ( v' * |v| - v * (v'Â·v)/|v| ) / (vÂ·v)
    let vv = v.length_squared();
    if vv <= Real::EPSILON {
        return Self {
            x: 0.0,
            y: 0.0,
            z: 0.0,
        };
    }
    let s = vv.sqrt();
    let v1_dot_v = Self::dot_vec(&v1, &v);
    // ì›ë¬¸ ì½”ë“œì— ìˆë˜ ì˜¤ë¥˜ ì£¼ì˜: v'Â·v ê°€ ì•„ë‹ˆë¼ v1Â·v
    let numer =
        Self::scale(v1, s) -
        &Self::scale(v, v1_dot_v / s);
    numer / vv
}
```
```rust
pub fn on_calculate_arc_segments(radius: f64, arc_length: f64, chord_length: f64) -> (usize, f64) {
    // Max segment angle = 2 * acos((R - c) / R)
    // Safeguards: zero, negative, or invalid values
    if radius <= 0.0 {
        return (2, arc_length / 2.0);
    }
    let mut ratio = (radius - chord_length) / radius;
    if ratio < -1.0 {
        ratio = -1.0;
    }
    if ratio > 1.0 {
        ratio = 1.0;
    }

    let max_seg_angle = 2.0 * ratio.acos();

    // As max_seg_angle approaches 0, a large number of segments is required.
    // If arc_length == 0, return 2.
    let n = if max_seg_angle > 0.0 {
        ((arc_length.abs() / max_seg_angle).ceil() as i64).max(2) as usize
    } else {
        2
    };
    (n, arc_length / (n as f64))
}
```
```rust
// on_integrate_simpson (ì ì‘í˜• Simpson, ëˆ„ì  ë°©ì‹)
pub fn on_integrate_simpson<F>(
    mut f: F,
    a: f64,
    b: f64,
    rel_tol: f64,
    max_levels: i32,
    eval_count_out: &mut i32,
    last_delta_out: &mut f64,
) -> f64
where
    F: FnMut(f64) -> f64,
{
    let mut simpson = 0.0_f64;
    let mut prev_simpson = 0.0_f64;
    let mut prev_mid_sum4 = 0.0_f64;
    let mut weighted_sum = 0.0_f64;
    *eval_count_out = 0;
    *last_delta_out = f64::INFINITY;

    for level in 0..=max_levels {
        if level == 0 {
            weighted_sum = f(a) + f(b);
            *eval_count_out = 2;

            // Initial T0 (reference)
            simpson = 0.5 * (b - a) * weighted_sum;
        } else {
            let mid_count = 1 << (level - 1);
            let mid_step = (b - a) / (mid_count as f64);
            let mut x = a + 0.5 * mid_step;
            let mut mid_sum = 0.0;
            for _ in 0..mid_count {
                mid_sum += f(x);
                x += mid_step;
            }
            *eval_count_out += mid_count as i32;

            let mid_sum4 = 4.0 * mid_sum;

            // Add 4 new midpoints and apply correction by subtracting half of the previous midpoint sum (-0.5 * prev_mid_sum4)
            weighted_sum += mid_sum4 - 0.5 * prev_mid_sum4;

            simpson = (b - a) * weighted_sum / ((1 << level) as f64 * 3.0);

            if level >= 5 {
                *last_delta_out = (simpson - prev_simpson).abs();
                if *last_delta_out <= rel_tol * prev_simpson.abs() {
                    return simpson;
                }
            }
            prev_mid_sum4 = mid_sum4;
            prev_simpson = simpson;
        }
    }
    simpson
}
```
```rust
pub fn on_integrate_simpson_simple<F>(f: F, a: f64, b: f64, rel_tol: f64) -> f64
where
    F: FnMut(f64) -> f64,
{
    let mut n = 0;
    let mut d = 0.0;
    on_integrate_simpson(f, a, b, rel_tol, 20, &mut n, &mut d)
}
```
```rust
// ------------------------------------------------------------
// Polynomial f(u) and its derivative f'(u) using Horner's method.
// `a` is the coefficient array.
// If `ascending = true`, the form is: a[0] + a[1] * u + ... + a[n] * u^n
// ------------------------------------------------------------
pub fn on_polynomial_f_df(a: &[f64], u: f64, ascending: bool) -> (f64, f64) {
    let n = a.len().wrapping_sub(1);
    if a.is_empty() {
        return (0.0, 0.0);
    }

    if ascending {
        // Reverse Horner (ascending order of coefficients)
        let mut f = a[n];
        let mut df = 0.0;
        for k in (0..n).rev() {
            df = df * u + f;
            f = f * u + a[k];
        }
        (f, df)
    } else {
        // Stored in descending order: a[0] + a[1] * u + ...
        let mut f = a[0];
        let mut df = 0.0;
        for k in 1..=n {
            df = df * u + f;
            f = f * u + a[k];
        }
        (f, df)
    }
}
```
## ğŸ“ í…ŒìŠ¤íŠ¸ ìˆ˜ì‹ ë° ì„¤ëª… ìš”ì•½
## 1. ì„ í˜• ì‹œìŠ¤í…œ í•´ë²• (solve_linear_system, solve_linear_system_vec)
- ë¬¸ì œ: $AX=B$
- í•´ë²•: $LU$ ë¶„í•´ í›„ ì „ì§„/í›„ì§„ ëŒ€ì…
- ì˜ˆì‹œ:

$$
\left[ \begin{matrix}2&1\\ 1&3\end{matrix}\right] \cdot \left[ \begin{matrix}x\\ y\end{matrix}\right] =\left[ \begin{matrix}5\\ 7\end{matrix}\right] \Rightarrow x=1.6,\  y=1.8
$$


2. 3D ì§ì„  êµì°¨ì  ë° ìµœì†Œ ê±°ë¦¬ (on_intersect_3d_lines_option, on_closest_points_of_3d_lines)
- ë‘ ì§ì„ :

$$
L_1(s)=p_1+s\cdot d_1,
$$

$$
L_2(t)=p_2+t\cdot d_2
$$

- êµì°¨ì  ë˜ëŠ” ìµœì†Œ ê±°ë¦¬ì  ê³„ì‚°:

$$
\mathrm{minimize\  }\| L_1(s)-L_2(t)\| ^2
$$

- ê²°ê³¼: ë‘ ì  ì‚¬ì´ ë²¡í„°ëŠ” ë‘ ë°©í–¥ì— ìˆ˜ì§, ê±°ë¦¬ = ìµœì†Œ ê±°ë¦¬

3. ë‹¨ìœ„ ë²¡í„° ë„í•¨ìˆ˜ (unitized_derivative)
- ì •ì˜:

$$
\left( \frac{\vec {v}}{|\vec {v}|}\right) '=\frac{\vec {v}'\cdot |\vec {v}|-\vec {v}\cdot (\vec {v}'\cdot \vec {v})/|\vec {v}|}{\vec {v}\cdot \vec {v}}
$$

- í…ŒìŠ¤íŠ¸:
- ìˆ˜ì¹˜ ë¯¸ë¶„ê³¼ ë¹„êµ
- ìˆ˜ì§ì„± ê²€ì¦: $u\cdot u'=0$
- í‰í–‰ ë³€í™” ì‹œ $u'=0$
- ìŠ¤ì¼€ì¼ ë¶ˆë³€ì„±

4. ìˆ˜ì¹˜ ì ë¶„ (on_integrate_simpson_simple)
- ì‹¬í”„ìŠ¨ ê³µì‹:

$$
\int _a^bf(x)\, dx\approx \frac{b-a}{6}[f(a)+4f(m)+f(b)]
$$

- í…ŒìŠ¤íŠ¸:

$$
\int _0^{\pi }\sin (x)\, dx=2
$$

$$
\int _0^3(3x^2+2x+1)\, dx=39
$$

5. ë‹¤í•­ì‹ ë° ë„í•¨ìˆ˜ (on_polynomial_f_df)
- ë‹¤í•­ì‹:

$$
f(u)=a_0+a_1u+a_2u^2+\dots 
$$

- ë„í•¨ìˆ˜:

$$
f'(u)=a_1+2a_2u+\dots 
$$

- í…ŒìŠ¤íŠ¸:

$$
f(u)=u^2+u-6\Rightarrow f(2)=0,\  f'(2)=5
$$




## ğŸ§ª í…ŒìŠ¤íŠ¸ ë²”ì£¼ë³„ í™•ì¥ ëª©ë¡

| í…ŒìŠ¤íŠ¸ ë²”ì£¼                     | í¬í•¨ëœ í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ë“¤                                                                 |
|--------------------------------|--------------------------------------------------------------------------------------|
| âœ… ì„ í˜• ì‹œìŠ¤í…œ í•´ë²•             | `test_solve_linear_system_simple`, `test_solve_linear_system_multi_rhs`, `test_solve_linear_system_vec` |
| âœ… 3D ì§ì„  êµì°¨ ë° ìµœì†Œ ê±°ë¦¬    | `test_intersect_3d_lines_min_distance`, `test_on_intersect_3d_lines_option`, `test_min_distance_skew_lines`, `test_closest_points_of_3d_lines` |
| âœ… ë‹¨ìœ„ ë²¡í„° ë„í•¨ìˆ˜             | `test_matches_numeric_derivative`, `test_derivative_is_orthogonal_to_u`, `test_parallel_change_gives_zero`, `test_scale_invariance`, `test_zero_guard_for_tiny_v`, `test_axis_case` |
| âœ… ìˆ˜ì¹˜ ì ë¶„ (ì‹¬í”„ìŠ¨ ë°©ì‹)      | `test_integrate_simpson_sin`, `test_integrate_simpson_poly`, `test_on_integrate_simpson_simple` |
| âœ… ë‹¤í•­ì‹ ë° ë„í•¨ìˆ˜ ê³„ì‚°        | `test_polynomial_f_df_basic`, `test_on_polynomial_f_df`                            |
| âœ… í˜¸ ë¶„í•  ê³„ì‚°                 | `test_calculate_arc_segments`                                                      |
| âœ… ì •ë ¬ ë°°ì—´ ì‚½ì… ê²€ì¦          | `test_insert_value_into_sorted_array`                                              |


## ğŸ“Š ì „ì²´ í…ŒìŠ¤íŠ¸ ê¸°ëŠ¥ ìš”ì•½ í‘œ (í™•ì¥ ë²„ì „)

| í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ ì´ë¦„                     | ê¸°ëŠ¥ ìš”ì•½                         | ìˆ˜í•™ì  ê¸°ëŒ€ ê²°ê³¼ ë˜ëŠ” í•µì‹¬ ìˆ˜ì‹                                      |
|--------------------------------------|----------------------------------|----------------------------------------------------------------------|
| `test_solve_linear_system_simple`    | 2Ã—2 ì„ í˜• ì‹œìŠ¤í…œ í•´ë²•              | $x = 1.6,\ y = 1.8$                                             |
| `test_solve_linear_system_multi_rhs` | ë‹¤ì¤‘ RHS ì„ í˜• ì‹œìŠ¤í…œ í•´ë²•         | $X = A^{-1} B$                                                  |
| `test_solve_linear_system_vec`       | ë²¡í„° ê¸°ë°˜ Ax = b í•´ë²•            | $x = \frac{64}{9},\ y = -\frac{29}{9}$                          |
| `test_intersect_3d_lines_min_distance` | 3D ì§ì„  êµì°¨ì  ê³„ì‚°            | $s = 0,\ t = 1$                                                 |
| `test_min_distance_skew_lines`       | 3D ì§ì„  ìµœì†Œ ê±°ë¦¬ì  ê³„ì‚°         | ë‘ ì  ì‚¬ì´ ë²¡í„°ê°€ ë‘ ë°©í–¥ì— ìˆ˜ì§                                    |
| `test_closest_points_of_3d_lines`    | ìµœê·¼ì ‘ ì  ìŒ ê³„ì‚°                | $P(s), Q(t)$                                                    |
| `test_matches_numeric_derivative`    | ë‹¨ìœ„ ë²¡í„° ë„í•¨ìˆ˜ ìˆ˜ì¹˜ ê²€ì¦       | $u'(0) \approx \frac{u(h) - u(-h)}{2h}$                         |
| `test_derivative_is_orthogonal_to_u` | ë„í•¨ìˆ˜ ìˆ˜ì§ì„± ê²€ì¦               | $u \cdot u' = 0$                                                |
| `test_parallel_change_gives_zero`    | í‰í–‰ ë³€í™” ì‹œ ë„í•¨ìˆ˜ 0            | $v' \parallel v \Rightarrow u' = 0$                             |
| `test_scale_invariance`              | ìŠ¤ì¼€ì¼ ë¶ˆë³€ì„± ê²€ì¦               | $u'(kv, kv') = u'(v, v')$                                       |
| `test_zero_guard_for_tiny_v`         | ê²½ê³„ê°’ ì²˜ë¦¬                       | $|\vec{v}| \approx 0 \Rightarrow u' = 0$                        |
| `test_axis_case`                     | ì¶• ê¸°ì¤€ ìˆ˜ë™ ê²€ì‚°                | $v = (1,0,0),\ v' = (0,1,0) \Rightarrow u' = (0,1,0)$           |
| `test_integrate_simpson_sin`         | ì‚¬ì¸ í•¨ìˆ˜ ì ë¶„                   | $\int_0^{\pi} \sin(x)\, dx = 2$                                 |
| `test_integrate_simpson_poly`        | ë‹¤í•­ì‹ ì ë¶„                       | $\int_0^3 (3x^2 + 2x + 1)\, dx = 39$                            |
| `test_on_integrate_simpson_simple`   | ì¼ë°˜ ì ë¶„                         | $\int_0^1 x^2\, dx = \frac{1}{3}$                               |
| `test_polynomial_f_df_basic`         | ë‹¤í•­ì‹ ë° ë„í•¨ìˆ˜ ê³„ì‚°            | $f(2) = 0,\ f'(2) = 5$                                          |
| `test_on_polynomial_f_df`            | ë‹¤í•­ì‹ í‰ê°€                       | $f(1) = 6,\ f'(1) = 8$                                          |
| `test_calculate_arc_segments`        | í˜¸ ë¶„í•  ê³„ì‚°                      | ì´ í˜¸ ê¸¸ì´ = ë¶„í•  ìˆ˜ Ã— ë¶„í•  ê¸¸ì´ (ì •í™•ë„ ê²€ì¦)                      |


```rust
#[cfg(test)]
mod solve_tests
{
    use nurbslib::core::maths::on_solve_linear_system;
    use nurbslib::core::matrix::Matrix;
```
```rust
    #[test]
    fn test_solve_linear_system_simple() {
        // 2x2 ì‹œìŠ¤í…œ:
        // [ 2  1 ] [x] = [ 5 ]
        // [ 1  3 ] [y]   [ 7 ]
        // í•´: x=2, y=2
        let mut a = Matrix::with_dims(2, 2);
        *a.at_mut(0, 0) = 2.0;
        *a.at_mut(0, 1) = 1.0;
        *a.at_mut(1, 0) = 1.0;
        *a.at_mut(1, 1) = 3.0;

        let mut b = Matrix::with_dims(2, 1);
        *b.at_mut(0, 0) = 5.0;
        *b.at_mut(1, 0) = 7.0;

        let x = on_solve_linear_system(&a, &b).expect("solve failed");
        println!("{}", x.to_string());
        assert!((*x.at(0, 0) - 1.6).abs() < 1e-12);
        assert!((*x.at(1, 0) - 1.8).abs() < 1e-12);

        let mut ax = Matrix::new();
        assert!(ax.multiply(&a, &x));
        assert!((*ax.at(0, 0) - *b.at(0, 0)).abs() < 1e-12);
        assert!((*ax.at(1, 0) - *b.at(1, 0)).abs() < 1e-12);
    }
```
```rust
    #[test]
    fn test_solve_linear_system_multi_rhs() {
        // 2x2, ë‘ ê°œì˜ RHS ì—´
        // A = [[1,2],[3,4]]
        // B = [[5,6],[7,8]]
        // X = A^{-1} B
        let mut a = Matrix::with_dims(2, 2);
        *a.at_mut(0, 0) = 1.0;
        *a.at_mut(0, 1) = 2.0;
        *a.at_mut(1, 0) = 3.0;
        *a.at_mut(1, 1) = 4.0;

        let mut b = Matrix::with_dims(2, 2);
        *b.at_mut(0, 0) = 5.0;
        *b.at_mut(0, 1) = 6.0;
        *b.at_mut(1, 0) = 7.0;
        *b.at_mut(1, 1) = 8.0;

        let x = on_solve_linear_system(&a, &b).expect("solve failed");

        // ì •ë‹µì€ A^{-1}B = [[-1, -2],[ 2,  3]]
        assert!((*x.at(0, 0) + 3.0).abs() < 1e-12);
        assert!((*x.at(1, 0) - 4.0).abs() < 1e-12);
        assert!((*x.at(0, 1) + 4.0).abs() < 1e-12);
        assert!((*x.at(1, 1) - 5.0).abs() < 1e-12);
    }
}
```
```rust
#[cfg(test)]
mod math2_tests {
    use nurbslib::core::maths::{on_closest_points_of_3d_lines, on_insert_value_into_sorted_array_option, on_intersect_3d_lines_option};
    use nurbslib::core::prelude::Vector;
```
```rust
    #[test]
    fn test_intersect_3d_lines_min_distance() {
        let p1 = Vector {
            x: 0.0,
            y: 0.0,
            z: 0.0,
        };
        let d1 = Vector {
            x: 1.0,
            y: 0.0,
            z: 0.0,
        };
        let p2 = Vector {
            x: 0.0,
            y: 1.0,
            z: 1.0,
        };
        let d2 = Vector {
            x: 0.0,
            y: -1.0,
            z: 0.0,
        };

        let (s, t, ip) = on_intersect_3d_lines_option(p1, d1, p2, d2).expect("should work");
        let q = p2 + d2.scale(t);

        // ì„œë¡œ ê°™ì€ ì ì´ ì•„ë‹ˆë¼, ìµœê·¼ì ‘ â€˜ë‘ ì â€™ì´ì–´ì•¼ í•¨
        assert!((s - 0.0).abs() < 1e-12);
        assert!((t - 1.0).abs() < 1e-12);

        // ip = p1 + s d1, q = p2 + t d2
        assert!(
            (ip.x - 0.0).abs() < 1e-12 && (ip.y - 0.0).abs() < 1e-12 && (ip.z - 0.0).abs() < 1e-12
        );
        assert!(
            (q.x - 0.0).abs() < 1e-12 && (q.y - 0.0).abs() < 1e-12 && (q.z - 1.0).abs() < 1e-12
        );

        // ìµœì†Œê±°ë¦¬ ë²¡í„°ëŠ” ë‘ ë°©í–¥ì— ìˆ˜ì§
        let m = Vector {
            x: q.x - ip.x,
            y: q.y - ip.y,
            z: q.z - ip.z,
        };
        assert!(m.dot(&d1).abs() < 1e-12);
        assert!(m.dot(&d2).abs() < 1e-12);

        // ê±°ë¦¬ 1
        assert!((m.length() - 1.0).abs() < 1e-12);
    }
```
```rust
    #[test]
    fn test_insert_value_into_sorted_array() {
        let v = vec![0.0, 0.5, 1.0];
        let out = on_insert_value_into_sorted_array_option(v.clone(), 0.75).unwrap();
        assert_eq!(out, vec![0.0, 0.5, 0.75, 1.0]);

        assert!(on_insert_value_into_sorted_array_option(v.clone(), -0.1).is_none());
        assert!(on_insert_value_into_sorted_array_option(v.clone(), 1.1).is_none());
    }
```
```rust
    #[test]
    fn test_min_distance_skew_lines() {
        let p1 = Vector {
            x: 0.0,
            y: 0.0,
            z: 0.0,
        };
        let d1 = Vector {
            x: 1.0,
            y: 0.0,
            z: 0.0,
        };
        let p2 = Vector {
            x: 0.0,
            y: 1.0,
            z: 1.0,
        };
        let d2 = Vector {
            x: 0.0,
            y: -1.0,
            z: 0.0,
        };

        let (s, t, ip, qp) = on_closest_points_of_3d_lines(p1, d1, p2, d2).expect("ok");
        // ìˆ˜ì§ì„± ê²€ì‚¬
        let r = ip - qp;
        assert!(r.dot(&d1).abs() < 1e-12);
        assert!(r.dot(&d2).abs() < 1e-12);
        // ipëŠ” ì²«ë²ˆì§¸ ì§ì„  ìœ„, qpëŠ” ë‘ë²ˆì§¸ ì§ì„  ìœ„
        assert!((ip - (p1 + d1.scale(s))).length() < 1e-12);
        assert!((qp - (p2 + d2.scale(t))).length() < 1e-12);
        // ê±°ë¦¬ ì–‘ìˆ˜
        assert!(r.length() > 0.0);
    }
}
```
```rust
#[cfg(test)]
mod unitized_derivative_tests {
    use nurbslib::core::prelude::Vector;

    #[inline]
    fn approx(a: f64, b: f64, tol: f64) -> bool {
        (a - b).abs() <= tol
    }

    #[inline]
    fn approx_vec(a: Vector, b: Vector, tol: f64) -> bool {
        (a.x - b.x).abs() <= tol && (a.y - b.y).abs() <= tol && (a.z - b.z).abs() <= tol
    }

    #[inline]
    fn normalize(v: Vector) -> Vector {
        let mut u = v;
        let _ = u.normalize();
        u
    }
```
```rust
    /// ìˆ˜ì¹˜ë¯¸ë¶„ìœ¼ë¡œ ê²€ì¦:
    /// v(t) = v + t*v1,  u(t) = normalize(v(t))
    /// u'(0) â‰ˆ [u(h) - u(-h)]/(2h)
    #[test]
    fn test_matches_numeric_derivative() {
        let cases = [
            (Vector::new(1.0, 2.0, 3.0), Vector::new(-4.0, 5.0, -6.0)),
            (Vector::new(-2.0, 0.5, 7.0), Vector::new(3.0, -1.0, 0.0)),
            (Vector::new(0.3, -1.7, 2.2), Vector::new(-0.9, 0.4, 1.1)),
            (Vector::new(10.0, 0.0, 0.0), Vector::new(0.0, 1.0, 0.0)),
        ];

        let h = 1e-7;

        for (v, v1) in cases {
            // í•¨ìˆ˜ ê²°ê³¼
            let du = Vector::unitized_derivative(&v, &v1);

            // ìˆ˜ì¹˜ë¯¸ë¶„
            let up = normalize(v + v1 * h);
            let um = normalize(v + v1 * -h);
            let du_num = (up - um) * (0.5 / h);

            assert!(
                approx_vec(du, du_num, 5e-6),
                "du={:?}, du_num={:?}",
                du,
                du_num
            );
        }
    }
```
```rust
    /// u = v/|v|ì´ë©´ uÂ·u = 1 â‡’ (uÂ·u)' = 0 â‡’ u'ëŠ” uì— ìˆ˜ì§ì´ì–´ì•¼ í•œë‹¤.
    #[test]
    fn test_derivative_is_orthogonal_to_u() {
        let cases = [
            (Vector::new(1.0, 2.0, 3.0), Vector::new(-4.0, 5.0, -6.0)),
            (Vector::new(3.0, -4.0, 0.0), Vector::new(1.0, 1.0, 0.0)),
            (Vector::new(0.5, 0.0, 4.0), Vector::new(0.0, -2.0, 1.0)),
        ];
        for (v, v1) in cases {
            let u = normalize(v);
            let du = Vector::unitized_derivative(&v, &v1);
            let dot = Vector::dot(&u, &du);
            assert!(approx(dot, 0.0, 1e-8), "uÂ·u' = {} (should be ~0)", dot);
        }
    }
```
```rust
    /// v'ê°€ vì™€ í‰í–‰ì´ë©´ ë°©í–¥ì€ ë³€í•˜ì§€ ì•ŠëŠ”ë‹¤ â‡’ u' = 0
    #[test]
    fn test_parallel_change_gives_zero() {
        let v = Vector::new(1.2, -3.4, 5.6);
        let alpha = 7.8;
        let v1 = v * alpha; // v' âˆ¥ v
        let du = Vector::unitized_derivative(&v, &v1);
        assert!(
            approx_vec(du, Vector::new(0.0, 0.0, 0.0), 1e-10),
            "du={:?}",
            du
        );
    }
```
```rust
    /// ìŠ¤ì¼€ì¼ ë¶ˆë³€ì„±: (v, v')ì— ê°™ì€ ìŠ¤ì¼€ì¼ kë¥¼ ê³±í•´ë„ u(t)ëŠ” ë™ì¼ â‡’ u'ë„ ë™ì¼
    #[test]
    fn test_scale_invariance() {
        let v = Vector::new(2.0, 1.0, -3.0);
        let v1 = Vector::new(0.5, -1.0, 4.0);
        let k = 13.7;

        let du = Vector::unitized_derivative(&v, &v1);
        let du2 = Vector::unitized_derivative(&(v * k), &(v1 * k));

        assert!(approx_vec(du, du2, 1e-10), "du={:?}, du2={:?}", du, du2);
    }
```
```rust
    /// ì•„ì£¼ ì‘ì€ |v|ì—ì„œëŠ” ê°€ë“œì— ì˜í•´ 0 ë°˜í™˜
    #[test]
    fn test_zero_guard_for_tiny_v() {
        let tiny = Vector::new(1e-14, -2e-14, 3e-14);
        let v1 = Vector::new(1.0, 0.0, 0.0);
        let du = Vector::unitized_derivative(&tiny, &v1);
        assert!(
            approx_vec(du, Vector::new(0.0, 0.0, 0.0), 0.0),
            "du={:?}",
            du
        );
    }
```
```rust
    /// ê°„ë‹¨í•œ ìˆ˜ë™ ê²€ì‚° ì¼€ì´ìŠ¤ (ì¶• ê¸°ì¤€)
    /// v=(1,0,0), v'=(0,1,0): |v|=1, v'Â·v=0 â‡’ u' = v'/|v| = (0,1,0)
    #[test]
    fn test_axis_case() {
        let v = Vector::new(1.0, 0.0, 0.0);
        let v1 = Vector::new(0.0, 1.0, 0.0);
        let du = Vector::unitized_derivative(&v, &v1);
        assert!(
            approx_vec(du, Vector::new(0.0, 1.0, 0.0), 1e-12),
            "du={:?}",
            du
        );
    }
}
```
```rust
mod calc_tests {

    use std::f64::consts::PI;
    use nurbslib::core::maths::{on_calculate_arc_segments, on_integrate_simpson_simple, on_polynomial_f_df};

    // ---- Arc segmentation ---------------------------------------------------
    #[test]
    fn test_calculate_arc_segments() {
        let r = 10.0;
        let arc_len = 10.0 * PI; // ë°˜ë°”í€´
        let chord = 1.0;
        let (n, seg_arc) = on_calculate_arc_segments(r, arc_len, chord);
        assert!(n >= 2);
        // ë¶„í• ëœ í˜¸ ê¸¸ì´ë“¤ì˜ í•©ì´ ì „ì²´ í˜¸ ê¸¸ì´ì™€ ë§ì•„ì•¼ í•¨
        let recon = seg_arc * (n as f64);
        assert!((recon - arc_len).abs() < 1e-9 * arc_len.abs());
    }
```
```rust
    // ---- Simpson integration -------------------------------------------------
    #[test]
    fn test_integrate_simpson_sin() {
        // âˆ«_0^Ï€ sin(x) dx = 2
        let val = on_integrate_simpson_simple(|x| x.sin(), 0.0, PI, 1e-10);
        assert!((val - 2.0).abs() < 1e-8);
    }
```
```rust
    #[test]
    fn test_integrate_simpson_poly() {
        // âˆ«_0^3 (3x^2 + 2x + 1) dx = [x^3 + x^2 + x]_0^3 = 27 + 9 + 3 = 39
        let val = on_integrate_simpson_simple(|x| 3.0 * x * x + 2.0 * x + 1.0, 0.0, 3.0, 1e-12);
        assert!((val - 39.0).abs() < 1e-9);
    }
```
```rust
    // ---- Polynomial f & df ---------------------------------------------------
    #[test]
    fn test_polynomial_f_df_basic() {
        // f(u) = -6 + 1*u + 1*u^2 = u^2 + u - 6
        let a = [-6.0, 1.0, 1.0]; // ascending ì €ì¥(ìƒìˆ˜, 1ì°¨, 2ì°¨)
        let (f2, df2) = on_polynomial_f_df(&a, 2.0, true);
        // f(2)=0, f'(u)=2u+1 => f'(2)=5
        assert!(f2.abs() < 1e-12);
        assert!((df2 - 5.0).abs() < 1e-12);
    }
}
```
```rust
#[cfg(test)]
mod integrate_tests {
    use std::f64::consts::PI;
    use nurbslib::core::maths::{on_calculate_arc_segments, on_integrate_simpson_simple};

    fn test_calculate_arc_segments() {
        let r = 10.0;
        let arc_len = 10.0 * PI; // ë°˜ë°”í€´
        let chord = 1.0;
        let (n, seg_arc) = on_calculate_arc_segments(r, arc_len, chord);
        assert!(n >= 2);
        // ë¶„í• ëœ í˜¸ ê¸¸ì´ë“¤ì˜ í•©ì´ ì „ì²´ í˜¸ ê¸¸ì´ì™€ ë§ì•„ì•¼ í•¨
        let recon = seg_arc * (n as f64);
        assert!((recon - arc_len).abs() < 1e-9 * arc_len.abs());
    }
```
```rust
    // ---- Simpson integration -------------------------------------------------
    #[test]
    fn test_integrate_simpson_sin() {
        // âˆ«_0^Ï€ sin(x) dx = 2
        let val = on_integrate_simpson_simple(|x| x.sin(), 0.0, PI, 1e-10);
        assert!((val - 2.0).abs() < 1e-8);
    }
```
```rust
    #[test]
    fn test_integrate_simpson_poly() {
        // âˆ«_0^3 (3x^2 + 2x + 1) dx = [x^3 + x^2 + x]_0^3 = 27 + 9 + 3 = 39
        let val = on_integrate_simpson_simple(|x| 3.0 * x * x + 2.0 * x + 1.0, 0.0, 3.0, 1e-12);
        assert!((val - 39.0).abs() < 1e-9);
    }
}
```
```rust
#[cfg(test)]
mod geometric_tests {
    use nurbslib::core::maths::{on_closest_points_of_3d_lines, on_integrate_simpson_simple, on_intersect_3d_lines_option, on_polynomial_f_df, on_solve_linear_system_vec};
    use nurbslib::core::matrix::Matrix;
    use nurbslib::core::prelude::Vector;
```
```rust
    #[test]
    fn test_solve_linear_system_vec() {
        let mut a = Matrix::from_vec2(&vec![
            vec![2.0, 1.0],
            vec![5.0, 7.0],
        ]);
        let mut b = vec![11.0, 13.0];
        let success = on_solve_linear_system_vec(&mut a, &mut b);
        assert!(success);
        println!("b{:?}", b);
        assert!((b[0] - 64.0 / 9.0).abs() < 1e-6);
        assert!((b[1] + 29.0 / 9.0).abs() < 1e-6);
    }
```
```rust
    #[test]
    fn test_on_intersect_3d_lines_option() {
        let p1 = Vector::new(0.0, 0.0, 0.0);
        let d1 = Vector::new(1.0, 0.0, 0.0);
        let p2 = Vector::new(0.0, 1.0, 0.0);
        let d2 = Vector::new(0.0, -1.0, 0.0);

        let result = on_intersect_3d_lines_option(p1, d1, p2, d2);
        assert!(result.is_some());
        let (_, _, ip) = result.unwrap();
        assert!((ip.x - 0.0).abs() < 1e-6);
        assert!((ip.y - 0.0).abs() < 1e-6);
    }
```
```rust
    #[test]
    fn test_closest_points_of_3d_lines() {
        let p1 = Vector::new(0.0, 0.0, 0.0);
        let d1 = Vector::new(1.0, 0.0, 0.0);
        let p2 = Vector::new(0.0, 1.0, 0.0);
        let d2 = Vector::new(0.0, 0.0, 1.0);

        let result = on_closest_points_of_3d_lines(p1, d1, p2, d2);
        assert!(result.is_ok());
        let (_, _, ps, qt) = result.unwrap();
        assert!((ps - qt).length() - 1.0 < 1e-6);
    }
```
```rust
    #[test]
    fn test_unitized_derivative() {
        let v = Vector::new(1.0, 0.0, 0.0);
        let v1 = Vector::new(0.0, 1.0, 0.0);
        let result = Vector::unitized_derivative(&v, &v1);
        assert!(result.length() > 0.0);
    }
```
```rust
    #[test]
    fn test_on_integrate_simpson_simple() {
        let result = on_integrate_simpson_simple(|x| x * x, 0.0, 1.0, 1e-6);
        assert!((result - 1.0 / 3.0).abs() < 1e-6);
    }
```
```rust
    #[test]
    fn test_on_polynomial_f_df() {
        let coeffs = vec![1.0, 2.0, 3.0]; // f(u) = 1 + 2u + 3u^2
        let (f, df) = on_polynomial_f_df(&coeffs, 1.0, true);
        assert!((f - 6.0).abs() < 1e-6);   // 1 + 2 + 3 = 6
        assert!((df - 8.0).abs() < 1e-6);  // f'(1) = 2 + 6 = 8
    }
}
```

---
