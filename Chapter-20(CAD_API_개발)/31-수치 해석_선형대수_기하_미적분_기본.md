# ìˆ˜ì¹˜ í•´ì„ ì„ í˜•ëŒ€ìˆ˜, ê¸°í•˜, ë¯¸ì ë¶„ ê¸°ë³¸

ì•„ë˜ëŠ” ì£¼ì–´ì§„ í•¨ìˆ˜ë“¤ì˜ ìˆ˜í•™ì  ì˜ë¯¸ë¥¼ ìˆ˜ì‹ê³¼ í•¨ê»˜ ì„¤ëª…í•˜ê³ , ê¸°ëŠ¥ë³„ë¡œ ì •ë¦¬í•œ í‘œë„ í•¨ê»˜ ì œê³µí•©ë‹ˆë‹¤.  
ì´ í•¨ìˆ˜ë“¤ì€ ì„ í˜•ëŒ€ìˆ˜, ê¸°í•˜, ë¯¸ì ë¶„, ìˆ˜ì¹˜í•´ì„ì˜ í•µì‹¬ ì•Œê³ ë¦¬ì¦˜ì„ êµ¬í˜„í•œ ê³ ê¸‰ ìˆ˜í•™ ë„êµ¬ì…ë‹ˆë‹¤.

##  ìˆ˜í•™ì  ì„¤ëª… ìš”ì•½
### 1. ì„ í˜• ì‹œìŠ¤í…œ í•´ë²• (LU ë¶„í•´ ê¸°ë°˜)
- ë¬¸ì œ: $AX=B$
- í•´ë²•: $A=LU$ ë¡œ ë¶„í•´ í›„,
- $LY=B$ (ì „ì§„ ëŒ€ì…)
- $UX=Y$ (í›„ì§„ ëŒ€ì…)

$$
X=U^{-1}L^{-1}B
$$

### 2. 3D ì§ì„  êµì°¨ì  ë° ìµœì†Œ ê±°ë¦¬
- ë‘ ì§ì„ :

$$
L_1(s)=p_1+s\cdot d_1,
L_2(t)=p_2+t\cdot d_2
$$

- êµì°¨ì  ì¡°ê±´:

$$
\mathrm{minimize\  }\| (p_1+sd_1)-(p_2+td_2)\| ^2
$$

- í•´ë²•:

$$
a=dâ‚Â·dâ‚, b=dâ‚Â·dâ‚‚, c=dâ‚‚Â·dâ‚‚
$$

$$
e=dâ‚Â·(pâ‚‚âˆ’pâ‚), f=dâ‚‚Â·(pâ‚‚âˆ’pâ‚)
$$

$$
D=acâˆ’bÂ²
$$

$$
s=(ecâˆ’fb)/D, t=(ebâˆ’fa)/D
$$

### 3. ë‹¨ìœ„ ë²¡í„° ë„í•¨ìˆ˜
- ë¬¸ì œ:

$$
\frac{d}{dt}\left( \frac{\vec {v}}{|\vec {v}|}\right) 
$$

- í•´ë²•:

$$
\left( \frac{\vec {v}}{|\vec {v}|}\right) '=\frac{\vec {v}'\cdot |\vec {v}|-\vec {v}\cdot (\vec {v}'\cdot \vec {v})/|\vec {v}|}{\vec {v}\cdot \vec {v}}
$$


### 4. ì ì‘í˜• ì‹¬í”„ìŠ¨ ì ë¶„
- ê¸°ë³¸ ì‹¬í”„ìŠ¨ ê³µì‹:

$$
\int _a^bf(x)\, dx\approx \frac{b-a}{6}\left[ f(a)+4f\left( \frac{a+b}{2}\right) +f(b)\right]
$$ 

- ì ì‘í˜•:
ë°˜ë³µì ìœ¼ë¡œ ì¤‘ê°„ì ì„ ì¶”ê°€í•˜ë©° ì˜¤ì°¨ê°€ ê¸°ì¤€ ì´í•˜ê°€ ë  ë•Œê¹Œì§€ ë°˜ë³µ

5. ë‹¤í•­ì‹ ë° ë„í•¨ìˆ˜ (Horner ë°©ì‹)
- ë‹¤í•­ì‹:

$$
f(u)=a_0+a_1u+a_2u^2+\dots +a_nu^n
$$

- ë„í•¨ìˆ˜:

$$
f'(u)=a_1+2a_2u+3a_3u^2+\dots +na_nu^{n-1}
$$

- Horner ë°©ì‹:

$$
f(u)=(((a_nu+a_{n-1})u+\dots )u+a_0)
$$

## ğŸ“Š ê¸°ëŠ¥ë³„ ì •ë¦¬ í‘œ

| í•¨ìˆ˜ ì´ë¦„                    | ê¸°ëŠ¥ ìš”ì•½         | ìˆ˜í•™ì  í•µì‹¬ ë˜ëŠ” ìˆ˜ì‹ ìš”ì•½                                 |
|-----------------------------|-------------------|------------------------------------------------------------|
| `solve_linear_system`       | AX = B í•´ë²•       | $A = LU \Rightarrow LY = B, UX = Y \Rightarrow X$     |
| `solve_linear_system_vec`   | Ax = b í•´ë²•       | LU ë¶„í•´ + ì „ì§„/í›„ì§„ ëŒ€ì…                                   |
| `on_intersect_3d_lines_option` | 3D ì§ì„  êµì°¨ì    | $s, t$ ê³„ì‚° â†’ $p_1 + s d_1 = p_2 + t d_2$          |
| `closest_points_of_3d_lines` | 3D ì§ì„  ìµœì†Œ ê±°ë¦¬ | $P(s), Q(t)$ â†’ ë‘ ì§ì„ ì˜ ìµœê·¼ì ‘ì                       |
| `unitized_derivative`       | ë‹¨ìœ„ ë²¡í„° ë„í•¨ìˆ˜  | $\left( \frac{\vec{v}}{|\vec{v}|} \right)'$            |
| `on_integrate_simpson`      | ìˆ˜ì¹˜ ì ë¶„         | $\int_a^b f(x)\,dx \approx \frac{b-a}{6}[f(a)+4f(m)+f(b)]$ |
| `on_polynomial_f_df`        | ë‹¤í•­ì‹ ë° ë„í•¨ìˆ˜  | $f(u), f'(u)$ â†’ Horner ë°©ì‹ìœ¼ë¡œ ê³„ì‚°                   |


---


## ì†ŒìŠ¤ ì½”ë“œ

```rust
/// ì™¸ë¶€ API: AX=B -> X
pub fn solve_linear_system(a: &Matrix, b: &Matrix) -> Result<Matrix, &'static str> {
    if a.row_count() != a.col_count() {
        return Err("square A required");
    }
    if a.col_count() != b.row_count() {
        return Err("A cols must equal B rows");
    }

    let mut alu = a.clone();
    let piv = on_mat_lu_decompose_partial(&mut alu)?;
    lu_solve(&alu, &piv, b)
}
```
```rust
pub fn solve_linear_system_vec(a: &mut Matrix, b: &mut [f64]) -> bool {
    let n = a.row_count();
    if a.col_count() != n || b.len() != n {
        return false;
    }

    // LU ë¶„í•´ (ë¶€ë¶„ í”¼ë²—, Doolittle). í–‰ ìŠ¤ì™‘ ì‹œ bë„ ê°™ì´ ìŠ¤ì™‘.
    for k in 0..n {
        // pivot row ì°¾ê¸° (|a[p,k]| ìµœëŒ€)
        let mut piv = k;
        let mut max_abs = a.at(k as i32, k as i32).abs();
        for i in (k + 1)..n {
            let v = a.at(i as i32, k as i32).abs();
            if v > max_abs {
                max_abs = v;
                piv = i;
            }
        }
        // pivot ì´ ë„ˆë¬´ ì‘ìœ¼ë©´ ì‹¤íŒ¨
        if max_abs <= 1e-30 {
            return false;
        }

        // í–‰ ìŠ¤ì™‘ (A, b ë™ì‹œ)
        if piv != k {
            for j in 0..n {
                let v_p = { *a.at(piv as i32, j as i32) };
                let v_k = { *a.at(k as i32, j as i32) };
                *a.at_mut(piv as i32, j as i32) = v_k;
                *a.at_mut(k as i32, j as i32) = v_p;
            }
            b.swap(piv, k);
        }
        // ì•„ë˜ ì‚¼ê° (L) ê°±ì‹  + trailing ìƒì‚¼ê°(U) ì—…ë°ì´íŠ¸
        let akk = a.at(k as i32, k as i32);
        if akk.abs() <= 1e-30 {
            return false;
        }

        let akk = { *a.at(k as i32, k as i32) };

        for i in (k + 1)..n {
            // A[i,k]ë„ ê°’ìœ¼ë¡œ ë³µì‚¬
            let aik = { *a.at(i as i32, k as i32) };
            let lik = aik / akk;

            // ì°¸ì¡°ê°€ ëª¨ë‘ ë“œë¡­ëœ ë’¤ì— ì“´ë‹¤
            {
                *a.at_mut(i as i32, k as i32) = lik;
            }

            // A(i, j) -= L(i,k) * U(k, j)  (j >= k+1)
            for j in (k + 1)..n {
                // ì½ê¸°ëŠ” ì „ë¶€ ê°’ ë³µì‚¬ë¡œ
                let aij = { *a.at(i as i32, j as i32) };
                let ukj = { *a.at(k as i32, j as i32) };
                let new_val = aij - lik * ukj;
                // ì“°ê¸°ëŠ” ë³„ë„ ë¸”ë¡ì—ì„œ
                {
                    *a.at_mut(i as i32, j as i32) = new_val;
                }
            }
        }
    }

    // ì „ì§„ ëŒ€ì…: L y = b  (Lì˜ ëŒ€ê°ì€ 1ë¡œ ê°€ì •)
    for i in 0..n {
        let mut s = b[i];
        for j in 0..i {
            s -= a.at(i as i32, j as i32) * b[j];
        }
        b[i] = s; // y ì €ì¥(ê·¸ëŒ€ë¡œ bì—)
    }

    // í›„ì§„ ëŒ€ì…: U x = y
    for i in (0..n).rev() {
        let mut s = b[i];
        for j in (i + 1)..n {
            s -= a.at(i as i32, j as i32) * b[j];
        }
        let uii = a.at(i as i32, i as i32);
        if uii.abs() <= 1e-30 {
            return false;
        }
        b[i] = s / uii;
    }

    true
}
```
```rust
pub fn on_intersect_3d_lines_option(
    p1: Vector,
    d1: Vector,
    p2: Vector,
    d2: Vector,
) -> Option<(f64, f64, Vector)> {
    let a = d1.dot(&d1);
    let b = d1.dot(&d2);
    let c = d2.dot(&d2);
    let delta = p2 - p1;
    let e = d1.dot(&delta);
    let f = d2.dot(&delta);
    let denom = a * c - b * b;
    if denom.abs() <= 1e-15 * a.max(1.0) {
        return None;
    }
    let s = (e * c - f * b) / denom;
    let t = (e * b - f * a) / denom;
    let ip = p1 + d1.scale(s);
    Some((s, t, ip))
}
```
```rust
pub fn closest_points_of_3d_lines(
    p1: Vector,
    d1: Vector,
    p2: Vector,
    d2: Vector,
) -> Result<(f64, f64, Vector, Vector), &'static str> {
    let a = d1.dot(&d1);
    let b = d1.dot(&d2);
    let c = d2.dot(&d2);
    let w0 = p1 - p2;
    let d = d1.dot(&w0);
    let e = d2.dot(&w0);

    let denom = a * c - b * b;
    if denom.abs() < 1e-30 {
        return Err("parallel or nearly parallel");
    }
    let s = (b * e - c * d) / denom;
    let t = (a * e - b * d) / denom;

    let ps = p1 + d1.scale(s);
    let qt = p2 + d2.scale(t);
    Ok((s, t, ps, qt))
}
```
```rust
pub fn unitized_derivative(v: &Self, v1: &Self) -> Self {
    // (v/|v|)' = ( v' * |v| - v * (v'Â·v)/|v| ) / (vÂ·v)
    let vv = v.length_squared();
    if vv <= Real::EPSILON {
        return Self {
            x: 0.0,
            y: 0.0,
            z: 0.0,
        };
    }
    let s = vv.sqrt();
    let v1_dot_v = Self::dot_vec(&v1, &v);
    // ì›ë¬¸ ì½”ë“œì— ìˆë˜ ì˜¤ë¥˜ ì£¼ì˜: v'Â·v ê°€ ì•„ë‹ˆë¼ v1Â·v
    let numer =
        Self::scale(v1, s) -
        &Self::scale(v, v1_dot_v / s);
    numer / vv
}
```
```rust
pub fn on_calculate_arc_segments(radius: f64, arc_length: f64, chord_length: f64) -> (usize, f64) {
    // Max segment angle = 2 * acos((R - c) / R)
    // Safeguards: zero, negative, or invalid values
    if radius <= 0.0 {
        return (2, arc_length / 2.0);
    }
    let mut ratio = (radius - chord_length) / radius;
    if ratio < -1.0 {
        ratio = -1.0;
    }
    if ratio > 1.0 {
        ratio = 1.0;
    }

    let max_seg_angle = 2.0 * ratio.acos();

    // As max_seg_angle approaches 0, a large number of segments is required.
    // If arc_length == 0, return 2.
    let n = if max_seg_angle > 0.0 {
        ((arc_length.abs() / max_seg_angle).ceil() as i64).max(2) as usize
    } else {
        2
    };
    (n, arc_length / (n as f64))
}
```
```rust
// on_integrate_simpson (ì ì‘í˜• Simpson, ëˆ„ì  ë°©ì‹)
pub fn on_integrate_simpson<F>(
    mut f: F,
    a: f64,
    b: f64,
    rel_tol: f64,
    max_levels: i32,
    eval_count_out: &mut i32,
    last_delta_out: &mut f64,
) -> f64
where
    F: FnMut(f64) -> f64,
{
    let mut simpson = 0.0_f64;
    let mut prev_simpson = 0.0_f64;
    let mut prev_mid_sum4 = 0.0_f64;
    let mut weighted_sum = 0.0_f64;
    *eval_count_out = 0;
    *last_delta_out = f64::INFINITY;

    for level in 0..=max_levels {
        if level == 0 {
            weighted_sum = f(a) + f(b);
            *eval_count_out = 2;

            // Initial T0 (reference)
            simpson = 0.5 * (b - a) * weighted_sum;
        } else {
            let mid_count = 1 << (level - 1);
            let mid_step = (b - a) / (mid_count as f64);
            let mut x = a + 0.5 * mid_step;
            let mut mid_sum = 0.0;
            for _ in 0..mid_count {
                mid_sum += f(x);
                x += mid_step;
            }
            *eval_count_out += mid_count as i32;

            let mid_sum4 = 4.0 * mid_sum;

            // Add 4 new midpoints and apply correction by subtracting half of the previous midpoint sum (-0.5 * prev_mid_sum4)
            weighted_sum += mid_sum4 - 0.5 * prev_mid_sum4;

            simpson = (b - a) * weighted_sum / ((1 << level) as f64 * 3.0);

            if level >= 5 {
                *last_delta_out = (simpson - prev_simpson).abs();
                if *last_delta_out <= rel_tol * prev_simpson.abs() {
                    return simpson;
                }
            }
            prev_mid_sum4 = mid_sum4;
            prev_simpson = simpson;
        }
    }
    simpson
}
```
```rust
pub fn on_integrate_simpson_simple<F>(f: F, a: f64, b: f64, rel_tol: f64) -> f64
where
    F: FnMut(f64) -> f64,
{
    let mut n = 0;
    let mut d = 0.0;
    on_integrate_simpson(f, a, b, rel_tol, 20, &mut n, &mut d)
}
```
```rust
// ------------------------------------------------------------
// Polynomial f(u) and its derivative f'(u) using Horner's method.
// `a` is the coefficient array.
// If `ascending = true`, the form is: a[0] + a[1] * u + ... + a[n] * u^n
// ------------------------------------------------------------
pub fn on_polynomial_f_df(a: &[f64], u: f64, ascending: bool) -> (f64, f64) {
    let n = a.len().wrapping_sub(1);
    if a.is_empty() {
        return (0.0, 0.0);
    }

    if ascending {
        // Reverse Horner (ascending order of coefficients)
        let mut f = a[n];
        let mut df = 0.0;
        for k in (0..n).rev() {
            df = df * u + f;
            f = f * u + a[k];
        }
        (f, df)
    } else {
        // Stored in descending order: a[0] + a[1] * u + ...
        let mut f = a[0];
        let mut df = 0.0;
        for k in 1..=n {
            df = df * u + f;
            f = f * u + a[k];
        }
        (f, df)
    }
}
```
