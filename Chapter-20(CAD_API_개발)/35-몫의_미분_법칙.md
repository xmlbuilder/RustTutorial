# ëª«ì˜ ë¯¸ë¶„ ë²•ì¹™

ì´ í•¨ìˆ˜ë“¤ì€ ê³ ì°¨ ë„í•¨ìˆ˜ ê³„ì‚°ì—ì„œ ìì£¼ ë“±ì¥í•˜ëŠ” **ëª«ì˜ ë¯¸ë¶„ ë²•ì¹™(Quotient Rule)** ì„ ë‹¤ë³€ìˆ˜ì— ëŒ€í•´ ì¼ë°˜í™”í•œ êµ¬í˜„ì…ë‹ˆë‹¤.  
íŠ¹íˆ ê³¡ë©´ì´ë‚˜ ê³¡ì„ ì˜ íŒŒë¼ë©”íŠ¸ë¦­ í‘œí˜„ì—ì„œ $F=\frac{X}{W}$ í˜•íƒœì˜ í•¨ìˆ˜ì— ëŒ€í•´ ë„í•¨ìˆ˜ë¥¼ ê³„ì‚°í•  ë•Œ ì‚¬ìš©ë©ë‹ˆë‹¤.  
ì•„ë˜ì— ê° í•¨ìˆ˜ì˜ ê¸°ëŠ¥, ìˆ˜ì‹, ë‹¨ê³„ë³„ ì„¤ëª…ì„ ì •ë¦¬.  

## ğŸ“˜ ì „ì²´ ê°œìš”
### ëª©ì 
- íŒŒë¼ë©”íŠ¸ë¦­ í•¨ìˆ˜ $F(s,t)=\frac{X(s,t)}{W(s,t)}$ ë˜ëŠ” $F(r,s,t)=\frac{X(r,s,t)}{W(r,s,t)}$ ì— ëŒ€í•´
- ê³ ì°¨ ë„í•¨ìˆ˜ $\partial ^nF/\partial s^i\partial t^j$ ë˜ëŠ” $\partial ^nF/\partial r^i\partial s^j\partial t^k$ ë¥¼ ê³„ì‚°
ì…ë ¥ êµ¬ì¡°
- v: ê° ë„í•¨ìˆ˜ ë¸”ë¡ì— ëŒ€í•´ $[X,Y,Z,...,W]$ í˜•íƒœë¡œ ì €ì¥ëœ ë°°ì—´
- v_stride: ê° ë¸”ë¡ì˜ í¬ê¸° (ì˜ˆ: dim + 1)
- dim: ê³µê°„ ì°¨ì› (ì˜ˆ: 3 â†’ X, Y, Z)
- der_count: ìµœëŒ€ ë¯¸ë¶„ ì°¨ìˆ˜

## ğŸ§® í•µì‹¬ ìˆ˜ì‹: ëª«ì˜ ë¯¸ë¶„ ë²•ì¹™
### 1ë³€ìˆ˜ ë²„ì „ (ê¸°ë³¸í˜•)

$$
F(u)=\frac{X(u)}{W(u)}\Rightarrow F'=\frac{X'}{W}-\frac{W'}{W}\cdot F
$$

### 2ë³€ìˆ˜ ë²„ì „

$$
F(s,t)=\frac{X(s,t)}{W(s,t)}
$$
- 1ì°¨ ë„í•¨ìˆ˜

$$
F_s=\frac{X_s}{W}-\frac{W_s}{W}\cdot F\\ \quad F_t=\frac{X_t}{W}-\frac{W_t}{W}\cdot F
$$
- 2ì°¨ ë„í•¨ìˆ˜

$$
F_{ss}=\frac{X_{ss}}{W}-2\frac{W_s}{W}F_s-\frac{W_{ss}}{W}F\\ \quad F_{st}=\frac{X_{st}}{W}-\frac{W_s}{W}F_t-\frac{W_t}{W}F_s-\frac{W_{st}}{W}F\\ \quad F_{tt}=\frac{X_{tt}}{W}-2\frac{W_t}{W}F_t-\frac{W_{tt}}{W}F
$$

- ê³ ì°¨ ì¼ë°˜ì‹


### 3ë³€ìˆ˜ ë²„ì „

$$
F(r,s,t)=\frac{X(r,s,t)}{W(r,s,t)}
$$

- 1ì°¨ ë„í•¨ìˆ˜


$$
F_r=\frac{X_r}{W}-\frac{W_r}{W}\cdot F\\ \quad F_s=\frac{X_s}{W}-\frac{W_s}{W}\cdot F\\ \quad F_t=\frac{X_t}{W}-\frac{W_t}{W}\cdot F
$$

- 2ì°¨ ë„í•¨ìˆ˜

$$
F_{rr}=\frac{X_{rr}}{W}-2\frac{W_r}{W}F_r-\frac{W_{rr}}{W}F\\ \quad F_{rs}=\frac{X_{rs}}{W}-\frac{W_r}{W}F_s-\frac{W_s}{W}F_r-\frac{W_{rs}}{W}F\\ \quad F_{rt}=\dots \quad F_{ss},F_{st},F_{tt}\mathrm{ë„\  ë™ì¼\  êµ¬ì¡°}
$$

- ê³ ì°¨ ì¼ë°˜ì‹


## ğŸ”§ í•¨ìˆ˜ë³„ ê¸°ëŠ¥ ì„¤ëª…
### ğŸ”¹ idx2(v_stride, i, j)
- 2ë³€ìˆ˜ íŒŒì…œ ë„í•¨ìˆ˜ ë¸”ë¡ì˜ ì¸ë±ìŠ¤ë¥¼ ê³„ì‚°
- ë¸”ë¡ ìˆœì„œëŠ” ì´ì°¨ìˆ˜ d=i+j ê¸°ì¤€ìœ¼ë¡œ ì‚¼ê°í˜• ë°°ì—´
- ìˆ˜ì‹:

$$
\mathrm{index}=\left( \frac{d(d+1)}{2}+j\right) \cdot v_{\mathrm{stride}}
$$

### ğŸ”¹ idx3(v_stride, i, j, k)
- 3ë³€ìˆ˜ íŒŒì…œ ë„í•¨ìˆ˜ ë¸”ë¡ì˜ ì¸ë±ìŠ¤ë¥¼ ê³„ì‚°
- ë¸”ë¡ ìˆœì„œëŠ” ì´ì°¨ìˆ˜ d=i+j+k ê¸°ì¤€ìœ¼ë¡œ 3ì°¨ì› í”¼ë¼ë¯¸ë“œ ë°°ì—´
- ìˆ˜ì‹:

$$
\mathrm{index}=v_{\mathrm{stride}}\cdot \left( \frac{d(d+1)(d+2)}{6}+\frac{(j+k)(j+k+1)}{2}+k\right)
$$


### ğŸ”¹ evaluate_quotient_rule2
- 2ë³€ìˆ˜ ëª« í•¨ìˆ˜ $F(s,t)=X/W$ ì— ëŒ€í•´ ê³ ì°¨ ë„í•¨ìˆ˜ ê³„ì‚°
- ë‹¨ê³„:
    - ëª¨ë“  ë¸”ë¡ì„ Wë¡œ ë‚˜ëˆ ì„œ X/Wë¡œ ë³€í™˜
    - 1ì°¨ ë„í•¨ìˆ˜ ê³„ì‚°: $F_s$ , $F_t$
    - 2ì°¨ ë„í•¨ìˆ˜ ê³„ì‚°: $F_{ss}$ , $F_{st}$ , $F_{tt}$
    - 3ì°¨ ì´ìƒ ë„í•¨ìˆ˜ëŠ” ì¼ë°˜ì‹ìœ¼ë¡œ ëˆ„ì  ê³„ì‚°

### ğŸ”¹ evaluate_quotient_rule3
- 3ë³€ìˆ˜ ëª« í•¨ìˆ˜ $F(r,s,t)=X/W$ ì— ëŒ€í•´ ê³ ì°¨ ë„í•¨ìˆ˜ ê³„ì‚°
- ë‹¨ê³„:
    - ëª¨ë“  ë¸”ë¡ì„ Wë¡œ ë‚˜ëˆ ì„œ $X/W$ ë¡œ ë³€í™˜
    - 1ì°¨ ë„í•¨ìˆ˜ ê³„ì‚°: $F_r$ , $F_s$ , $F_t$
    - 2ì°¨ ë„í•¨ìˆ˜ ê³„ì‚°: $F_{rr}$ , $F_{rs}$ , $F_{rt}$ , $F_{ss}$ , $F_{st}$ , $F_{tt}$
    - 3ì°¨ ì´ìƒ ë„í•¨ìˆ˜ëŠ” ì¼ë°˜ì‹ìœ¼ë¡œ ëˆ„ì  ê³„ì‚°

## ğŸ“Œ ìš”ì•½

| í•¨ìˆ˜ ì´ë¦„                  | ì ìš© ëŒ€ìƒ             | ê¸°ëŠ¥ ìš”ì•½ ë˜ëŠ” ìˆ˜ì‹ ì„¤ëª…                                                                 |
|---------------------------|-----------------------|------------------------------------------------------------------------------------------|
| `idx2`                    | 2ë³€ìˆ˜ ë„í•¨ìˆ˜ ì¸ë±ìŠ¤   | $\left( \frac{(i+j)(i+j+1)}{2} + j \right) \cdot v_s$                                |
| `idx3`                    | 3ë³€ìˆ˜ ë„í•¨ìˆ˜ ì¸ë±ìŠ¤   | $v_s \cdot \left( \frac{d(d+1)(d+2)}{6} + \frac{(j+k)(j+k+1)}{2} + k \right)$         |
| `evaluate_quotient_rule2` | $F(s,t) = X/W$     | 2ë³€ìˆ˜ ëª« í•¨ìˆ˜ì˜ ê³ ì°¨ ë„í•¨ìˆ˜ ê³„ì‚° (1ì°¨, 2ì°¨, nì°¨ ì¼ë°˜ì‹ í¬í•¨)                           |
| `evaluate_quotient_rule3` | $F(r,s,t) = X/W$   | 3ë³€ìˆ˜ ëª« í•¨ìˆ˜ì˜ ê³ ì°¨ ë„í•¨ìˆ˜ ê³„ì‚° (1ì°¨, 2ì°¨, nì°¨ ì¼ë°˜ì‹ í¬í•¨)                           |

---


# í…ŒìŠ¤íŠ¸ 

í…ŒìŠ¤íŠ¸ ì½”ë“œì—ì„œ í•µì‹¬ì´ ë˜ëŠ” ë‘ í•¨ìˆ˜:
- `quotient_rule2_matches_finite_difference_up_to_second_order`
- `quotient_rule3_matches_finite_difference_up_to_second_order`  
ì´ ë‘ í…ŒìŠ¤íŠ¸ì˜ ëª©ì ê³¼ ìˆ˜ì‹ ì ìš© ê³¼ì •ì„ ì•„ë˜ì— ìì„¸íˆ ì •ë¦¬.

## ğŸ¯ í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ë“¤ì˜ ëª©ì 
### 1. quotient_rule2_matches_finite_difference_up_to_second_order
- ëª©ì : 2ë³€ìˆ˜ í•¨ìˆ˜ $F(s,t)=\frac{X(s,t)}{W(s,t)}$ ì— ëŒ€í•´ evaluate_quotient_rule2 í•¨ìˆ˜ê°€ ê³„ì‚°í•œ ë„í•¨ìˆ˜ ê²°ê³¼ê°€ **ì¤‘ì•™ ìœ í•œì°¨ë¶„ë²•(finite difference)** ìœ¼ë¡œ ê³„ì‚°í•œ ìˆ˜ì¹˜ ë„í•¨ìˆ˜ì™€ ì¼ì¹˜í•˜ëŠ”ì§€ ê²€ì¦
- ê²€ì¦ ë²”ìœ„: 0ì°¨ (í•¨ìˆ˜ê°’), 1ì°¨ ($F_s$ , $F_t$ ), 2ì°¨ ( $F_{ss}$ , $F_{st}$ , $F_{tt}$ )

### 2. quotient_rule3_matches_finite_difference_up_to_second_order
- ëª©ì : 3ë³€ìˆ˜ í•¨ìˆ˜ $F(r,s,t)=\frac{X(r,s,t)}{W(r,s,t)}$ ì— ëŒ€í•´ `evaluate_quotient_rule3` í•¨ìˆ˜ê°€ ê³„ì‚°í•œ ë„í•¨ìˆ˜ ê²°ê³¼ê°€ ì¤‘ì•™ ìœ í•œì°¨ë¶„ë²•ê³¼ ì¼ì¹˜í•˜ëŠ”ì§€ ê²€ì¦
- ê²€ì¦ ë²”ìœ„: 0ì°¨, 1ì°¨ ($F_r$ , $F_s$, $F_t$ ), 2ì°¨ ($F_{rr}$ , $F_{rs}$ , $F_{rt}$ , $F_{ss}$ , $F_{st}$ , $F_{tt}$ )

## ğŸ§® ìˆ˜ì‹ ì ìš© ë‹¨ê³„ ìš”ì•½
ê³µí†µ êµ¬ì¡°: $F=\frac{X}{W}$
### 1. 0ì°¨ (í•¨ìˆ˜ê°’)

$$
F=\frac{X}{W}
$$

### 2. 1ì°¨ ë„í•¨ìˆ˜

$$
F_u=\frac{X_u}{W}-\frac{W_u}{W}\cdot F\quad \mathrm{(uëŠ”\  s,\  t\  ë˜ëŠ”\  r)}
$$

### 3. 2ì°¨ ë„í•¨ìˆ˜
ì˜ˆ: 2Dì˜ ê²½ìš°  

$$
F_{ss}=\frac{X_{ss}}{W}-2\frac{W_s}{W}F_s-\frac{W_{ss}}{W}F\\ \quad F_{st}=\frac{X_{st}}{W}-\frac{W_s}{W}F_t-\frac{W_t}{W}F_s-\frac{W_{st}}{W}F\\ \quad F_{tt}=\frac{X_{tt}}{W}-2\frac{W_t}{W}F_t-\frac{W_{tt}}{W}F
$$


## ğŸ§ª í…ŒìŠ¤íŠ¸ íë¦„ ìš”ì•½
### 1. í•´ì„ì  ë„í•¨ìˆ˜ ì±„ìš°ê¸°
- X2D, W2D, X3D, W3D êµ¬ì¡°ì²´ë¥¼ í†µí•´ ê° ë„í•¨ìˆ˜ ê°’ì„ ê³„ì‚°
- v ë°°ì—´ì— ì €ì¥: ê° ë¸”ë¡ì€ $[X, Y, ..., W]$ í˜•íƒœ
### 2. ëª« ë„í•¨ìˆ˜ ê³„ì‚° í˜¸ì¶œ
- on_evaluate_quotient_rule2(...) ë˜ëŠ” on_evaluate_quotient_rule3(...) í˜¸ì¶œ
- ë‚´ë¶€ì—ì„œ ëª«ì˜ ë¯¸ë¶„ ë²•ì¹™ì„ ì ìš©í•˜ì—¬ F=X/W ë° ë„í•¨ìˆ˜ë“¤ì„ ê³„ì‚°
### 3. ìˆ˜ì¹˜ ë„í•¨ìˆ˜ ê³„ì‚°
- fd2, fd3 í•¨ìˆ˜ë¡œ ì¤‘ì•™ ìœ í•œì°¨ë¶„ë²•ì„ ì‚¬ìš©í•´ ìˆ˜ì¹˜ ë„í•¨ìˆ˜ ê³„ì‚°
### 4. ë¹„êµ ë° ê²€ì¦
- approx_sliceë¡œ í•´ì„ ê²°ê³¼ì™€ ìˆ˜ì¹˜ ê²°ê³¼ë¥¼ ë¹„êµ
- ì˜¤ì°¨ í—ˆìš© ë²”ìœ„ ë‚´ì— ìˆìœ¼ë©´ í…ŒìŠ¤íŠ¸ í†µê³¼

## ğŸ“Œ ìš”ì•½ í‘œ

| í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ ì´ë¦„                                         | ëŒ€ìƒ í•¨ìˆ˜               | ê²€ì¦ ë„í•¨ìˆ˜ ëª©ë¡                                      | ëª©ì  ìš”ì•½                                  |
|----------------------------------------------------------|--------------------------|--------------------------------------------------------|---------------------------------------------|
| `quotient_rule2_matches_finite_difference_up_to_second_order` | `evaluate_quotient_rule2` | $F,\ F_s,\ F_t,\ F_{ss},\ F_{st},\ F_{tt}$         | 2ë³€ìˆ˜ ëª« í•¨ìˆ˜ì˜ í•´ì„ ë„í•¨ìˆ˜ vs ìˆ˜ì¹˜ ë„í•¨ìˆ˜ ë¹„êµ |
| `quotient_rule3_matches_finite_difference_up_to_second_order` | `evaluate_quotient_rule3` | $F,\ F_r,\ F_s,\ F_t,\ F_{rr},\ F_{rs},\dots$      | 3ë³€ìˆ˜ ëª« í•¨ìˆ˜ì˜ í•´ì„ ë„í•¨ìˆ˜ vs ìˆ˜ì¹˜ ë„í•¨ìˆ˜ ë¹„êµ |



## ğŸ¯ ì´ê±¸ ì™œ êµ¬í•˜ëŠ”ê°€?
### í•µì‹¬ ëª©ì :
ëª« í•¨ìˆ˜ $F=\frac{X}{W}$ ì˜ ê³ ì°¨ ë„í•¨ìˆ˜ ê³„ì‚°ì„ ì •í™•í•˜ê²Œ êµ¬í˜„í•˜ê³  ê²€ì¦í•˜ê¸° ìœ„í•´ì„œì…ë‹ˆë‹¤.

## ğŸ§© ì–´ë””ì— ì“°ì´ëŠ”ê°€?
### 1. ğŸ¨ NURBS ê³¡ì„ /ê³¡ë©´ì˜ ì •ë°€ í‰ê°€
- NURBSëŠ” $F(u)=\frac{X(u)}{W(u)}$ í˜•íƒœì˜ ëª« í•¨ìˆ˜ë¡œ ì •ì˜ë¨
- ê³¡ì„ ì˜ ì ‘ì„ , ë²•ì„ , ê³¡ë¥ , ë¹„í‹€ë¦¼ ë“±ì„ ê³„ì‚°í•˜ë ¤ë©´ ê³ ì°¨ ë„í•¨ìˆ˜ê°€ í•„ìš”í•¨
- ì˜ˆ: ìë™ì°¨ í‘œë©´, í•­ê³µê¸° ì™¸í˜•, ìºë¦­í„° ëª¨ë¸ë§

### 2. ğŸ§® ìˆ˜ì¹˜ í•´ì„ ë° ì‹œë®¬ë ˆì´ì…˜
- ìœ ì²´ì—­í•™, êµ¬ì¡°í•´ì„, ì „ìê¸° ì‹œë®¬ë ˆì´ì…˜ ë“±ì—ì„œ ê³ ì°¨ ë¯¸ë¶„ì´ í•„ìš”í•œ ê²½ìš°
- ì˜ˆ: ê³¡ë©´ ìœ„ì˜ ë¬¼ë¦¬ëŸ‰ ë³€í™”ìœ¨ ê³„ì‚° (ì†ë„, ì••ë ¥, ì‘ë ¥ ë“±)

### 3. ğŸ“ CAD ì»¤ë„ ë° í˜•ìƒ ìµœì í™”
- í˜•ìƒ ì„¤ê³„ ì¤‘ ê³¡ë©´ì˜ í’ˆì§ˆì„ í‰ê°€í•˜ê±°ë‚˜ ìë™ìœ¼ë¡œ ìµœì í™”í•  ë•Œ
- ì˜ˆ: ê³¡ë©´ì´ ë„ˆë¬´ ê¸‰ê²©í•˜ê²Œ íœ˜ì–´ì§€ëŠ” ì§€ì  ê°ì§€ â†’ ì„¤ê³„ ìˆ˜ì •

### 4. ğŸ§  ë¨¸ì‹ ëŸ¬ë‹ì—ì„œì˜ ê¸°í•˜ ì •ë³´ í™œìš©
- ê³¡ë©´ ìœ„ì˜ íŠ¹ì„±(ê³¡ë¥ , ì ‘ì„  ë“±)ì„ featureë¡œ ì‚¬ìš©
- ì˜ˆ: 3D ì¸ì‹, í¬ì¦ˆ ì¶”ì •, í˜•ìƒ ë¶„ë¥˜

### ğŸ§® ìˆ˜ì‹ì´ ì™œ ì¤‘ìš”í•œê°€?
- ëª«ì˜ ë¯¸ë¶„ì€ ë‹¨ìˆœí•œ ë„í•¨ìˆ˜ ê³„ì‚°ì´ ì•„ë‹ˆë¼, ê¸°í•˜ì  ì˜ë¯¸ë¥¼ ê°€ì§„ ì—°ì‚°ì…ë‹ˆë‹¤
- ì˜ˆ:

$$
F_s=\frac{X_s}{W}-\frac{W_s}{W}\cdot F
$$

- â†’ ì´ëŠ” ë‹¨ìˆœí•œ ë³€í™”ìœ¨ì´ ì•„ë‹ˆë¼, íˆ¬ì˜ëœ ì ‘ì„  ë°©í–¥ì„ ì˜ë¯¸í•¨

- âœ… í…ŒìŠ¤íŠ¸ì˜ ì—­í• - evaluate_quotient_rule2, evaluate_quotient_rule3 í•¨ìˆ˜ê°€ ì •í™•í•˜ê²Œ ë„í•¨ìˆ˜ë¥¼ ê³„ì‚°í•˜ëŠ”ì§€ í™•ì¸
    - ìˆ˜ì¹˜ ë¯¸ë¶„(finite difference)ê³¼ ë¹„êµí•˜ì—¬ ì˜¤ì°¨ë¥¼ ê²€ì¦
    - ì´ ê²€ì¦ì„ í†µê³¼í•´ì•¼ ì‹¤ì œ CAD ì»¤ë„ì´ë‚˜ ê·¸ë˜í”½ ì—”ì§„ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ



## âœ… ê²€ì¦ì€ ì–´ë–»ê²Œ ì´ë£¨ì–´ì¡ŒëŠ”ê°€?
### 1. ì¤‘ì•™ ìœ í•œì°¨ë¶„ë²• (Central Finite Difference Method)
- í…ŒìŠ¤íŠ¸ì—ì„œëŠ” í•´ì„ì ìœ¼ë¡œ ê³„ì‚°ëœ ë„í•¨ìˆ˜ ê²°ê³¼ë¥¼ ìˆ˜ì¹˜ì ìœ¼ë¡œ ê·¼ì‚¬í•œ ë„í•¨ìˆ˜ì™€ ë¹„êµí•©ë‹ˆë‹¤.
- ìˆ˜ì¹˜ ê·¼ì‚¬ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤:
- ì˜ˆ: 1ì°¨ ë„í•¨ìˆ˜ ê·¼ì‚¬

$$
F_s(s_0,t_0)\approx \frac{F(s_0+h,t_0)-F(s_0-h,t_0)}{2h}
$$

- ì˜ˆ: 2ì°¨ ë„í•¨ìˆ˜ ê·¼ì‚¬

$$
F_{ss}(s_0,t_0)\approx \frac{F(s_0+h,t_0)-2F(s_0,t_0)+F(s_0-h,t_0)}{h^2}
$$

- ì´ ë°©ì‹ì€ ì •í™•í•œ í•´ì„ ë„í•¨ìˆ˜ ì—†ì´ë„ ê·¼ì‚¬ê°’ì„ ì–»ì„ ìˆ˜ ìˆëŠ” ì•ˆì •ì ì¸ ë°©ë²•ì…ë‹ˆë‹¤.

### 2. í•´ì„ ë„í•¨ìˆ˜ì™€ ìˆ˜ì¹˜ ë„í•¨ìˆ˜ì˜ ë¹„êµ
- evaluate_quotient_rule2 ë˜ëŠ” evaluate_quotient_rule3 í•¨ìˆ˜ëŠ” í•´ì„ì ìœ¼ë¡œ ë„í•¨ìˆ˜ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
- fd2, fd3 í•¨ìˆ˜ëŠ” ìˆ˜ì¹˜ì ìœ¼ë¡œ ë„í•¨ìˆ˜ë¥¼ ê·¼ì‚¬í•©ë‹ˆë‹¤.
- ë‘ ê²°ê³¼ë¥¼ approx_slice í•¨ìˆ˜ë¥¼ í†µí•´ ë¹„êµí•©ë‹ˆë‹¤:

```rust
assert!(approx_slice(&fss, &second[0], atol, rtol));
```

- ì—¬ê¸°ì„œ atolì€ ì ˆëŒ€ ì˜¤ì°¨ í—ˆìš©ì¹˜, rtolì€ ìƒëŒ€ ì˜¤ì°¨ í—ˆìš©ì¹˜ì…ë‹ˆë‹¤.

## ğŸ“Œ ê²€ì¦ì˜ í•µì‹¬

| í•­ëª©                     | ì„¤ëª… ë˜ëŠ” ì—­í•                                       | ê´€ë ¨ í•¨ìˆ˜ ë˜ëŠ” ê¸°ë²•                   |
|--------------------------|-----------------------------------------------------|----------------------------------------|
| ë¹„êµ ëŒ€ìƒ                | í•´ì„ì  ë„í•¨ìˆ˜ vs ìˆ˜ì¹˜ ê·¼ì‚¬ ë„í•¨ìˆ˜                  | `evaluate_quotient_rule2/3` vs `fd2/fd3` |
| ìˆ˜ì¹˜ ê·¼ì‚¬ ë°©ì‹           | ì¤‘ì•™ ìœ í•œì°¨ë¶„ë²• (finite difference)                | `fd2`, `fd3`                            |
| ì˜¤ì°¨ í—ˆìš© ê¸°ì¤€           | ì ˆëŒ€ ì˜¤ì°¨ + ìƒëŒ€ ì˜¤ì°¨                              | `approx`, `approx_slice`               |
| ê²€ì¦ ìˆ˜í–‰ ë°©ì‹           | ê° ë„í•¨ìˆ˜ ì„±ë¶„ë³„ë¡œ ì˜¤ì°¨ ë¹„êµ                       | `assert!(approx_slice(...))`           |
| ê²€ì¦ ëŒ€ìƒ ë„í•¨ìˆ˜ ì¢…ë¥˜    | 0ì°¨, 1ì°¨, 2ì°¨ ë„í•¨ìˆ˜                               | $F,\ F_s,\ F_t,\ F_{ss},\dots$     |


## impl X2D

impl X2DëŠ” **ì¤‘ì•™ ìœ í•œì°¨ë¶„ë²•(Central Finite Difference)** ì„ í†µí•´ ìˆ˜ì¹˜ ë„í•¨ìˆ˜ë¥¼ ê³„ì‚°í•  ë•Œ **ê¸°ì¤€ í•¨ìˆ˜ X(s,t)** ì™€ ê·¸ í•´ì„ì  ë„í•¨ìˆ˜ë“¤ì„ ì œê³µí•˜ëŠ” ì—­í• ì„ í•©ë‹ˆë‹¤.

## ğŸ” impl X2Dì˜ ì—­í• 
### 1. í•¨ìˆ˜ ì •ì˜
```rust
fn val(s, t) â†’ [f64; 2]
```
- X(s,t)ì˜ ê°’ ë°˜í™˜

### 2. ë„í•¨ìˆ˜ ì •ì˜
- d_s(s, t) â†’ $\frac{\partial X}{\partial s}$
- d_t(s, t) â†’ $\frac{\partial X}{\partial t}$
- d_ss(s, t) â†’ $\frac{\partial ^2X}{\partial s^2}$
- d_st(s, t) â†’ $\frac{\partial ^2X}{\partial s\partial t}$
- d_tt(s, t) â†’ $\frac{\partial ^2X}{\partial t^2}$

#### ğŸ§ª ì¤‘ì•™ ì°¨ë¶„ë²•ì—ì„œì˜ ì‚¬ìš©
ì¤‘ì•™ ì°¨ë¶„ë²• í•¨ìˆ˜ fd2ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì‚¬ìš©ë©ë‹ˆë‹¤:
```
let f0 = f(s, t);
let fs â‰ˆ (f(s+h, t) - f(sâˆ’h, t)) / 2h;
let fss â‰ˆ (f(s+h, t) - 2f(s, t) + f(sâˆ’h, t)) / hÂ²;
```

#### ì—¬ê¸°ì„œ f(s, t)ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜ë©ë‹ˆë‹¤:
```rust
fn f2(s, t) {
    let x = X2D::val(s, t);
    let w = W2D::val(s, t);
    [x[0]/w, x[1]/w]
}
```
- ì¦‰, X2DëŠ” X(s,t)ë¥¼ ì •ì˜í•˜ê³ , f2ëŠ” $F(s,t)=\frac{X(s,t)}{W(s,t)}$ ë¥¼ êµ¬ì„±í•˜ì—¬ ì°¨ë¶„ë²•ì— ì‚¬ìš©ë©ë‹ˆë‹¤.


## 2. ë„í•¨ìˆ˜ ì •ì˜ (`impl X2D`)

| í•¨ìˆ˜ ì´ë¦„       | ìˆ˜ì‹ í‘œí˜„                                                              | ì˜ë¯¸ ë˜ëŠ” ë°©í–¥         |
|----------------|------------------------------------------------------------------------|------------------------|
| `d_s(s, t)`     | $\frac{\partial X}{\partial s} = [2s + 2t,\ 2]$                     | s ë°©í–¥ 1ì°¨ ë„í•¨ìˆ˜      |
| `d_t(s, t)`     | $\frac{\partial X}{\partial t} = [2s + 6t,\ -1]$                    | t ë°©í–¥ 1ì°¨ ë„í•¨ìˆ˜      |
| `d_ss(s, t)`    | $\frac{\partial^2 X}{\partial s^2} = [2,\ 0]$                       | s ë°©í–¥ 2ì°¨ ë„í•¨ìˆ˜      |
| `d_st(s, t)`    | $\frac{\partial^2 X}{\partial s \partial t} = [2,\ 0]$              | í˜¼í•© 2ì°¨ ë„í•¨ìˆ˜        |
| `d_tt(s, t)`    | $\frac{\partial^2 X}{\partial t^2} = [6,\ 0]$                       | t ë°©í–¥ 2ì°¨ ë„í•¨ìˆ˜      |


## ğŸ§ª ì¤‘ì•™ ì°¨ë¶„ë²• ê·¼ì‚¬ ìˆ˜ì‹

| ë„í•¨ìˆ˜ ì¢…ë¥˜   | ê·¼ì‚¬ ìˆ˜ì‹                                                                 |
|---------------|---------------------------------------------------------------------------|
| $F_s$     | $\frac{F(s+h, t) - F(s-h, t)}{2h}$                                    |
| $F_t$     | $\frac{F(s, t+h) - F(s, t-h)}{2h}$                                    |
| $F_{ss}$  | $\frac{F(s+h, t) - 2F(s, t) + F(s-h, t)}{h^2}$                         |
| $F_{tt}$  | $\frac{F(s, t+h) - 2F(s, t) + F(s, t-h)}{h^2}$                         |
| $F_{st}$  | $\frac{F(s+h, t+h) - F(s+h, t-h) - F(s-h, t+h) + F(s-h, t-h)}{4h^2}$   |


## ğŸ“Œ ìš”ì•½

| êµ¬ì„± ìš”ì†Œ           | ì—­í•  ë˜ëŠ” ìˆ˜ì‹ í‘œí˜„                     |
|--------------------|------------------------------------------|
| `X2D::val`         | $X(s, t)$ ê°’ ê³„ì‚°                    |
| `X2D::d_s`, `d_t`, `d_ss`, ... | $X$ì˜ í•´ì„ì  ë„í•¨ìˆ˜ ì œê³µ         |
| `f2(s, t)`         | $F(s, t) = \frac{X(s, t)}{W(s, t)}$ êµ¬ì„± |
| `fd2`              | ì¤‘ì•™ ìœ í•œì°¨ë¶„ë²•ìœ¼ë¡œ $F$ì˜ ìˆ˜ì¹˜ ë„í•¨ìˆ˜ ê·¼ì‚¬ |
| `evaluate_quotient_rule2` vs `fd2` | í•´ì„ ë„í•¨ìˆ˜ì™€ ìˆ˜ì¹˜ ë„í•¨ìˆ˜ì˜ ì •í™•ë„ ë¹„êµ |


# impl X3D
impl X3Dì˜ ì—­í• ê³¼ ì¤‘ì•™ ì°¨ë¶„ë²•ì—ì„œì˜ í™œìš©ì„ ìˆ˜ì‹ê³¼ í•¨ê»˜ ì •ë¦¬í•œ ì„¤ëª…ì…ë‹ˆë‹¤.  
X3DëŠ” 3ë³€ìˆ˜ í•¨ìˆ˜ X(r,s,t)ì˜ í•´ì„ì  ë„í•¨ìˆ˜ ì œê³µìì´ë©°, ëª« í•¨ìˆ˜ $F=\frac{X}{W}$ ì˜ ìˆ˜ì¹˜ ê²€ì¦ì— ì‚¬ìš©ë©ë‹ˆë‹¤.

## ğŸ” impl X3Dì˜ ì—­í• 
X3DëŠ” 3ë³€ìˆ˜ í•¨ìˆ˜ X(r,s,t)ì˜ í•´ì„ì  ì •ì˜ì™€ ë„í•¨ìˆ˜ë¥¼ ì œê³µí•©ë‹ˆë‹¤.  
ì´ëŠ” ëª« í•¨ìˆ˜ $F(r,s,t)=\frac{X(r,s,t)}{W(r,s,t)}$ ì˜ ë„í•¨ìˆ˜ ê³„ì‚° ë° ê²€ì¦ì— ì‚¬ìš©ë©ë‹ˆë‹¤.
### 1. í•¨ìˆ˜ ì •ì˜
```rust
fn val(r, s, t) -> [f64; 2]
```
- ë°˜í™˜ê°’:

$$
X(r,s,t)=\left[ r+s^2+t^3,\  2r-s+t\right]
$$ 

## 2. ë„í•¨ìˆ˜ ì •ì˜ (`impl X3D`)

| í•¨ìˆ˜ ì´ë¦„        | ìˆ˜ì‹ í‘œí˜„                                                              | ì˜ë¯¸ ë˜ëŠ” ë°©í–¥         |
|------------------|------------------------------------------------------------------------|------------------------|
| `d_r(r, s, t)`   | $\frac{\partial X}{\partial r} = [1,\ 2]$                           | r ë°©í–¥ 1ì°¨ ë„í•¨ìˆ˜      |
| `d_s(r, s, t)`   | $\frac{\partial X}{\partial s} = [2s,\ -1]$                         | s ë°©í–¥ 1ì°¨ ë„í•¨ìˆ˜      |
| `d_t(r, s, t)`   | $\frac{\partial X}{\partial t} = [3t^2,\ 1]$                        | t ë°©í–¥ 1ì°¨ ë„í•¨ìˆ˜      |
| `d_rr(r, s, t)`  | $\frac{\partial^2 X}{\partial r^2} = [0,\ 0]$                       | r ë°©í–¥ 2ì°¨ ë„í•¨ìˆ˜      |
| `d_rs(r, s, t)`  | $\frac{\partial^2 X}{\partial r \partial s} = [0,\ 0]$              | râ€“s í˜¼í•© 2ì°¨ ë„í•¨ìˆ˜     |
| `d_rt(r, s, t)`  | $\frac{\partial^2 X}{\partial r \partial t} = [0,\ 0]$              | râ€“t í˜¼í•© 2ì°¨ ë„í•¨ìˆ˜     |
| `d_ss(r, s, t)`  | $\frac{\partial^2 X}{\partial s^2} = [2,\ 0]$                       | s ë°©í–¥ 2ì°¨ ë„í•¨ìˆ˜      |
| `d_st(r, s, t)`  | $\frac{\partial^2 X}{\partial s \partial t} = [0,\ 0]$              | sâ€“t í˜¼í•© 2ì°¨ ë„í•¨ìˆ˜     |
| `d_tt(r, s, t)`  | $\frac{\partial^2 X}{\partial t^2} = [6t,\ 0]$                      | t ë°©í–¥ 2ì°¨ ë„í•¨ìˆ˜      |


### ğŸ§ª ì¤‘ì•™ ì°¨ë¶„ë²•ì—ì„œì˜ ì‚¬ìš©
í…ŒìŠ¤íŠ¸ì—ì„œëŠ” fd3 í•¨ìˆ˜ë¥¼ í†µí•´ ìˆ˜ì¹˜ì ìœ¼ë¡œ ë„í•¨ìˆ˜ë¥¼ ê·¼ì‚¬í•©ë‹ˆë‹¤. ì´ë•Œ ì‚¬ìš©ë˜ëŠ” í•¨ìˆ˜ëŠ” $F(r,s,t)=\frac{X(r,s,t)}{W(r,s,t)}$ ì…ë‹ˆë‹¤.
#### f3(r, s, t) ì •ì˜
```rust
fn f3(r, s, t) {
    let x = X3D::val(r, s, t);
    let w = W3D::val(r, s, t);
    [x[0] / w, x[1] / w]
}
```

â†’ ëª« í•¨ìˆ˜ $F(r,s,t)=\frac{X(r,s,t)}{W(r,s,t)}$ ë¥¼ êµ¬ì„±

## ğŸ§ª ì¤‘ì•™ ì°¨ë¶„ë²• ê·¼ì‚¬ ìˆ˜ì‹ (3D)

| ë„í•¨ìˆ˜ ì¢…ë¥˜     | ê·¼ì‚¬ ìˆ˜ì‹                                                                                         |
|------------------|----------------------------------------------------------------------------------------------------|
| $F_r$        | $\frac{F(r+h, s, t) - F(r-h, s, t)}{2h}$                                                       |
| $F_s$        | $\frac{F(r, s+h, t) - F(r, s-h, t)}{2h}$                                                       |
| $F_t$        | $\frac{F(r, s, t+h) - F(r, s, t-h)}{2h}$                                                       |
| $F_{rr}$     | $\frac{F(r+h, s, t) - 2F(r, s, t) + F(r-h, s, t)}{h^2}$                                        |
| $F_{rs}$     | $\frac{F(r+h, s+h, t) - F(r+h, s-h, t) - F(r-h, s+h, t) + F(r-h, s-h, t)}{4h^2}$               |
| $F_{rt}$     | $\frac{F(r+h, s, t+h) - F(r+h, s, t-h) - F(r-h, s, t+h) + F(r-h, s, t-h)}{4h^2}$               |
| $F_{st}$     | $\frac{F(r, s+h, t+h) - F(r, s+h, t-h) - F(r, s-h, t+h) + F(r, s-h, t-h)}{4h^2}$               |
| $F_{tt}$     | $\frac{F(r, s, t+h) - 2F(r, s, t) + F(r, s, t-h)}{h^2}$                                        |


## ğŸ“Œ ìš”ì•½ í‘œ

| êµ¬ì„± ìš”ì†Œ                         | ì—­í•  ë˜ëŠ” ìˆ˜ì‹ í‘œí˜„                                         |
|----------------------------------|--------------------------------------------------------------|
| `X3D::val`                       | $X(r, s, t)$ ê°’ ê³„ì‚°                                     |
| `X3D::d_r`, `d_s`, `d_t`, `d_rr`, `d_rs`, `d_rt`, `d_ss`, `d_st`, `d_tt` | $X$ì˜ í•´ì„ì  ë„í•¨ìˆ˜ ì œê³µ             |
| `f3(r, s, t)`                    | $F(r, s, t) = \frac{X(r, s, t)}{W(r, s, t)}$ êµ¬ì„±         |
| `fd3`                            | ì¤‘ì•™ ì°¨ë¶„ë²•ìœ¼ë¡œ $F$ì˜ ìˆ˜ì¹˜ ë„í•¨ìˆ˜ ê·¼ì‚¬                   |
| `evaluate_quotient_rule3` vs `fd3` | í•´ì„ ë„í•¨ìˆ˜ì™€ ìˆ˜ì¹˜ ë„í•¨ìˆ˜ì˜ ì •í™•ë„ ë¹„êµ                     |


## âœ… í•µì‹¬ ìš”ì•½
- ì°¨ë¶„ë²•ì€ ê·¼ì‚¬ë²•ì…ë‹ˆë‹¤.
    - ìˆ˜ì¹˜ì ìœ¼ë¡œ ë„í•¨ìˆ˜ë¥¼ ì¶”ì •í•  ìˆ˜ ìˆì§€ë§Œ, ì˜¤ì°¨ê°€ ì¡´ì¬í•©ë‹ˆë‹¤.
- ì´ í•¨ìˆ˜ë“¤ì€ ê·¼ì‚¬ê°€ ì•„ë‹Œ í•´ì„ì  ìˆ˜ì‹ ê¸°ë°˜ ê³„ì‚°ì…ë‹ˆë‹¤.
    - ëª«ì˜ ë¯¸ë¶„ ë²•ì¹™ì„ ì§ì ‘ ì ìš©í•˜ì—¬ ì •í™•í•œ ë„í•¨ìˆ˜ ê°’ì„ ê³„ì‚°í•©ë‹ˆë‹¤.
- í…ŒìŠ¤íŠ¸ì—ì„œëŠ” ì°¨ë¶„ë²•ìœ¼ë¡œ ê·¼ì‚¬í•œ ê°’ê³¼ ë¹„êµí•˜ì—¬
    - ìˆ˜ì‹ ê¸°ë°˜ ê³„ì‚°ì´ ì‹¤ì œë¡œë„ ì •í™•í•œì§€ë¥¼ ê²€ì¦í•©ë‹ˆë‹¤.

```rust
#[cfg(test)]
mod quotient_rule_tests {

    use nurbslib::core::maths::{on_evaluate_quotient_rule2, on_evaluate_quotient_rule3};
    // ---------- ìœ í‹¸ ----------

    fn idx2(i: usize, j: usize, v_stride: usize) -> usize {
        // k(i,j) = ((i+j)(i+j+1)/2 + j) * stride
        let d = i + j;
        (((d * (d + 1)) / 2) + j) * v_stride
    }

    fn idx3(i: usize, j: usize, k: usize, v_stride: usize) -> usize {
        // n(i,j,k) = stride*( d(d+1)(d+2)/6 + (j+k)(j+k+1)/2 + k ), d=i+j+k
        let d = i + j + k;
        v_stride * ((d * (d + 1) * (d + 2)) / 6 + ((j + k) * (j + k + 1)) / 2 + k)
    }

    fn approx(a: f64, b: f64, atol: f64, rtol: f64) -> bool {
        let diff = (a - b).abs();
        if diff <= atol {
            return true;
        }
        diff <= rtol * a.abs().max(b.abs()).max(1.0)
    }

    fn approx_slice(a: &[f64], b: &[f64], atol: f64, rtol: f64) -> bool {
        if a.len() != b.len() {
            return false;
        }
        for (&x, &y) in a.iter().zip(b.iter()) {
            if !approx(x, y, atol, rtol) {
                return false;
            }
        }
        true
    }
```
```rust
    // ---------- 2D í…ŒìŠ¤íŠ¸ìš© í•´ì„ ë¯¸ë¶„ ----------
    //
    // dim = 2
    // X(s,t) = [ s^2 + 2 s t + 3 t^2 ,  2 s - t + 1 ]
    // W(s,t) = 1 + s - 2 t
    // ì  (s0,t0) ì£¼ë³€ ë„í•¨ìˆ˜ë“¤ (ìµœëŒ€ 2ì°¨ / 3ì°¨ê¹Œì§€ í™•ì¥ ê°€ëŠ¥)

    #[derive(Clone, Copy)]
    struct X2D;
    impl X2D {
        fn val(s: f64, t: f64) -> [f64; 2] {
            [s * s + 2.0 * s * t + 3.0 * t * t, 2.0 * s - t + 1.0]
        }
        fn d_s(s: f64, t: f64) -> [f64; 2] {
            [2.0 * s + 2.0 * t, 2.0]
        }
        fn d_t(s: f64, t: f64) -> [f64; 2] {
            [2.0 * s + 6.0 * t, -1.0]
        }
        fn d_ss(_s: f64, _t: f64) -> [f64; 2] {
            [2.0, 0.0]
        }
        fn d_st(_s: f64, _t: f64) -> [f64; 2] {
            [2.0, 0.0]
        }
        fn d_tt(_s: f64, _t: f64) -> [f64; 2] {
            [6.0, 0.0]
        }
        // 3ì°¨ ë„í•¨ìˆ˜ëŠ” 0 (ë‹¤í•­ ì°¨ìˆ˜ìƒ)
    }
```
```rust
    #[derive(Clone, Copy)]
    struct W2D;
    impl W2D {
        fn val(s: f64, t: f64) -> f64 {
            1.0 + s - 2.0 * t
        }
        fn d_s(_s: f64, _t: f64) -> f64 {
            1.0
        }
        fn d_t(_s: f64, _t: f64) -> f64 {
            -2.0
        }
        fn d_ss(_s: f64, _t: f64) -> f64 {
            0.0
        }
        fn d_st(_s: f64, _t: f64) -> f64 {
            0.0
        }
        fn d_tt(_s: f64, _t: f64) -> f64 {
            0.0
        }
    }
```
```rust
    // F = X/W, ìˆ˜ì¹˜ ë¯¸ë¶„ìš© í—¬í¼
    fn f2(s: f64, t: f64) -> [f64; 2] {
        let x = X2D::val(s, t);
        let w = W2D::val(s, t);
        [x[0] / w, x[1] / w]
    }
```
```rust
    // ---------- 3D í…ŒìŠ¤íŠ¸ìš© í•´ì„ ë¯¸ë¶„ ----------
    //
    // dim=2 (ì—¬ì „íˆ ë²¡í„° 2ì„±ë¶„)ë¡œ ë‘ê³ , ë§¤ê°œë³€ìˆ˜ë§Œ 3D.
    // X(r,s,t) = [ r + s^2 + t^3,  2r - s + t ]
    // W(r,s,t) = 2 + r - s - t
    // (ìµœëŒ€ 2ì°¨ / 3ì°¨)

    #[derive(Clone, Copy)]
    struct X3D;
    impl X3D {
        fn val(r: f64, s: f64, t: f64) -> [f64; 2] {
            [r + s * s + t * t * t, 2.0 * r - s + t]
        }
        fn d_r(_r: f64, _s: f64, _t: f64) -> [f64; 2] {
            [1.0, 2.0]
        }
        fn d_s(_r: f64, s: f64, _t: f64) -> [f64; 2] {
            [2.0 * s, -1.0]
        }
        fn d_t(_r: f64, _s: f64, t: f64) -> [f64; 2] {
            [3.0 * t * t, 1.0]
        }
        fn d_rr(_r: f64, _s: f64, _t: f64) -> [f64; 2] {
            [0.0, 0.0]
        }
        fn d_rs(_r: f64, _s: f64, _t: f64) -> [f64; 2] {
            [0.0, 0.0]
        }
        fn d_rt(_r: f64, _s: f64, _t: f64) -> [f64; 2] {
            [0.0, 0.0]
        }
        fn d_ss(_r: f64, _s: f64, _t: f64) -> [f64; 2] {
            [2.0, 0.0]
        }
        fn d_st(_r: f64, _s: f64, _t: f64) -> [f64; 2] {
            [0.0, 0.0]
        }
        fn d_tt(_r: f64, _s: f64, _t: f64) -> [f64; 2] {
            [6.0 * _t, 0.0]
        }
        // 3ì°¨:
        #[allow(unused)]
        fn d_ttt(_r: f64, _s: f64, _t: f64) -> [f64; 2] {
            [6.0, 0.0]
        }
    }
```
```rust
    #[derive(Clone, Copy)]
    struct W3D;
    impl W3D {
        fn val(r: f64, s: f64, t: f64) -> f64 {
            2.0 + r - s - t
        }
        fn d_r(_r: f64, _s: f64, _t: f64) -> f64 {
            1.0
        }
        fn d_s(_r: f64, _s: f64, _t: f64) -> f64 {
            -1.0
        }
        fn d_t(_r: f64, _s: f64, _t: f64) -> f64 {
            -1.0
        }
        fn d_rr(_r: f64, _s: f64, _t: f64) -> f64 {
            0.0
        }
        fn d_rs(_r: f64, _s: f64, _t: f64) -> f64 {
            0.0
        }
        fn d_rt(_r: f64, _s: f64, _t: f64) -> f64 {
            0.0
        }
        fn d_ss(_r: f64, _s: f64, _t: f64) -> f64 {
            0.0
        }
        fn d_st(_r: f64, _s: f64, _t: f64) -> f64 {
            0.0
        }
        fn d_tt(_r: f64, _s: f64, _t: f64) -> f64 {
            0.0
        }
    }
```
```rust
    fn f3(r: f64, s: f64, t: f64) -> [f64; 2] {
        let x = X3D::val(r, s, t);
        let w = W3D::val(r, s, t);
        [x[0] / w, x[1] / w]
    }
```
```rust
    // ì¤‘ì•™ ìœ í•œì°¨ë¶„ (2D)
    fn fd2<F>(f: F, s: f64, t: f64, h: f64) -> ([[f64; 2]; 3], [[f64; 2]; 3])
    where
        F: Fn(f64, f64) -> [f64; 2],
    {
        // 0: ê°’, 1: s, 2: t
        let f0 = f(s, t);
        let fs = {
            let fp = f(s + h, t);
            let fm = f(s - h, t);
            [(fp[0] - fm[0]) / (2.0 * h), (fp[1] - fm[1]) / (2.0 * h)]
        };
        let ft = {
            let fp = f(s, t + h);
            let fm = f(s, t - h);
            [(fp[0] - fm[0]) / (2.0 * h), (fp[1] - fm[1]) / (2.0 * h)]
        };
        // 2ì°¨
        let fss = {
            let fp = f(s + h, t);
            let f0 = f(s, t);
            let fm = f(s - h, t);
            [
                (fp[0] - 2.0 * f0[0] + fm[0]) / (h * h),
                (fp[1] - 2.0 * f0[1] + fm[1]) / (h * h),
            ]
        };
        let ftt = {
            let fp = f(s, t + h);
            let f0 = f(s, t);
            let fm = f(s, t - h);
            [
                (fp[0] - 2.0 * f0[0] + fm[0]) / (h * h),
                (fp[1] - 2.0 * f0[1] + fm[1]) / (h * h),
            ]
        };
        let fst = {
            let fpp = f(s + h, t + h);
            let fpm = f(s + h, t - h);
            let fmp = f(s - h, t + h);
            let fmm = f(s - h, t - h);
            [
                (fpp[0] - fpm[0] - fmp[0] + fmm[0]) / (4.0 * h * h),
                (fpp[1] - fpm[1] - fmp[1] + fmm[1]) / (4.0 * h * h),
            ]
        };
        // ë°˜í™˜ í¬ë§·: [0]=ê°’,[1]=1ì°¨,[2]=2ì°¨ ë¬¶ìŒ
        let first = [f0, fs, ft];
        let second = [fss, fst, ftt];
        (first, second)
    }
```
```rust
    // ì¤‘ì•™ ìœ í•œì°¨ë¶„ (3D) â€” ê°’/1ì°¨/2ì°¨ê¹Œì§€
    #[allow(clippy::too_many_arguments)]
    fn fd3<F>(f: F, r: f64, s: f64, t: f64, h: f64) -> ([[f64; 2]; 4], [[[f64; 2]; 3]; 3])
    where
        F: Fn(f64, f64, f64) -> [f64; 2],
    {
        let f0 = f(r, s, t);
        let fr = {
            let fp = f(r + h, s, t);
            let fm = f(r - h, s, t);
            [(fp[0] - fm[0]) / (2.0 * h), (fp[1] - fm[1]) / (2.0 * h)]
        };
        let fs = {
            let fp = f(r, s + h, t);
            let fm = f(r, s - h, t);
            [(fp[0] - fm[0]) / (2.0 * h), (fp[1] - fm[1]) / (2.0 * h)]
        };
        let ft = {
            let fp = f(r, s, t + h);
            let fm = f(r, s, t - h);
            [(fp[0] - fm[0]) / (2.0 * h), (fp[1] - fm[1]) / (2.0 * h)]
        };
        // 2ì°¨
        let frr = {
            let fp = f(r + h, s, t);
            let f0 = f(r, s, t);
            let fm = f(r - h, s, t);
            [
                (fp[0] - 2.0 * f0[0] + fm[0]) / (h * h),
                (fp[1] - 2.0 * f0[1] + fm[1]) / (h * h),
            ]
        };
        let fss = {
            let fp = f(r, s + h, t);
            let f0 = f(r, s, t);
            let fm = f(r, s - h, t);
            [
                (fp[0] - 2.0 * f0[0] + fm[0]) / (h * h),
                (fp[1] - 2.0 * f0[1] + fm[1]) / (h * h),
            ]
        };
        let ftt = {
            let fp = f(r, s, t + h);
            let f0 = f(r, s, t);
            let fm = f(r, s, t - h);
            [
                (fp[0] - 2.0 * f0[0] + fm[0]) / (h * h),
                (fp[1] - 2.0 * f0[1] + fm[1]) / (h * h),
            ]
        };
        let frs = {
            let fpp = f(r + h, s + h, t);
            let fpm = f(r + h, s - h, t);
            let fmp = f(r - h, s + h, t);
            let fmm = f(r - h, s - h, t);
            [
                (fpp[0] - fpm[0] - fmp[0] + fmm[0]) / (4.0 * h * h),
                (fpp[1] - fpm[1] - fmp[1] + fmm[1]) / (4.0 * h * h),
            ]
        };
        let frt = {
            let fpp = f(r + h, s, t + h);
            let fpm = f(r + h, s, t - h);
            let fmp = f(r - h, s, t + h);
            let fmm = f(r - h, s, t - h);
            [
                (fpp[0] - fpm[0] - fmp[0] + fmm[0]) / (4.0 * h * h),
                (fpp[1] - fpm[1] - fmp[1] + fmm[1]) / (4.0 * h * h),
            ]
        };
        let fst = {
            let fpp = f(r, s + h, t + h);
            let fpm = f(r, s + h, t - h);
            let fmp = f(r, s - h, t + h);
            let fmm = f(r, s - h, t - h);
            [
                (fpp[0] - fpm[0] - fmp[0] + fmm[0]) / (4.0 * h * h),
                (fpp[1] - fpm[1] - fmp[1] + fmm[1]) / (4.0 * h * h),
            ]
        };
        let first = [f0, fr, fs, ft];
        let second = [[frr, frs, frt], [frs, fss, fst], [frt, fst, ftt]];
        (first, second)
    }
```
```rust
    // ---------- í…ŒìŠ¤íŠ¸: evaluate_quotient_rule2 (2D) ----------

    #[test]
    fn quotient_rule2_matches_finite_difference_up_to_second_order() {
        let dim = 2usize;
        let der_count = 2usize;
        let stride = dim + 1;
        let blocks = (der_count + 1) * (der_count + 2) / 2;
        let mut v = vec![0.0f64; blocks * stride];

        // í…ŒìŠ¤íŠ¸ì  (Wê°€ 0ì— ë©€ë¦¬ ë–¨ì–´ì§€ë„ë¡)
        let s0 = 0.2;
        let t0 = -0.1;

        // ë¶„ì/ë¶„ëª¨ í•´ì„ ë„í•¨ìˆ˜ ì±„ìš°ê¸°
        // (i,j) in {00,10,01,20,11,02}
        {
            // (0,0)
            let k = idx2(0, 0, stride);
            let x = X2D::val(s0, t0);
            v[k + 0] = x[0];
            v[k + 1] = x[1];
            v[k + dim] = W2D::val(s0, t0);
            // (1,0)
            let k = idx2(1, 0, stride);
            let x = X2D::d_s(s0, t0);
            v[k + 0] = x[0];
            v[k + 1] = x[1];
            v[k + dim] = W2D::d_s(s0, t0);
            // (0,1)
            let k = idx2(0, 1, stride);
            let x = X2D::d_t(s0, t0);
            v[k + 0] = x[0];
            v[k + 1] = x[1];
            v[k + dim] = W2D::d_t(s0, t0);
            // (2,0)
            let k = idx2(2, 0, stride);
            let x = X2D::d_ss(s0, t0);
            v[k + 0] = x[0];
            v[k + 1] = x[1];
            v[k + dim] = W2D::d_ss(s0, t0);
            // (1,1)
            let k = idx2(1, 1, stride);
            let x = X2D::d_st(s0, t0);
            v[k + 0] = x[0];
            v[k + 1] = x[1];
            v[k + dim] = W2D::d_st(s0, t0);
            // (0,2)
            let k = idx2(0, 2, stride);
            let x = X2D::d_tt(s0, t0);
            v[k + 0] = x[0];
            v[k + 1] = x[1];
            v[k + dim] = W2D::d_tt(s0, t0);
        }

        // ì½œ
        assert!(on_evaluate_quotient_rule2(dim, der_count, stride, &mut v));

        // ê²°ê³¼ í•´ì„: vì—ëŠ” Xë¸”ë¡â†’Fë¸”ë¡ìœ¼ë¡œ ì¹˜í™˜ë˜ì–´ ìˆìŒ
        // ìˆ˜ì¹˜ ê²°ê³¼ì™€ ë¹„êµ
        let h = 1e-4;
        let (first, second) = fd2(f2, s0, t0, h);

        let k00 = idx2(0, 0, stride);
        let k10 = idx2(1, 0, stride);
        let k01 = idx2(0, 1, stride);
        let k20 = idx2(2, 0, stride);
        let k11 = idx2(1, 1, stride);
        let k02 = idx2(0, 2, stride);

        let f00 = [v[k00 + 0], v[k00 + 1]];
        let fs = [v[k10 + 0], v[k10 + 1]];
        let ft = [v[k01 + 0], v[k01 + 1]];
        let fss = [v[k20 + 0], v[k20 + 1]];
        let fst = [v[k11 + 0], v[k11 + 1]];
        let ftt = [v[k02 + 0], v[k02 + 1]];

        // í—ˆìš©ì˜¤ì°¨
        let (atol, rtol) = (1e-8, 1e-6);

        assert!(
            approx_slice(&f00, &first[0], atol, rtol),
            "F mismatch: {:?} vs {:?}",
            f00,
            first[0]
        );
        assert!(
            approx_slice(&fs, &first[1], atol, rtol),
            "Fs mismatch: {:?} vs {:?}",
            fs,
            first[1]
        );
        assert!(
            approx_slice(&ft, &first[2], atol, rtol),
            "Ft mismatch: {:?} vs {:?}",
            ft,
            first[2]
        );
        assert!(
            approx_slice(&fss, &second[0], atol, rtol),
            "Fss mismatch: {:?} vs {:?}",
            fss,
            second[0]
        );
        assert!(
            approx_slice(&fst, &second[1], atol, rtol),
            "Fst mismatch: {:?} vs {:?}",
            fst,
            second[1]
        );
        assert!(
            approx_slice(&ftt, &second[2], atol, rtol),
            "Ftt mismatch: {:?} vs {:?}",
            ftt,
            second[2]
        );
    }
```
```rust
    // ---------- í…ŒìŠ¤íŠ¸: evaluate_quotient_rule3 (3D) ----------

    #[test]
    fn quotient_rule3_matches_finite_difference_up_to_second_order() {
        let dim = 2usize;
        let der_count = 2usize;
        let stride = dim + 1;
        let blocks = (der_count + 1) * (der_count + 2) * (der_count + 3) / 6;
        let mut v = vec![0.0f64; blocks * stride];

        // í…ŒìŠ¤íŠ¸ì  (W>1 ë³´ì¥)
        let r0 = 0.1;
        let s0 = -0.2;
        let t0 = 0.3;

        // (0,0,0)
        let n = idx3(0, 0, 0, stride);
        let x = X3D::val(r0, s0, t0);
        v[n + 0] = x[0];
        v[n + 1] = x[1];
        v[n + dim] = W3D::val(r0, s0, t0);

        // 1ì°¨
        let n = idx3(1, 0, 0, stride);
        let x = X3D::d_r(r0, s0, t0);
        v[n + 0] = x[0];
        v[n + 1] = x[1];
        v[n + dim] = W3D::d_r(r0, s0, t0);
        let n = idx3(0, 1, 0, stride);
        let x = X3D::d_s(r0, s0, t0);
        v[n + 0] = x[0];
        v[n + 1] = x[1];
        v[n + dim] = W3D::d_s(r0, s0, t0);
        let n = idx3(0, 0, 1, stride);
        let x = X3D::d_t(r0, s0, t0);
        v[n + 0] = x[0];
        v[n + 1] = x[1];
        v[n + dim] = W3D::d_t(r0, s0, t0);

        // 2ì°¨
        let n = idx3(2, 0, 0, stride);
        let x = X3D::d_rr(r0, s0, t0);
        v[n + 0] = x[0];
        v[n + 1] = x[1];
        v[n + dim] = W3D::d_rr(r0, s0, t0);
        let n = idx3(1, 1, 0, stride);
        let x = X3D::d_rs(r0, s0, t0);
        v[n + 0] = x[0];
        v[n + 1] = x[1];
        v[n + dim] = W3D::d_rs(r0, s0, t0);
        let n = idx3(1, 0, 1, stride);
        let x = X3D::d_rt(r0, s0, t0);
        v[n + 0] = x[0];
        v[n + 1] = x[1];
        v[n + dim] = W3D::d_rt(r0, s0, t0);
        let n = idx3(0, 2, 0, stride);
        let x = X3D::d_ss(r0, s0, t0);
        v[n + 0] = x[0];
        v[n + 1] = x[1];
        v[n + dim] = W3D::d_ss(r0, s0, t0);
        let n = idx3(0, 1, 1, stride);
        let x = X3D::d_st(r0, s0, t0);
        v[n + 0] = x[0];
        v[n + 1] = x[1];
        v[n + dim] = W3D::d_st(r0, s0, t0);
        let n = idx3(0, 0, 2, stride);
        let x = X3D::d_tt(r0, s0, t0);
        v[n + 0] = x[0];
        v[n + 1] = x[1];
        v[n + dim] = W3D::d_tt(r0, s0, t0);

        assert!(on_evaluate_quotient_rule3(dim, der_count, stride, &mut v));

        // ìˆ˜ì¹˜ ë¹„êµ
        let h = 1e-4;
        let (first, second) = fd3(f3, r0, s0, t0, h);

        // ê°’
        let n000 = idx3(0, 0, 0, stride);
        let f00 = [v[n000 + 0], v[n000 + 1]];
        assert!(approx_slice(&f00, &first[0], 1e-8, 1e-6));

        // 1ì°¨
        let nr = idx3(1, 0, 0, stride);
        let ns = idx3(0, 1, 0, stride);
        let nt = idx3(0, 0, 1, stride);
        let fr = [v[nr + 0], v[nr + 1]];
        let fs = [v[ns + 0], v[ns + 1]];
        let ft = [v[nt + 0], v[nt + 1]];
        assert!(approx_slice(&fr, &first[1], 1e-8, 1e-6), "Fr mismatch");
        assert!(approx_slice(&fs, &first[2], 1e-8, 1e-6), "Fs mismatch");
        assert!(approx_slice(&ft, &first[3], 1e-8, 1e-6), "Ft mismatch");

        // 2ì°¨
        let nrr = idx3(2, 0, 0, stride);
        let nrs = idx3(1, 1, 0, stride);
        let nrt = idx3(1, 0, 1, stride);
        let nss = idx3(0, 2, 0, stride);
        let nst = idx3(0, 1, 1, stride);
        let ntt = idx3(0, 0, 2, stride);

        let frr = [v[nrr + 0], v[nrr + 1]];
        let frs = [v[nrs + 0], v[nrs + 1]];
        let frt = [v[nrt + 0], v[nrt + 1]];
        let fss = [v[nss + 0], v[nss + 1]];
        let fst = [v[nst + 0], v[nst + 1]];
        let ftt = [v[ntt + 0], v[ntt + 1]];

        // second: [[frr, frs, frt],[frs,fss,fst],[frt,fst,ftt]]
        assert!(
            approx_slice(&frr, &second[0][0], 1e-7, 1e-5),
            "Frr mismatch"
        );
        assert!(
            approx_slice(&frs, &second[0][1], 1e-7, 1e-5),
            "Frs mismatch"
        );
        assert!(
            approx_slice(&frt, &second[0][2], 1e-7, 1e-5),
            "Frt mismatch"
        );
        assert!(
            approx_slice(&fss, &second[1][1], 1e-7, 1e-5),
            "Fss mismatch"
        );
        assert!(
            approx_slice(&fst, &second[1][2], 1e-7, 1e-5),
            "Fst mismatch"
        );
        assert!(
            approx_slice(&ftt, &second[2][2], 1e-7, 1e-5),
            "Ftt mismatch"
        );
    }
}
```

## ğŸ“Œ ëª« í•¨ìˆ˜ ë„í•¨ìˆ˜ ê³„ì‚° í•¨ìˆ˜ ìš”ì•½

| í•¨ìˆ˜ ì´ë¦„                    | ì°¨ì› | ì¸ë±ìŠ¤ ê³„ì‚° ë°©ì‹            | ì²˜ë¦¬í•˜ëŠ” ìˆ˜ì‹ í‘œí˜„                          |
|-----------------------------|------|-----------------------------|---------------------------------------------|
| `on_evaluate_quotient_rule2` | 2D   | `idx2(i, j, stride)`        | $F(s, t) = \frac{X(s, t)}{W(s, t)}$     |
| `on_evaluate_quotient_rule3` | 3D   | `idx3(i, j, k, stride)`     | $F(r, s, t) = \frac{X(r, s, t)}{W(r, s, t)}$ |



## ğŸ§® ì¸ë±ìŠ¤ ê³„ì‚° ë°©ì‹
### ğŸ”¹ 2D ì¸ë±ìŠ¤: idx2(i, j, stride)

$$
\mathrm{index}=\left( \frac{(i+j)(i+j+1)}{2}+j\right) \cdot \mathrm{stride}
$$

- i,j: ë„í•¨ìˆ˜ ì°¨ìˆ˜ (ì˜ˆ: $F_{st} â†’ i=1,j=1$ )
- stride: ê° ë¸”ë¡ì˜ í¬ê¸° = dim + 1 (ì˜ˆ: dim=2 â†’ stride=3)
- ë°˜í™˜ ìœ„ì¹˜: í•´ë‹¹ ë„í•¨ìˆ˜ì˜ $[Xâ‚€, Xâ‚, ..., W]$ ê°’ì´ ì €ì¥ëœ ì‹œì‘ ì¸ë±ìŠ¤

### ğŸ”¹ 3D ì¸ë±ìŠ¤: idx3(i, j, k, stride)

$$
\mathrm{index}=\mathrm{stride}\cdot \left( \frac{d(d+1)(d+2)}{6}+\frac{(j+k)(j+k+1)}{2}+k\right) \quad \mathrm{where\  }d=i+j+k
$$

- i,j,k: ë„í•¨ìˆ˜ ì°¨ìˆ˜ (ì˜ˆ: $F_{rst} â†’ i=1,j=1,k=1$ )
- stride: ê° ë¸”ë¡ì˜ í¬ê¸° = dim + 1
- ë°˜í™˜ ìœ„ì¹˜: í•´ë‹¹ ë„í•¨ìˆ˜ì˜ $[Xâ‚€, Xâ‚, ..., W]$ ê°’ì´ ì €ì¥ëœ ì‹œì‘ ì¸ë±ìŠ¤

### ğŸ“¦ ì €ì¥ êµ¬ì¡°
ê° ì¸ë±ìŠ¤ ìœ„ì¹˜ì—ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ê°’ë“¤ì´ ì €ì¥ë©ë‹ˆë‹¤:
v[index + 0] = Xì˜ ì²« ë²ˆì§¸ ì„±ë¶„
v[index + 1] = Xì˜ ë‘ ë²ˆì§¸ ì„±ë¶„
v[index + dim] = W ê°’


- dim = 2ì¼ ê²½ìš°: stride = 3
- ì˜ˆ: v[idx2(1,0,3)] â†’ F_sì˜ Xâ‚€, Xâ‚, Wê°€ [v[k+0], v[k+1], v[k+2]]ì— ì €ì¥ë¨

### âœ… ì‚¬ìš© íë¦„ ìš”ì•½
- v ë°°ì—´ì— Xì™€ Wì˜ ë„í•¨ìˆ˜ ê°’ì„ ì¸ë±ìŠ¤ ê³„ì‚°ìœ¼ë¡œ ì±„ì›€
- on_evaluate_quotient_rule2/3 í˜¸ì¶œ â†’ $F=X/W$ ë° ë„í•¨ìˆ˜ ê³„ì‚°
- ê²°ê³¼ëŠ” ê°™ì€ ì¸ë±ìŠ¤ ìœ„ì¹˜ì— Fì˜ ë„í•¨ìˆ˜ë¡œ ë®ì–´ì“°ê¸°ë¨
- í…ŒìŠ¤íŠ¸ì—ì„œëŠ” fd2, fd3ë¡œ ìˆ˜ì¹˜ ê·¼ì‚¬í•œ ë„í•¨ìˆ˜ì™€ ë¹„êµ



### ğŸ§® v ë°°ì—´ì˜ êµ¬ì¡° (3D: evaluate_quotient_rule3)
- ê° ë„í•¨ìˆ˜ ë¸”ë¡ì€ stride = dim + 1 í¬ê¸°ë¥¼ ê°€ì§ â†’ ì˜ˆ: dim = 2ì´ë©´ stride = 3
- ê° ë¸”ë¡ì—ëŠ” ë‹¤ìŒì´ ì €ì¥ë¨:
- v[n + 0] â†’ Fì˜ ì²« ë²ˆì§¸ ì„±ë¶„ (ì˜ˆ: xì¶•)
- v[n + 1] â†’ Fì˜ ë‘ ë²ˆì§¸ ì„±ë¶„ (ì˜ˆ: yì¶•)
- v[n + dim] â†’ W ê°’

### ğŸ”¢ ì¸ë±ìŠ¤ ê³„ì‚° ì˜ˆì‹œ
#### 1. F(r,s,t) ìì²´ (0ì°¨)
- ìœ„ì¹˜: idx3(0,0,0,stride) â†’ ì˜ˆë¥¼ ë“¤ì–´ stride = 3ì´ë©´ n = 0
- ì €ì¥:
- v[0] â†’ F_0[0] (xì¶•)
- v[1] â†’ F_0[1] (yì¶•)
- v[2] â†’ W
#### 2. F_r (1ì°¨ ë„í•¨ìˆ˜)
- ìœ„ì¹˜: idx3(1,0,0,stride) â†’ ê³„ì‚°í•˜ë©´ n = 4 (stride=3ì¼ ë•Œ)
- ì €ì¥:
- v[4] â†’ F_r[0]
- v[5] â†’ F_r[1]
- v[6] â†’ W_r

## âœ… ì •ë¦¬ (stride = 3 ê¸°ì¤€)

| ë„í•¨ìˆ˜ ì¢…ë¥˜ | ì¸ë±ìŠ¤ ê³„ì‚°ì‹           | ì €ì¥ ìœ„ì¹˜               | ì„¤ëª…                     |
|-------------|--------------------------|--------------------------|--------------------------|
| $F$     | `idx3(0,0,0,3)` â†’ 0      | `v[0], v[1], v[2]`       | í•¨ìˆ˜ê°’ $F = X / W$   |
| $F_r$   | `idx3(1,0,0,3)` â†’ 3      | `v[3], v[4], v[5]`       | r ë°©í–¥ 1ì°¨ ë„í•¨ìˆ˜        |
| $F_s$   | `idx3(0,1,0,3)` â†’ 6      | `v[6], v[7], v[8]`       | s ë°©í–¥ 1ì°¨ ë„í•¨ìˆ˜        |
| $F_t$   | `idx3(0,0,1,3)` â†’ 9      | `v[9], v[10], v[11]`     | t ë°©í–¥ 1ì°¨ ë„í•¨ìˆ˜        |

- â€» ì‹¤ì œ ì¸ë±ìŠ¤ëŠ” idx3 í•¨ìˆ˜ë¡œ ì •í™•íˆ ê³„ì‚°í•´ì•¼ í•˜ë©°, ìœ„ëŠ” ì˜ˆì‹œì…ë‹ˆë‹¤.


