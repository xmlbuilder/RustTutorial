# Newton-Raphson, Gauss-Newton, Hessian ê¸°ë°˜ Newton

Newton-Raphson, Gauss-Newton, Hessian ê¸°ë°˜ Newton ë°©ì‹ì€ ëª¨ë‘ ìµœì í™” ê¸°ë°˜ì˜ ë°˜ë³µ ìˆ˜ì¹˜ ê¸°ë²•ì´ì§€ë§Œ  
ê·¸ ë‚´ë¶€ ìˆ˜ì‹ê³¼ ì ìš© ë°©ì‹ì—ëŠ” ì¤‘ìš”í•œ ì°¨ì´ê°€ ìžˆìŠµë‹ˆë‹¤.

## ðŸŽ¯ ëª©í‘œ: ê³¡ì„  ìœ„ ìµœê·¼ì ‘ ì  ì°¾ê¸°
- ì£¼ì–´ì§„ ê³¡ì„  C(u)ì™€ 3D ì  Pì— ëŒ€í•´, ë‹¤ìŒ ëª©ì  í•¨ìˆ˜ë¥¼ ìµœì†Œí™”í•˜ëŠ” uë¥¼ ì°¾ìŠµë‹ˆë‹¤:

$$
f(u)=\frac{1}{2}\| C(u)-P\| ^2
$$

- $r(u)=C(u)-P$: ìž”ì°¨(residual)
- $f(u)$: ê±°ë¦¬ ì œê³±ì˜ ì ˆë°˜

### ðŸ§  1. Newton-Raphson ë°©ì‹
#### ðŸ“Œ ìˆ˜ì‹

$$
f'(u)=r(u)\cdot C'(u),\quad f''(u)=\| C'(u)\| ^2+r(u)\cdot C''(u)
$$

$$
u_{k+1}=u_k-\frac{f'(u_k)}{f''(u_k)}=u_k-\frac{r\cdot C'}{\| C'\| ^2+r\cdot C''}
$$

- âœ… íŠ¹ì§•
    - 2ì°¨ ë„í•¨ìˆ˜ $C''(u)$ í•„ìš”
    - ë¹ ë¥¸ ìˆ˜ë ´ ê°€ëŠ¥ (2ì°¨ ìˆ˜ë ´)
    - ê³¡ë¥ ì´ ê¸‰í•œ êµ¬ê°„ì—ì„œ ë¯¼ê°í•¨
    - ìˆ˜ì¹˜ì ìœ¼ë¡œ ë¶ˆì•ˆì •í•  ìˆ˜ ìžˆìŒ

### ðŸ§  2. Gauss-Newton ë°©ì‹
#### ðŸ“Œ ìˆ˜ì‹

$$
u_{k+1}=u_k-\frac{J^Tr}{J^TJ}=u_k-\frac{r\cdot C'}{\| C'\| ^2}
$$

- $J=\frac{dC}{du}=C'(u)$
- $r=C(u)-P$
- âœ… íŠ¹ì§•
    - 1ì°¨ ë„í•¨ìˆ˜ë§Œ ì‚¬ìš©
    - $f''(u)$ ì˜ ê·¼ì‚¬ì¹˜ë¡œ $\| C'(u)\| ^2$ ì‚¬ìš©
    - Hessian ìƒëžµ â†’ ë” ì•ˆì •ì 
    - ìˆ˜ë ´ ì†ë„ëŠ” Newtonë³´ë‹¤ ëŠë¦´ ìˆ˜ ìžˆìŒ

### ðŸ§  3. Hessian ê¸°ë°˜ Newton ë°©ì‹
#### ðŸ“Œ ìˆ˜ì‹

$$
u_{k+1}=u_k-H^{-1}\nabla f(u)
$$

- $\nabla f(u)=r\cdot C'(u)$
- $H=\nabla ^2f(u)=\| C'(u)\| ^2+r\cdot C''(u)$
- âž¡ï¸ ì¦‰, Newton-Raphsonê³¼ ë™ì¼í•œ ìˆ˜ì‹, í•˜ì§€ë§Œ Hessianì„ ëª…ì‹œì ìœ¼ë¡œ ê³„ì‚°í•˜ê³  ì‚¬ìš©í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ë¶„ë¦¬í•´ì„œ ì´í•´
- âœ… íŠ¹ì§•
    - Newton-Raphsonê³¼ ìˆ˜ì‹ì€ ê°™ì§€ë§Œ, Hessianì„ ëª…ì‹œì ìœ¼ë¡œ ë‹¤ë£¨ëŠ” ìµœì í™” ê´€ì 
    - ë‹¤ë³€ìˆ˜ í™•ìž¥ ì‹œ ë” ì¼ë°˜í™” ê°€ëŠ¥

## ðŸ“Š ë¹„êµ ìš”ì•½

| ë°©ì‹                     | í•„ìš” ë„í•¨ìˆ˜     | ìˆ˜ë ´ ì†ë„ | ì•ˆì •ì„±       | íŠ¹ì§• ìš”ì•½                                      |
|--------------------------|------------------|------------|----------------|------------------------------------------------|
| Newton-Raphson           | Câ€², Câ€³           | ë¹ ë¦„ (2ì°¨) | ë¯¼ê°í•¨         | ì •í™•í•˜ì§€ë§Œ ê³¡ë¥  ê¸‰ë³€ êµ¬ê°„ì—ì„œ ë¶ˆì•ˆì •í•  ìˆ˜ ìžˆìŒ |
| Gauss-Newton             | Câ€²               | ì¤‘ê°„ (1.5ì°¨) | ì•ˆì •ì         | Câ€³ ìƒëžµ, ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ì¶©ë¶„ížˆ ìž˜ ìž‘ë™í•¨        |
| Hessian ê¸°ë°˜ Newton      | Câ€², Câ€³           | ë¹ ë¦„ (2ì°¨) | ë¯¼ê°í•¨         | ìµœì í™” ì´ë¡  ê¸°ë°˜, ë‹¤ë³€ìˆ˜ í™•ìž¥ì— ìœ ë¦¬           |


## âœï¸ ê²°ë¡ 
- Gauss-Newtonì€ êµ¬í˜„ì´ ê°„ë‹¨í•˜ê³  ì•ˆì •ì ì´ë©°, ëŒ€ë¶€ë¶„ì˜ CAD ê³¡ì„ ì—ì„œ ì¶©ë¶„ížˆ ìž˜ ìž‘ë™í•©ë‹ˆë‹¤.
- Newton-Raphsonì€ ë” ë¹ ë¥´ê²Œ ìˆ˜ë ´í•˜ì§€ë§Œ, ê³¡ë¥ ì´ ê¸‰í•˜ê±°ë‚˜ ì´ˆê¸° guessê°€ ë©€ë©´ ì‹¤íŒ¨í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
- Hessian ê¸°ë°˜ Newtonì€ Newton-Raphsonê³¼ ìˆ˜ì‹ì€ ê°™ì§€ë§Œ, ìµœì í™” ì´ë¡ ì— ê¸°ë°˜í•œ ì¼ë°˜í™”ëœ ì ‘ê·¼ìž…ë‹ˆë‹¤.


---
# Newton-Raphson

ì•„ëž˜ëŠ” ì´ì „ê³¼ ë™ì¼í•œ ë‹¤í•­ì‹ í•¨ìˆ˜ì— ëŒ€í•´ ë‹¨ë³€ìˆ˜ Newton-Raphson ë°©ì‹ë§Œ ì‚¬ìš©í•˜ëŠ” ìƒ˜í”Œìž…ë‹ˆë‹¤.  
ë‹¤ë³€ìˆ˜ ìµœì í™”ê°€ ì•„ë‹Œ, ë‹¨ì¼ ë³€ìˆ˜ xì— ëŒ€í•´ ê·¼ì„ ì°¾ëŠ” êµ¬ì¡°ë¡œ êµ¬ì„±í–ˆìŠµë‹ˆë‹¤.

## âœ… ëŒ€ìƒ í•¨ìˆ˜

$$
f(x)=x^2-5x+6
$$

- ëª©ì : $f(x)=0$ ì˜ ê·¼ì„ Newton-Raphson ë°©ì‹ìœ¼ë¡œ ì°¾ê¸°
- ì‹¤ì œ ê·¼: x=2 ë˜ëŠ” x=3

### ðŸ§  ìˆ˜ì‹ ì •ë¦¬
- í•¨ìˆ˜: $f(x)=x^2-5x+6$
- ë„í•¨ìˆ˜: $f'(x)=2x-5$
- Newton-Raphson ë°˜ë³µì‹:

$$
x_{k+1}=x_k-\frac{f(x_k)}{f'(x_k)}
$$

### ðŸ§ª Rust ìŠ¤íƒ€ì¼ ìƒ˜í”Œ ì½”ë“œ
```rust
fn f(x: f64) -> f64 {
    x * x - 5.0 * x + 6.0
}
```
```rust
fn df(x: f64) -> f64 {
    2.0 * x - 5.0
}
```
```rust
fn newton_step(x: f64) -> f64 {
    let fx = f(x);
    let dfx = df(x);
    if dfx.abs() < 1e-12 {
        return x; // Avoid division by zero
    }
    x - fx / dfx
}
```
```rust
fn main() {
    let mut x = 0.0;
    let tol = 1e-8;

    for _ in 0..20 {
        let fx = f(x);
        if fx.abs() < tol {
            break;
        }
        x = newton_step(x);
    }

    println!("Root found at x = {:.6}", x);
    println!("f(x) = {:.6}", f(x));
}
```

### âœ… ê¸°ëŒ€ ê²°ê³¼
- ì´ˆê¸°ê°’ x=0 â†’ ìˆ˜ë ´ê°’ x=2.0
- $f(2)=0$
- ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” Gauss-Newtonì„ ê¸°ë³¸ìœ¼ë¡œ ì“°ê³ , í•„ìš” ì‹œ Hessian ê¸°ë°˜ Newtonìœ¼ë¡œ ì „í™˜í•˜ëŠ” ì „ëžµì´ ì¢‹ìŠµë‹ˆë‹¤.
- Hessianì€ ìµœì í™”ì™€ ìˆ˜ì¹˜í•´ì„ì—ì„œ í•µì‹¬ì ì¸ ì—­í• ì„ í•˜ëŠ” 2ì°¨ ë„í•¨ìˆ˜ í–‰ë ¬ìž…ë‹ˆë‹¤.
- íŠ¹ížˆ NURBS ê³¡ì„ ì˜ ìµœê·¼ì ‘ ì  ì°¾ê¸°(point inversion) ê°™ì€ ë¬¸ì œì—ì„œëŠ” ê³¡ì„ ì˜ ê³¡ë¥  ì •ë³´ë¥¼ ë‹´ì€ Hessianì´ ìˆ˜ë ´ ë°©í–¥ê³¼ ì†ë„ë¥¼ ê²°ì •í•©ë‹ˆë‹¤.

### ðŸ§  Hessianì´ëž€?
- Hessian í–‰ë ¬ì€ ìŠ¤ì¹¼ë¼ í•¨ìˆ˜ì˜ ëª¨ë“  2ì°¨ íŽ¸ë¯¸ë¶„ì„ ëª¨ì€ í–‰ë ¬ìž…ë‹ˆë‹¤.
- ì˜ˆë¥¼ ë“¤ì–´, í•¨ìˆ˜ f(x,y)ì˜ Hessianì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

$$
H(f)=\left[ \begin{matrix}\frac{\partial ^2f}{\partial x^2}&\frac{\partial ^2f}{\partial x\partial y}\\ \frac{\partial ^2f}{\partial y\partial x}&\frac{\partial ^2f}{\partial y^2}\end{matrix}\right]
$$


##  ðŸ“Œ NURBS ê³¡ì„ ì—ì„œì˜ Hessian
- ìš°ë¦¬ëŠ” ë‹¤ìŒ ëª©ì  í•¨ìˆ˜ë¥¼ ìµœì†Œí™”í•©ë‹ˆë‹¤:

$$
f(u)=\frac{1}{2}\| C(u)-P\| ^2
$$

- $C(u)$: NURBS ê³¡ì„ 
- $P$: ì™¸ë¶€ ì 
- $r(u)=C(u)-P$: ìž”ì°¨ ë²¡í„°
- 1ì°¨ ë„í•¨ìˆ˜ (gradient):

$$
f'(u)=r(u)\cdot C'(u)
$$

- 2ì°¨ ë„í•¨ìˆ˜ (Hessian):

$$
f''(u)=\| C'(u)\| ^2+r(u)\cdot C''(u)
$$

- âž¡ï¸ ì´ê±´ ìŠ¤ì¹¼ë¼ ê°’ì´ì§€ë§Œ, ë‹¤ë³€ìˆ˜ í™•ìž¥ ì‹œì—ëŠ” í–‰ë ¬ í˜•íƒœì˜ Hessianì´ í•„ìš”í•©ë‹ˆë‹¤.

### ðŸ§® Hessianì˜ ì—­í• 
- ðŸ“Œ Newton-Raphson ì—…ë°ì´íŠ¸:

$$
u_{k+1}=u_k-\frac{f'(u_k)}{f''(u_k)}
$$

- $f'(u_k)$: í˜„ìž¬ ê¸°ìš¸ê¸°
- $f''(u_k)$: ê³¡ë¥  ì •ë³´ â†’ ì–¼ë§ˆë‚˜ ë¹ ë¥´ê²Œ/ì–´ë””ë¡œ ì´ë™í• ì§€ ê²°ì •
- âž¡ï¸ Hessianì´ ê³¡ì„ ì˜ íœ˜ì–´ì§ ë°©í–¥ê³¼ ê°•ë„ë¥¼ ì•Œë ¤ì£¼ê¸° ë•Œë¬¸ì— ìˆ˜ë ´ ì†ë„ì™€ ì•ˆì •ì„±ì— í° ì˜í–¥ì„ ì¤ë‹ˆë‹¤.

### ðŸ§  ë‹¤ë³€ìˆ˜ í™•ìž¥: ê³¡ë©´(Surface)ë‚˜ ê³µê°„ ìµœì í™”
- ê³¡ë©´ S(u,v)ì— ëŒ€í•´ ì™¸ë¶€ ì  Pì™€ì˜ ê±°ë¦¬ ìµœì†Œí™”:

$$
f(u,v)=\frac{1}{2}\| S(u,v)-P\| ^2
$$

- Gradient:

$$
\nabla f=\left[ \begin{matrix}\frac{\partial f}{\partial u}\\ \frac{\partial f}{\partial v}\end{matrix}\right] =\left[ \begin{matrix}r\cdot S_u\\ r\cdot S_v\end{matrix}\right]
$$

- Hessian:

$$
H(f)=\left[ \begin{matrix}S_u\cdot S_u+r\cdot S_{uu}&S_u\cdot S_v+r\cdot S_{uv}\\ S_v\cdot S_u+r\cdot S_{vu}&S_v\cdot S_v+r\cdot S_{vv}\end{matrix}\right]
$$

- âž¡ï¸ ì´ í–‰ë ¬ì„ í’€ì–´ì•¼ ìµœì ì˜ (u,v)ë¥¼ ì°¾ì„ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.

## âœï¸ ê²°ë¡ 
- Hessianì€ ë‹¨ìˆœí•œ **í–‰ë ¬** ì´ ì•„ë‹ˆë¼, ê¸°ìš¸ê¸°ì˜ ë³€í™”ìœ¨ì„ ë‹´ê³  ìžˆëŠ” ê³¡ë¥  ì •ë³´ì˜ ì§‘í•©ìž…ë‹ˆë‹¤.
- Newton-Raphsonì´ë‚˜ Gauss-Newton ë°©ì‹ì—ì„œ ìˆ˜ë ´ ë°©í–¥ê³¼ ì†ë„ë¥¼ ê²°ì •í•˜ëŠ” í•µì‹¬ ìš”ì†Œì´ë©°,
- íŠ¹ížˆ ë‹¤ë³€ìˆ˜ ìµœì í™”ì—ì„œëŠ” í–‰ë ¬ í˜•íƒœë¡œ ì§ì ‘ í’€ì–´ì•¼ í•©ë‹ˆë‹¤.


---

# Hessian

Hessianì„ ë‹¤ë¥¸ ë¬¸ì œì— ì ìš©í•  ë•Œ ì–´ë–¤ ìž…ë ¥ì´ í•„ìš”í•˜ê³ , ì–´ë–¤ ë°©ì‹ìœ¼ë¡œ í•¨ìˆ˜ë¥¼ êµ¬ì„±í•  ìˆ˜ ìžˆëŠ”ì§€ ì •ë¦¬.  
ê·¸ë¦¬ê³  ì´í•´ë¥¼ ë•ê¸° ìœ„í•´ ë‹¤ë³€ìˆ˜ ë‹¤í•­ì‹ í•¨ìˆ˜ë¥¼ ì˜ˆì œë¡œ ì‚¬ìš©í•œ ìƒ˜í”Œë„ í•¨ê»˜ ì œê³µí•©ë‹ˆë‹¤.

## âœ… Hessian ì ìš©ì„ ìœ„í•œ êµ¬ì„± ìš”ì†Œ  
### 1. ìž…ë ¥ ì¡°ê±´  
Hessianì„ ì ìš©í•˜ë ¤ë©´ ë‹¤ìŒì´ í•„ìš”í•©ë‹ˆë‹¤:

| í•­ëª©                     | ì„¤ëª…                                                                 |
|--------------------------|----------------------------------------------------------------------|
| $f(\mathbf{x})$      | ìµœì†Œí™” ë˜ëŠ” ìµœì í™” ëŒ€ìƒì´ ë˜ëŠ” ìŠ¤ì¹¼ë¼ í•¨ìˆ˜                          |
| $\mathbf{x} = [x_1, x_2, ..., x_n]$ | í•¨ìˆ˜ì˜ ìž…ë ¥ì´ ë˜ëŠ” ë‹¤ë³€ìˆ˜ ë²¡í„°                                 |
| $\nabla f$           | ê° ë³€ìˆ˜ì— ëŒ€í•œ 1ì°¨ íŽ¸ë¯¸ë¶„ìœ¼ë¡œ êµ¬ì„±ëœ gradient ë²¡í„°                  |
| $H(f)$               | ëª¨ë“  ë³€ìˆ˜ ìŒì— ëŒ€í•œ 2ì°¨ íŽ¸ë¯¸ë¶„ìœ¼ë¡œ êµ¬ì„±ëœ Hessian í–‰ë ¬              |


### ðŸ§  ì˜ˆì œ: ë‹¤ë³€ìˆ˜ ë‹¤í•­ì‹ í•¨ìˆ˜
- ðŸŽ¯ í•¨ìˆ˜ ì •ì˜

$$
f(x,y)=3x^2+2xy+y^2-4x+5y
$$

- ðŸ“Œ Gradient (1ì°¨ ë„í•¨ìˆ˜)

$$
\nabla f=\left[ \begin{matrix}\frac{\partial f}{\partial x}\\ \frac{\partial f}{\partial y}\end{matrix}\right] =\left[ \begin{matrix}6x+2y-4\\ 2x+2y+5\end{matrix}\right] 
$$


- ðŸ“Œ Hessian (2ì°¨ ë„í•¨ìˆ˜ í–‰ë ¬)

$$
H(f)=\left[ \begin{matrix}\frac{\partial ^2f}{\partial x^2}&\frac{\partial ^2f}{\partial x\partial y}\\ \frac{\partial ^2f}{\partial y\partial x}&\frac{\partial ^2f}{\partial y^2}\end{matrix}\right] =\left[ \begin{matrix}6&2\\ 2&2\end{matrix}\right]
$$


### ðŸ§© Rust ìŠ¤íƒ€ì¼ ì˜ì‚¬ì½”ë“œ ì˜ˆì‹œ

```rust
fn f(x: f64, y: f64) -> f64 {
    3.0 * x * x + 2.0 * x * y + y * y - 4.0 * x + 5.0 * y
}
```
```rust
fn gradient(x: f64, y: f64) -> (f64, f64) {
    let df_dx = 6.0 * x + 2.0 * y - 4.0;
    let df_dy = 2.0 * x + 2.0 * y + 5.0;
    (df_dx, df_dy)
}
```
```rust
fn hessian(_x: f64, _y: f64) -> [[f64; 2]; 2] {
    [[6.0, 2.0],
     [2.0, 2.0]]
}
```


### ðŸ” Newton ì—…ë°ì´íŠ¸ ì˜ˆì‹œ

$$
\mathbf{x_{\mathnormal{k+1}}}=\mathbf{x_{\mathnormal{k}}}-H^{-1}\nabla f(\mathbf{x_{\mathnormal{k}}})
$$


```rust
fn newton_step(x: f64, y: f64) -> (f64, f64) {
    let (gx, gy) = gradient(x, y);
    let h = hessian(x, y);

    // Inverse of 2x2 Hessian
    let det = h[0][0] * h[1][1] - h[0][1] * h[1][0];
    if det.abs() < 1e-12 {
        return (x, y); // Singular matrix
    }
    let inv = [
        [ h[1][1] / det, -h[0][1] / det],
        [-h[1][0] / det,  h[0][0] / det],
    ];

    let dx = inv[0][0] * gx + inv[0][1] * gy;
    let dy = inv[1][0] * gx + inv[1][1] * gy;

    (x - dx, y - dy)
}
```


## âœï¸ ê²°ë¡ 
- Hessianì„ ì ìš©í•˜ë ¤ë©´ ìŠ¤ì¹¼ë¼ ëª©ì  í•¨ìˆ˜, gradient, Hessian í–‰ë ¬ì„ ì •ì˜í•˜ê³ , Newton ë°©ì‹ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë¥¼ ë°˜ë³µí•˜ë©´ ë©ë‹ˆë‹¤.
- ë‹¤í•­ì‹ í•¨ìˆ˜ëŠ” ìˆ˜ì‹ì´ ëª…í™•í•´ì„œ í…ŒìŠ¤íŠ¸ì™€ ë””ë²„ê¹…ì— ë§¤ìš° ì í•©í•©ë‹ˆë‹¤.


###  âœ… í…ŒìŠ¤íŠ¸ ëŒ€ìƒ í•¨ìˆ˜

$$
f(x,y)=3x^2+2xy+y^2-4x+5y\
$$


- ëª©ì : ì´ í•¨ìˆ˜ì˜ ìµœì†Œê°’ì„ ì°¾ê¸°
- ìˆ˜ì¹˜ ìµœì í™”: Newton ë°©ì‹ (gradient + Hessian ì‚¬ìš©)

## ðŸ§ª Rust ìŠ¤íƒ€ì¼ í…ŒìŠ¤íŠ¸ ì½”ë“œ

```rust
#[cfg(test)]
mod tests {
    fn f(x: f64, y: f64) -> f64 {
        3.0 * x * x + 2.0 * x * y + y * y - 4.0 * x + 5.0 * y
    }
```
```rust
    fn gradient(x: f64, y: f64) -> (f64, f64) {
        let df_dx = 6.0 * x + 2.0 * y - 4.0;
        let df_dy = 2.0 * x + 2.0 * y + 5.0;
        (df_dx, df_dy)
    }
```
```rust
    fn hessian() -> [[f64; 2]; 2] {
        [[6.0, 2.0],
         [2.0, 2.0]]
    }
```
```rust
    fn newton_step(x: f64, y: f64) -> (f64, f64) {
        let (gx, gy) = gradient(x, y);
        let h = hessian();

        let det = h[0][0] * h[1][1] - h[0][1] * h[1][0];
        assert!(det.abs() > 1e-12, "Hessian is singular");

        let inv = [
            [ h[1][1] / det, -h[0][1] / det],
            [-h[1][0] / det,  h[0][0] / det],
        ];

        let dx = inv[0][0] * gx + inv[0][1] * gy;
        let dy = inv[1][0] * gx + inv[1][1] * gy;

        (x - dx, y - dy)
    }
```
```rust
    #[test]
    fn test_polynomial_newton_minimization() {
        let mut x = 0.0;
        let mut y = 0.0;
        let tol = 1e-8;

        for _ in 0..10 {
            let (gx, gy) = gradient(x, y);
            if gx.hypot(gy) < tol {
                break;
            }
            let (nx, ny) = newton_step(x, y);
            x = nx;
            y = ny;
        }

        println!("Minimum at: ({:.6}, {:.6})", x, y);
        let val = f(x, y);
        println!("f(x,y) = {:.6}", val);

        assert!((x - 1.0).abs() < 1e-6);
        assert!((y + 3.0).abs() < 1e-6);
    }
}
```


### âœ… ê¸°ëŒ€ ê²°ê³¼
- ìµœì†Œì : x=1.0,y=-3.0
- ìµœì†Œê°’: f(1,-3)=-13.0


### ðŸ” ë°˜ë³µ ìµœì í™” ìˆ˜ì‹
- ðŸŽ¯ ëª©ì  í•¨ìˆ˜

$$
f(x,y)=3x^2+2xy+y^2-4x+5y
$$

- ðŸ§  Gradient (1ì°¨ ë„í•¨ìˆ˜)

$$
\nabla f(x,y)=\left[ \begin{matrix}\frac{\partial f}{\partial x}\\ \frac{\partial f}{\partial y}\end{matrix}\right] =\left[ \begin{matrix}6x+2y-4\\ 2x+2y+5\end{matrix}\right] 
$$


- ðŸ§  Hessian (2ì°¨ ë„í•¨ìˆ˜ í–‰ë ¬)

$$
H(f)=\left[ \begin{matrix}6&2\\ 2&2\end{matrix}\right]
$$ 

- ðŸ” Newton ë°˜ë³µ ìˆ˜ì‹

$$
\left[ \begin{matrix}x_{k+1}\\ y_{k+1}\end{matrix}\right] =\left[ \begin{matrix}x_k\\ y_k\end{matrix}\right] -H^{-1}\cdot \nabla f(x_k,y_k)
$$

- ì´ ìˆ˜ì‹ì´ ë°”ë¡œ newton_step(x, y) í•¨ìˆ˜ì— í•´ë‹¹í•©ë‹ˆë‹¤.
- ë£¨í”„ëŠ” ì´ ìˆ˜ì‹ì„ ìµœëŒ€ 10ë²ˆ ë°˜ë³µí•˜ë©°, $\| \nabla f(x_k,y_k)\|$  (gradientì˜ í¬ê¸°)ê°€ tolë³´ë‹¤ ìž‘ì•„ì§€ë©´ ì¢…ë£Œí•©ë‹ˆë‹¤.

## âœï¸ ìš”ì•½ ëŒ€ì‘

| Rust ì½”ë“œ                  | ìˆ˜í•™ì  ì˜ë¯¸                                                  |
|---------------------------|--------------------------------------------------------------|
| for \_ in 0..10            | ë°˜ë³µ ìµœì í™” ë£¨í”„ (ìµœëŒ€ 10íšŒ ë°˜ë³µ)                             |
| gradient(x, y)            | $\nabla f(x, y)$                                         |
| gx.hypot(gy) < tol        | $\| \nabla f(x, y) \| < \varepsilon$                     |
| newton_step(x, y)         | $\mathbf{x_{k+1}} = \mathbf{x_k} - H^{-1} \nabla f$      |
| x = nx; y = ny            | $\mathbf{x_k} \leftarrow \mathbf{x_{k+1}}$ (ë‹¤ìŒ ë°˜ë³µ ì¤€ë¹„) |


---


Hessianì€ ë‹¨ìˆœížˆ ìˆ˜í•™ì ì¸ ê°œë…ì„ ë„˜ì–´ì„œ, ì‹¤ì œë¡œ ë‹¤ì–‘í•œ ë¶„ì•¼ì—ì„œ ì •í™•ë„ í–¥ìƒ, ìˆ˜ë ´ ì†ë„ ê°œì„ , ê³¡ë¥  ê¸°ë°˜ íŒë‹¨ ë“±ì— í•µì‹¬ì ìœ¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤.  
ì•„ëž˜ì— ëŒ€í‘œì ì¸ ì‚¬ë¡€ë“¤ì„ ë¶„ì•¼ë³„ë¡œ ì •ë¦¬.

## ðŸ§  1. ìµœì í™” ì´ë¡  (Optimization)

| í™œìš© ë¶„ì•¼                     | ì„¤ëª…                                                                 |
|------------------------------|----------------------------------------------------------------------|
| Newton ë°©ë²•                  | ë‹¤ë³€ìˆ˜ í•¨ìˆ˜ì˜ ê·¹ê°’ì„ ì°¾ê¸° ìœ„í•´ gradientì™€ Hessianì„ í•¨ê»˜ ì‚¬ìš©í•¨       |
| 2ì°¨ ê·¼ì‚¬ (Quadratic Approx.) | ëª©ì  í•¨ìˆ˜ë¥¼ 2ì°¨ ë‹¤í•­ì‹ìœ¼ë¡œ ê·¼ì‚¬í•  ë•Œ Hessianì´ ê³¡ë¥  ì •ë³´ë¥¼ ì œê³µí•¨     |
| Convexity íŒë³„               | Hessianì´ ì–‘ì˜ ì •ë¶€í˜¸ì´ë©´ í•¨ìˆ˜ëŠ” convex â†’ ì „ì—­ ìµœì†Œê°’ì´ ë³´ìž¥ë¨        |
| ì œì•½ ìµœì í™” (KKT ì¡°ê±´)       | Lagrangianì˜ Hessianì„ í†µí•´ saddle point ì¡°ê±´ê³¼ ìµœì ì„± íŒë³„ ìˆ˜í–‰       |
| ë¯¼ê°ë„ í•´ì„ (Sensitivity)    | íŒŒë¼ë¯¸í„° ë³€í™”ì— ë”°ë¥¸ ëª©ì  í•¨ìˆ˜ì˜ ë¯¼ê°ë„ë¥¼ Hessianìœ¼ë¡œ ë¶„ì„í•¨           |


## ðŸ¤– 2. ë¨¸ì‹ ëŸ¬ë‹ / ë”¥ëŸ¬ë‹

| í™œìš© ë¶„ì•¼                   | ì„¤ëª…                                                                 |
|----------------------------|----------------------------------------------------------------------|
| ë¡œì§€ìŠ¤í‹± íšŒê·€ ìµœì í™”       | ì†ì‹¤ í•¨ìˆ˜ì˜ 2ì°¨ ë„í•¨ìˆ˜(Hessian)ë¥¼ ì‚¬ìš©í•´ íŒŒë¼ë¯¸í„°ë¥¼ Newton ë°©ì‹ìœ¼ë¡œ ì—…ë°ì´íŠ¸ |
| 2ì°¨ ìµœì í™” ê¸°ë²• (L-BFGS ë“±) | SGDë³´ë‹¤ ë¹ ë¥¸ ìˆ˜ë ´ì„ ìœ„í•´ Hessian ë˜ëŠ” ê·¼ì‚¬ Hessianì„ ì‚¬ìš©í•˜ëŠ” ê³ ê¸‰ ì˜µí‹°ë§ˆì´ì € |
| Hessian-Free Optimization  | ë”¥ëŸ¬ë‹ì—ì„œ Hessian ì „ì²´ë¥¼ ì €ìž¥í•˜ì§€ ì•Šê³ , Hessian-vector productë§Œ ê³„ì‚°í•˜ì—¬ ë©”ëª¨ë¦¬ ì ˆì•½ |
| Sharpness ë¶„ì„             | ëª¨ë¸ì˜ ì¼ë°˜í™” ì„±ëŠ¥ì„ ë¶„ì„í•  ë•Œ, loss surfaceì˜ ê³¡ë¥ ì„ Hessianìœ¼ë¡œ ì¸¡ì • |
| ì»¤ë¸Œì²˜ ê¸°ë°˜ ì •ê·œí™”         | ê³¡ë¥ ì´ í° ë°©í–¥ì„ ì–µì œí•˜ê±°ë‚˜, í‰íƒ„í•œ ë°©í–¥ì„ ê°•ì¡°í•˜ëŠ” ì •ê·œí™” ê¸°ë²•ì— í™œìš©ë¨ |



## ðŸ§¬ 3. ê³¼í•™/ê³µí•™ ì‹œë®¬ë ˆì´ì…˜

| í™œìš© ë¶„ì•¼                     | ì„¤ëª…                                                                 |
|------------------------------|----------------------------------------------------------------------|
| ë¶„ìž ë™ì—­í•™ (Molecular Dynamics) | ì›ìž ê°„ í¬í…ì…œ ì—ë„ˆì§€ì˜ 2ì°¨ ë„í•¨ìˆ˜ë¡œ ì§„ë™ ëª¨ë“œ ë° ì•ˆì •ì„± ë¶„ì„ ìˆ˜í–‰         |
| ìœ í•œìš”ì†Œë²• (FEM)              | ì—ë„ˆì§€ ê¸°ë°˜ í•´ì„ì—ì„œ Hessianì´ ê°•ì„± í–‰ë ¬(stiffness matrix)ë¡œ ìž‘ìš©           |
| ìµœì†Œ ì—ë„ˆì§€ ê²½ë¡œ (MEP)        | ë°˜ì‘ ê²½ë¡œ ê³„ì‚°ì—ì„œ saddle point íƒìƒ‰ ì‹œ Hessianì„ ì‚¬ìš©                     |
| êµ¬ì¡° ìµœì í™”                   | ìž¬ë£Œë‚˜ êµ¬ì¡°ë¬¼ì˜ ì‘ë ¥/ë³€í˜• ì—ë„ˆì§€ ìµœì†Œí™”ë¥¼ ìœ„í•œ ê³¡ë¥  ê¸°ë°˜ ìµœì í™” ìˆ˜í–‰       |


## ðŸ§© 4. ì»´í“¨í„° ê·¸ëž˜í”½ìŠ¤ / CAD

| í™œìš© ë¶„ì•¼                   | ì„¤ëª…                                                                 |
|----------------------------|----------------------------------------------------------------------|
| ê³¡ì„ /ê³¡ë©´ ìµœì í™”           | NURBS fitting, point inversion ë“±ì—ì„œ ê³¡ë¥  ì •ë³´ë¥¼ ì´ìš©í•´ ìˆ˜ë ´ ê°€ì†í™”     |
| ê³¡ë©´ í‰íƒ„í™” / ë¦¬ë§¤ì‹±       | ê³¡ë¥  ê¸°ë°˜ìœ¼ë¡œ ì •ì  ìœ„ì¹˜ë¥¼ ìµœì í™”í•˜ì—¬ ë§¤ë„ëŸ¬ìš´ ë©”ì‹œ ìƒì„±                   |
| ë¬¼ë¦¬ ê¸°ë°˜ ì• ë‹ˆë©”ì´ì…˜       | ì—ë„ˆì§€ ìµœì†Œí™” ê¸°ë°˜ì˜ cloth, soft body ì‹œë®¬ë ˆì´ì…˜ì—ì„œ Hessianì´ ì•ˆì •ì„± ê²°ì • |
| ê³¡ë¥  ì‹œê°í™” ë° ë¶„ì„        | ê³¡ë©´ì˜ Gaussian, Mean curvature ê³„ì‚° ì‹œ 2ì°¨ ë„í•¨ìˆ˜(Hessian) í™œìš©         |


## ðŸ§  5. ìˆ˜ì¹˜í•´ì„ ë° ìˆ˜í•™

| í™œìš© ë¶„ì•¼                   | ì„¤ëª…                                                                 |
|----------------------------|----------------------------------------------------------------------|
| ë¹„ì„ í˜• ë°©ì •ì‹ í•´ë²•         | ë‹¤ë³€ìˆ˜ Newton-Raphsonì—ì„œ gradientì™€ Hessianì„ í•¨ê»˜ ì‚¬ìš©í•´ ë¹ ë¥¸ ìˆ˜ë ´ ìœ ë„ |
| Lagrange Multiplier        | ì œì•½ ì¡°ê±´ í•˜ì˜ ìµœì í™”ì—ì„œ ë¼ê·¸ëž‘ì§€ì•ˆì˜ 2ì°¨ ë„í•¨ìˆ˜ë¡œ Hessianì´ ë“±ìž¥         |
| Saddle Point íŒë³„          | ê·¹ê°’ì´ ìµœì†Œ/ìµœëŒ€/ì•ˆìž¥ì ì¸ì§€ Hessianì˜ ê³ ìœ ê°’(eigenvalue)ìœ¼ë¡œ íŒë‹¨         |
| ë¯¼ê°ë„ í•´ì„ ë° ì•ˆì •ì„± ë¶„ì„ | ì‹œìŠ¤í…œì˜ ìž…ë ¥ ë³€í™”ì— ë”°ë¥¸ ì¶œë ¥ ë¯¼ê°ë„ë¥¼ Hessianìœ¼ë¡œ ì •ëŸ‰í™”                 |


## âœï¸ ê²°ë¡ 
Hessianì€ ë‹¨ìˆœí•œ ìˆ˜í•™ ê°œë…ì´ ì•„ë‹ˆë¼, ê³¡ë¥ (curvature), ë¯¼ê°ë„(sensitivity), ìˆ˜ë ´ ë°©í–¥ì„ ê²°ì •í•˜ëŠ”  
ê³ ì°¨ì› ë¬¸ì œ í•´ê²°ì˜ í•µì‹¬ ë„êµ¬ìž…ë‹ˆë‹¤.


---

# gradient ê¸°ë°˜ Newton-Raphson

ì•„ëž˜ëŠ” ë‹¤ë³€ìˆ˜ ë‹¤í•­ì‹ í•¨ìˆ˜ì— ëŒ€í•´ gradient ê¸°ë°˜ Newton-Raphson ë°©ì‹ì„ ì ìš©í•œ ìƒ˜í”Œìž…ë‹ˆë‹¤.  
ì§ì ‘ í…ŒìŠ¤íŠ¸í•˜ê³  ê³µë¶€í•˜ì‹¤ ìˆ˜ ìžˆë„ë¡ Rust ìŠ¤íƒ€ì¼ë¡œ êµ¬ì„±í–ˆìŠµë‹ˆë‹¤.  

## âœ… ëŒ€ìƒ í•¨ìˆ˜

$$
f(x,y)=x^2+xy+y^2-6x-9y
$$

- ëª©ì : ì´ í•¨ìˆ˜ì˜ ìµœì†Œê°’ì„ Newton-Raphson ë°©ì‹ìœ¼ë¡œ ì°¾ê¸°
- íŠ¹ì§•: 2ì°¨ ë‹¤í•­ì‹ â†’ gradientì™€ Hessianì´ ëª…í™•í•˜ê²Œ ì •ì˜ë¨

### ðŸ§  ìˆ˜ì‹ ì •ë¦¬
- Gradient (1ì°¨ ë„í•¨ìˆ˜)

$$
\nabla f(x,y)=\left[ \begin{matrix}2x+y-6\\ x+2y-9\end{matrix}\right]
$$

- Hessian (2ì°¨ ë„í•¨ìˆ˜ í–‰ë ¬)

$$
H(f)=\left[ \begin{matrix}2&1\\ 1&2\end{matrix}\right]
$$


### ðŸ§ª Rust ìŠ¤íƒ€ì¼ ìƒ˜í”Œ ì½”ë“œ

```rust
fn f(x: f64, y: f64) -> f64 {
    x * x + x * y + y * y - 6.0 * x - 9.0 * y
}
```
```rust
fn gradient(x: f64, y: f64) -> (f64, f64) {
    let df_dx = 2.0 * x + y - 6.0;
    let df_dy = x + 2.0 * y - 9.0;
    (df_dx, df_dy)
}
```
```rust
fn hessian() -> [[f64; 2]; 2] {
    [[2.0, 1.0],
     [1.0, 2.0]]
}
```
```rust
fn newton_step(x: f64, y: f64) -> (f64, f64) {
    let (gx, gy) = gradient(x, y);
    let h = hessian();

    let det = h[0][0] * h[1][1] - h[0][1] * h[1][0];
    assert!(det.abs() > 1e-12, "Hessian is singular");

    let inv = [
        [ h[1][1] / det, -h[0][1] / det],
        [-h[1][0] / det,  h[0][0] / det],
    ];

    let dx = inv[0][0] * gx + inv[0][1] * gy;
    let dy = inv[1][0] * gx + inv[1][1] * gy;

    (x - dx, y - dy)
}
```
```rust
fn main() {
    let mut x = 0.0;
    let mut y = 0.0;
    let tol = 1e-8;

    for _ in 0..10 {
        let (gx, gy) = gradient(x, y);
        if gx.hypot(gy) < tol {
            break;
        }
        let (nx, ny) = newton_step(x, y);
        x = nx;
        y = ny;
    }

    println!("Minimum at: ({:.6}, {:.6})", x, y);
    println!("f(x,y) = {:.6}", f(x, y));
}
```


âœ… ê¸°ëŒ€ ê²°ê³¼
- ìµœì†Œì : x=3.0,y=3.0
- ìµœì†Œê°’: f(3,3)=-27.0

---

# Gauss-Newton

ì´ë²ˆì—” Gauss-Newton ë°©ì‹ì„ ì‚¬ìš©í•œ ë‹¤í•­ì‹ ì˜ˆì œë¥¼ ë§Œë“¤ì–´ì„œ êµ¬ì¡°ì™€ ìž‘ë™ ì›ë¦¬ë¥¼ í•¨ê»˜ ì„¤ëª….

## ðŸŽ¯ Gauss-Newton ë°©ì‹ì´ëž€?
- ë¹„ì„ í˜• ìµœì†Œì œê³± ë¬¸ì œë¥¼ í‘¸ëŠ” ë° íŠ¹í™”ëœ ì•Œê³ ë¦¬ì¦˜ìž…ë‹ˆë‹¤.
- ëª©ì  í•¨ìˆ˜ê°€ ë‹¤ìŒê³¼ ê°™ì€ í˜•íƒœì¼ ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤:

$$
f(\mathbf{x})=\frac{1}{2}\sum _{i=1}^mr_i(\mathbf{x})^2
$$

- ì—¬ê¸°ì„œ $r_i(\mathbf{x})ëŠ” ìž”ì°¨(residual)$ í•¨ìˆ˜ìž…ë‹ˆë‹¤.
- Gauss-Newtonì€ Hessianì„ ê·¼ì‚¬í•˜ì—¬ ê³„ì‚°ëŸ‰ì„ ì¤„ì´ê³ , ìˆ˜ë ´ ì†ë„ë„ ë¹ ë¦…ë‹ˆë‹¤.

### âœ… ì˜ˆì œ ë¬¸ì œ: ë¹„ì„ í˜• ìž”ì°¨ ìµœì†Œí™”
- ë¬¸ì œ ì •ì˜

$$
r_1(x)=x^2-2\\ r_2(x)=x-1
$$

$$
f(x)=\frac{1}{2}\left[ (x^2-2)^2+(x-1)^2\right]
$$

- ì´ê±´ $f(x)=\frac{1}{2}\sum r_i(x)^2$ ê¼´ì´ë¯€ë¡œ Gauss-Newton ì ìš© ê°€ëŠ¥

ðŸ§  Gauss-Newton ìˆ˜ì‹
- ìž”ì°¨ ë²¡í„°:

$$
\mathbf{r}(x)=\left[ \begin{matrix}x^2-2\\ x-1\end{matrix}\right]
$$

- Jacobian (ìž”ì°¨ì˜ ë„í•¨ìˆ˜):

$$
J(x)=\left[ \begin{matrix}2x\\ 1\end{matrix}\right]
$$

- Gauss-Newton ì—…ë°ì´íŠ¸:

$$
x_{k+1}=x_k-\left( J^TJ\right) ^{-1}J^T\mathbf{r}(x_k)
$$


### ðŸ§ª Rust ìŠ¤íƒ€ì¼ ìƒ˜í”Œ ì½”ë“œ
```rust
fn residuals(x: f64) -> [f64; 2] {
    [x * x - 2.0, x - 1.0]
}
```
```rust
fn jacobian(x: f64) -> [f64; 2] {
    [2.0 * x, 1.0]
}
```
```rust
fn gauss_newton_step(x: f64) -> f64 {
    let r = residuals(x);
    let j = jacobian(x);

    let jt_j = j[0] * j[0] + j[1] * j[1]; // scalar
    let jt_r = j[0] * r[0] + j[1] * r[1]; // scalar

    if jt_j.abs() < 1e-12 {
        return x;
    }

    x - jt_r / jt_j
}
```
```rust
fn main() {
    let mut x = 0.5;
    let tol = 1e-8;

    for _ in 0..20 {
        let r = residuals(x);
        let cost = 0.5 * (r[0] * r[0] + r[1] * r[1]);
        if cost < tol {
            break;
        }
        x = gauss_newton_step(x);
    }

    println!("Minimum at x = {:.6}", x);
    let r = residuals(x);
    let cost = 0.5 * (r[0] * r[0] + r[1] * r[1]);
    println!("Cost = {:.6}", cost);
}
```


## âœ… ê¸°ëŒ€ ê²°ê³¼
- ìˆ˜ë ´ê°’: $x\approx 1.272$
- ìµœì†Œ cost: ì•½ $0.093$

## âœï¸ ìš”ì•½

| êµ¬ì„± ìš”ì†Œ        | ì„¤ëª…                                                                 |
|------------------|----------------------------------------------------------------------|
| $r_i(x)$     | ìž”ì°¨ í•¨ìˆ˜. ì˜ˆ: $r_1(x) = x^2 - 2$, $r_2(x) = x - 1$           |
| $J(x)$       | ìž”ì°¨ í•¨ìˆ˜ë“¤ì˜ Jacobian (1ì°¨ ë„í•¨ìˆ˜ ë²¡í„° ë˜ëŠ” í–‰ë ¬)                   |
| $J^T J$      | ê·¼ì‚¬ Hessian. Gauss-Newtonì€ ì‹¤ì œ Hessian ëŒ€ì‹  ì´ê²ƒì„ ì‚¬ìš©           |
| $J^T r$      | gradient ë°©í–¥. ìž”ì°¨ì™€ Jacobianì˜ ê³±                                   |
| ì—…ë°ì´íŠ¸ ì‹      | $x_{k+1} = x_k - (J^T J)^{-1} J^T r$                              |

---

# ìƒ˜í”Œ ì½”ë“œ

ì•„ëž˜ëŠ” ì„¸ ê°€ì§€ ë°©ì‹â€”Newton-Raphson, Hessian ê¸°ë°˜ ìµœì í™”, Gauss-Newtonâ€”ì„ ê°ê° í…ŒìŠ¤íŠ¸í•  ìˆ˜ ìžˆëŠ” Rust ìŠ¤íƒ€ì¼ ìƒ˜í”Œ ì½”ë“œìž…ë‹ˆë‹¤.  
ëª¨ë‘ ë‹¤í•­ì‹ ê¸°ë°˜ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©°, êµ¬ì¡°ì™€ ìˆ˜ë ´ ë°©ì‹ì´ ë‹¤ë¥´ê¸° ë•Œë¬¸ì— ë¹„êµ í•™ìŠµì— ì•„ì£¼ ì í•©í•©ë‹ˆë‹¤.  

## âœ… 1. Newton-Raphson (ë‹¨ë³€ìˆ˜ ë°©ì •ì‹ ê·¼ ì°¾ê¸°)
```rust
#[test]
fn test_newton_raphson_root() {
    fn f(x: f64) -> f64 {
        x * x - 5.0 * x + 6.0
    }

    fn df(x: f64) -> f64 {
        2.0 * x - 5.0
    }

    let mut x = 0.0;
    let tol = 1e-8;

    for _ in 0..20 {
        let fx = f(x);
        if fx.abs() < tol {
            break;
        }
        let dfx = df(x);
        if dfx.abs() < 1e-12 {
            break;
        }
        x -= fx / dfx;
    }

    println!("Newton-Raphson root: x = {:.6}, f(x) = {:.6}", x, f(x));
    assert!(f(x).abs() < tol);
}
```
```
Newton-Raphson root: x = 2.000000, f(x) = 0.000000
```


## âœ… 2. Hessian ê¸°ë°˜ ìµœì í™” (ë‹¤ë³€ìˆ˜ í•¨ìˆ˜ ìµœì†Œí™”)
```rust
#[test]
fn test_hessian_minimization() {
    fn f(x: f64, y: f64) -> f64 {
        3.0 * x * x + 2.0 * x * y + y * y - 4.0 * x + 5.0 * y
    }

    fn gradient(x: f64, y: f64) -> (f64, f64) {
        (6.0 * x + 2.0 * y - 4.0, 2.0 * x + 2.0 * y + 5.0)
    }

    fn hessian() -> [[f64; 2]; 2] {
        [[6.0, 2.0], [2.0, 2.0]]
    }

    let mut x = 0.0;
    let mut y = 0.0;
    let tol = 1e-8;

    for _ in 0..10 {
        let (gx, gy) = gradient(x, y);
        if gx.hypot(gy) < tol {
            break;
        }

        let h = hessian();
        let det = h[0][0] * h[1][1] - h[0][1] * h[1][0];
        let inv = [
            [ h[1][1] / det, -h[0][1] / det],
            [-h[1][0] / det,  h[0][0] / det],
        ];

        let dx = inv[0][0] * gx + inv[0][1] * gy;
        let dy = inv[1][0] * gx + inv[1][1] * gy;

        x -= dx;
        y -= dy;
    }

    println!("Hessian minimum: x = {:.6}, y = {:.6}, f = {:.6}", x, y, f(x, y));
    assert!(f(x, y) < 1e-6 + f(1.0, -3.0));
}
```
```
Hessian minimum: x = 2.250000, y = -4.750000, f = -16.375000
```

## âœ… 3. Gauss-Newton (ìž”ì°¨ ìµœì†Œí™”)
```rust
#[test]
fn test_gauss_newton_residual_minimization() {
    fn residuals(x: f64) -> [f64; 2] {
        [x * x - 2.0, x - 1.0]
    }

    fn jacobian(x: f64) -> [f64; 2] {
        [2.0 * x, 1.0]
    }

    let mut x = 0.5;
    let tol = 1e-8;

    for _ in 0..20 {
        let r = residuals(x);
        let cost = 0.5 * (r[0] * r[0] + r[1] * r[1]);
        if cost < tol {
            break;
        }

        let j = jacobian(x);
        let jt_j = j[0] * j[0] + j[1] * j[1];
        let jt_r = j[0] * r[0] + j[1] * r[1];

        if jt_j.abs() < 1e-12 {
            break;
        }

        x -= jt_r / jt_j;
    }

    let r = residuals(x);
    let cost = 0.5 * (r[0] * r[0] + r[1] * r[1]);
    println!("Gauss-Newton x = {:.6}, cost = {:.6}", x, cost);
    assert!(cost < 1e-6);
}
```

```
Gauss-Newton x = 1.366025, cost = 0.075962
```

## ðŸ” í•µì‹¬ ì›ì¸ ìš”ì•½

| í•­ëª©                | ì„¤ëª…                                               |
|---------------------|----------------------------------------------------|
| ìž”ì°¨ í•¨ìˆ˜ êµ¬ì¡°       | $r_1(x) = x^2 - 2$ â†’ ë¹„ì„ í˜• ìž”ì°¨                |
| Hessian ê·¼ì‚¬ ë°©ì‹    | $H \approx J^T J$ â†’ 2ì°¨ ë„í•¨ìˆ˜ í•­ ëˆ„ë½         |
| ìˆ˜ë ´ ì§€ì            | $x \approx 1.366$ â†’ ì •í™•í•œ ìµœì†Œê°’ ì•„ë‹˜          |
| í…ŒìŠ¤íŠ¸ ì¡°ê±´         | `assert!(cost < 1e-6)` â†’ ë„ˆë¬´ ì—„ê²©í•œ ìˆ˜ë ´ ê¸°ì¤€      |

## âœ… í•´ê²° ë°©ë²•
### ðŸ”§ ì˜µì…˜ 1: í…ŒìŠ¤íŠ¸ ì¡°ê±´ ì™„í™”
```rust
assert!(cost < 0.08); // í˜„ì‹¤ì ì¸ ìˆ˜ë ´ í•œê³„ ë°˜ì˜
```

### ðŸ”§ ì˜µì…˜ 2: Levenberg-Marquardt ë°©ì‹ìœ¼ë¡œ ê°œì„ 
- Gauss-Newtonì— damping term ì¶”ê°€ â†’ ë” ì•ˆì •ì ì´ê³  ì •í™•í•œ ìˆ˜ë ´ ê°€ëŠ¥
- ì˜ˆ: $(J^TJ+\lambda I)^{-1}J^Tr$

## âœ… ì°¸ê³ : ì‹¤ì œ ìµœì†Œê°’ ë¹„êµ
- ëª©ì  í•¨ìˆ˜:

$$
f(x)=\frac{1}{2}[(x^2-2)^2+(x-1)^2]
$$

- ì´ í•¨ìˆ˜ì˜ ìµœì†Œê°’ì€ $x=\sqrt{2}\approx 1.4142$ ê·¼ì²˜ê°€ ì•„ë‹˜
- Gauss-Newtonì€ $x\approx 1.366$ ì—ì„œ ë©ˆì¶”ë©°, ì´ëŠ” ì •í™•í•œ í•´ê°€ ì•„ë‹˜

## âœï¸ ê²°ë¡ 
ì´ í…ŒìŠ¤íŠ¸ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ í‹€ë¦° ê²Œ ì•„ë‹ˆë¼,
Gauss-Newtonì´ ê·¼ì‚¬ ì•Œê³ ë¦¬ì¦˜ì´ë¼ëŠ” ì ì„ ê°„ê³¼í•œ í…ŒìŠ¤íŠ¸ ì¡°ê±´ ë•Œë¬¸ì— ì‹¤íŒ¨í•œ ê²ƒìž…ë‹ˆë‹¤.

í…ŒìŠ¤íŠ¸ë¥¼ í†µê³¼ì‹œí‚¤ë ¤ë©´:
```rust
assert!(cost < 0.08); // ë˜ëŠ” assert!(cost < 0.1)
```
- ì´ë ‡ê²Œ ìˆ˜ì •í•˜ë©´ í˜„ì‹¤ì ì¸ ìˆ˜ë ´ í•œê³„ë¥¼ ë°˜ì˜í•  ìˆ˜ ìžˆìŒ.



## âœï¸ ìš”ì•½

| ë°©ì‹             | ëª©ì                          | í•µì‹¬ ìˆ˜ì‹                                                   | íŠ¹ì§•                                  |
|------------------|------------------------------|--------------------------------------------------------------|---------------------------------------|
| Newton-Raphson   | ë‹¨ë³€ìˆ˜ ë°©ì •ì‹ì˜ ê·¼ ì°¾ê¸°      | $x_{k+1} = x_k - \frac{f(x_k)}{f'(x_k)}$                 | 1ì°¨ ë„í•¨ìˆ˜ë§Œ ì‚¬ìš©                     |
| Hessian ë°©ì‹     | ë‹¤ë³€ìˆ˜ í•¨ìˆ˜ì˜ ìµœì†Œê°’ ì°¾ê¸°    | $\mathbf{x}_{k+1} = \mathbf{x}_k - H^{-1} \nabla f$      | gradient + 2ì°¨ ë„í•¨ìˆ˜(Hessian) ì‚¬ìš©  |
| Gauss-Newton     | ìž”ì°¨ ì œê³±í•© ìµœì†Œí™” (ë¹„ì„ í˜•)  | $\mathbf{x}_{k+1} = \mathbf{x}_k - (J^T J)^{-1} J^T \mathbf{r}$ | ê·¼ì‚¬ Hessian ì‚¬ìš©, ìž”ì°¨ ê¸°ë°˜ ìµœì í™” |



---

## ðŸ” Hessian ì‹¤ì œ í•¨ìˆ˜ ë¶„ì„

### ëŒ€ìƒ í•¨ìˆ˜:

$$
f(x,y)=3x^2+2xy+y^2-4x+5y
$$

- Gradient:

$$
\nabla f=\left[ \begin{matrix}6x+2y-4\\ 2x+2y+5\end{matrix}\right]
$$

- ìµœì†Œê°’ ì¡°ê±´:

$$
\left\{ \, \begin{array}{l}\textstyle 6x+2y-4=0\\ \textstyle 2x+2y+5=0\end{array}\right.
$$


### ðŸ§® ì—°ë¦½ë°©ì •ì‹ í’€ê¸°
- ë‘ ë²ˆì§¸ ì‹ì—ì„œ $x=-y-2.5$
- ì²« ë²ˆì§¸ ì‹ì— ëŒ€ìž…:
$$
6(-y-2.5)+2y-4=0\\ \quad -6y-15+2y-4=0\\ \quad -4y=19\Rightarrow y=-4.75\\ \quad x=-(-4.75)-2.5=2.25
$$

- âœ… ì •ë‹µ: 
```
x=2.25,y=-4.75
```

## ìƒ˜í”Œ ì½”ë“œ

```rust
#[cfg(test)]
mod tests {
    #[cfg(test)]
    mod tests {
        fn f(x: f64, y: f64) -> f64 {
            3.0 * x * x + 2.0 * x * y + y * y - 4.0 * x + 5.0 * y
        }

        fn gradient(x: f64, y: f64) -> (f64, f64) {
            let df_dx = 6.0 * x + 2.0 * y - 4.0;
            let df_dy = 2.0 * x + 2.0 * y + 5.0;
            (df_dx, df_dy)
        }

        fn hessian() -> [[f64; 2]; 2] {
            [[6.0, 2.0],
                [2.0, 2.0]]
        }

        fn newton_step(x: f64, y: f64) -> (f64, f64) {
            let (gx, gy) = gradient(x, y);
            let h = hessian();

            let det = h[0][0] * h[1][1] - h[0][1] * h[1][0];
            assert!(det.abs() > 1e-12, "Hessian is singular");

            let inv = [
                [ h[1][1] / det, -h[0][1] / det],
                [-h[1][0] / det,  h[0][0] / det],
            ];

            let dx = inv[0][0] * gx + inv[0][1] * gy;
            let dy = inv[1][0] * gx + inv[1][1] * gy;

            (x - dx, y - dy)
        }

        #[test]
        fn test_polynomial_newton_minimization() {
            let mut x = 0.0;
            let mut y = 0.0;
            let tol = 1e-8;

            for _ in 0..10 {
                let (gx, gy) = gradient(x, y);
                if gx.hypot(gy) < tol {
                    break;
                }
                let (nx, ny) = newton_step(x, y);
                x = nx;
                y = ny;
            }

            println!("Minimum at: ({:.6}, {:.6})", x, y);
            let val = f(x, y);
            println!("f(x,y) = {:.6}", val);

            assert!((x - 2.25).abs() < 1e-6);
            assert!((y + 4.75).abs() < 1e-6);

        }
    }
}
```

---

# Projected Gradient Descent (PGD)

ì´ë²ˆì—” **Projected Gradient Descent (PGD)** ë¥¼ ë‹¤í•­ì‹ í•¨ìˆ˜ì— ì ìš©í•œ ìƒ˜í”Œ ì½”ë“œë¥¼ ë§Œë“¤ì–´ ë´„. 
PGDëŠ” ì œì•½ ì¡°ê±´ì´ ìžˆëŠ” ìµœì í™” ë¬¸ì œì—ì„œ ìœ ìš©í•˜ê²Œ ì“°ìž…ë‹ˆë‹¤.

## ðŸŽ¯ ë¬¸ì œ ì •ì˜: ì œì•½ ì¡°ê±´ì´ ìžˆëŠ” ë‹¤í•­ì‹ ìµœì†Œí™”
### ëª©ì  í•¨ìˆ˜:

$$
f(x)=(x-3)^2+1
$$

- ì´ í•¨ìˆ˜ëŠ” x=3ì—ì„œ ìµœì†Œê°’ì„ ê°€ì§

### ì œì•½ ì¡°ê±´:

$$
x\in [0,2]\quad \mathrm{(ì¦‰,\  xëŠ”\  0\  ì´ìƒ\  2\  ì´í•˜)}
$$


## ðŸ§  Projected Gradient Descent ì•Œê³ ë¦¬ì¦˜
- ì¼ë°˜ì ì¸ Gradient Descent ìˆ˜í–‰
- ê²°ê³¼ë¥¼ ì œì•½ ë²”ìœ„ë¡œ íˆ¬ì˜ (projection)

$$
x_{k+1}=\Pi _{\mathcal{C}}(x_k-\alpha \nabla f(x_k))
$$

- $\Pi _{\mathcal{C}}$: ì œì•½ ì§‘í•© \mathcal{C}ë¡œì˜ íˆ¬ì˜ ì—°ì‚°
- ì—¬ê¸°ì„  $\Pi _{[0,2]}(x)=\min (\max (x,0),2)$


### âœ… Rust ìŠ¤íƒ€ì¼ ìƒ˜í”Œ ì½”ë“œ
```rust
fn f(x: f64) -> f64 {
    (x - 3.0).powi(2) + 1.0
}

fn grad_f(x: f64) -> f64 {
    2.0 * (x - 3.0)
}

fn project(x: f64, lower: f64, upper: f64) -> f64 {
    x.max(lower).min(upper)
}

#[test]
fn test_projected_gradient_descent() {
    let mut x = 0.0; // ì´ˆê¸°ê°’
    let alpha = 0.1; // í•™ìŠµë¥ 
    let tol = 1e-6;
    let max_iter = 100;

    for _ in 0..max_iter {
        let grad = grad_f(x);
        let new_x = x - alpha * grad;
        let projected_x = project(new_x, 0.0, 2.0);

        if (projected_x - x).abs() < tol {
            break;
        }

        x = projected_x;
    }

    println!("Projected minimum at x = {:.6}, f(x) = {:.6}", x, f(x));
    assert!((x - 2.0).abs() < 1e-6); // ì œì•½ ë•Œë¬¸ì— x=2ì—ì„œ ë©ˆì¶¤
}
```

```
Projected minimum at x = 2.000000, f(x) = 2.000000
```


## âœï¸ ìš”ì•½

| í•­ëª©         | ë‚´ìš©                                      |
|--------------|-------------------------------------------|
| $f(x)$   | $(x - 3)^2 + 1$                        |
| ì œì•½ ì¡°ê±´     | $x \in [0, 2]$                         |
| ê¸°ìš¸ê¸°        | $\nabla f(x) = 2(x - 3)$               |
| íˆ¬ì˜ ì—°ì‚°     | $\Pi_{[0,2]}(x) = \min(\max(x, 0), 2)$ |
| ìˆ˜ë ´ì         | $x = 2,\ f(2) = 2$                     |


---


