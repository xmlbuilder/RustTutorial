## ì„ í˜• ìœ ë¦¬ ë³€í™˜
- ì´ í•¨ìˆ˜ëŠ” NURBS ì»¤ë¸Œë¥¼ ì„ í˜• ìœ ë¦¬ í•¨ìˆ˜(linear rational function) ë¡œ  
    ìž¬ë§¤ê°œë³€ìˆ˜í™”(reparametrization)í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜.

## ðŸ”¥ 1. ë¬¸ì œ ì •ì˜: ì»¤ë¸Œ ìž¬ë§¤ê°œë³€ìˆ˜í™”ëž€?
- ì›ëž˜ ì»¤ë¸ŒëŠ” ë§¤ê°œë³€ìˆ˜ u ë¡œ ì •ì˜ë˜ì–´ ìžˆì–´:
```math
C(u)=\frac{\sum _iN_{i,p}(u)\, w_i\, P_i}{\sum _iN_{i,p}(u)\, w_i}
```
- ì—¬ê¸°ì„œ ë§¤ê°œë³€ìˆ˜ u ë¥¼ ìƒˆë¡œìš´ ë§¤ê°œë³€ìˆ˜ s ë¡œ ë°”ê¾¸ê³  ì‹¶ë‹¤.
- ê·¸ ë³€í™˜ì´ ë°”ë¡œ:
```math
s=g(u)=\frac{\alpha u+\beta }{\gamma u+\delta }
```
- ì´ê±¸ ì„ í˜• ìœ ë¦¬ í•¨ìˆ˜(linear fractional transform) ë¼ê³  í•œë‹¤.
- ì´ ë³€í™˜ì„ ì ìš©í•˜ë©´:
    - knot vectorë„ ë°”ë€Œê³ 
    - control pointì˜ weightë„ ë°”ë€Œê³ 
    - ê²°ê³¼ëŠ” ì¼ë°˜ì ìœ¼ë¡œ ìœ ë¦¬ NURBSê°€ ëœë‹¤.

## ðŸ”¥ 2. ë³€í™˜ì´ ìœ íš¨í•˜ë ¤ë©´ í•„ìš”í•œ ì¡°ê±´
- ì›ë³¸ ì½”ë“œì˜ ì¡°ê±´ì„ ìˆ˜ì‹ìœ¼ë¡œ ì •ë¦¬í•˜ë©´:
- (1) ë³€í™˜ì´ ë‹¨ì‚¬(ì¼ëŒ€ì¼)ì—¬ì•¼ í•œë‹¤
```math
\alpha \delta -\beta \gamma >0
```
- ì´ê±´ ì„ í˜• ìœ ë¦¬ í•¨ìˆ˜ì˜ Jacobianì´ ì–‘ìˆ˜ë¼ëŠ” ëœ».
- ì¦‰, ë§¤ê°œë³€ìˆ˜ ë°©í–¥ì´ ë’¤ì§‘ížˆì§€ ì•ŠëŠ”ë‹¤.

- (2) ë¶„ëª¨ê°€ 0ì´ ë˜ë©´ ì•ˆ ëœë‹¤
```math
\gamma u+\delta \neq 0
```
- ëª¨ë“  knot u ì— ëŒ€í•´ ë¶„ëª¨ê°€ 0ì´ë©´ ë³€í™˜ ë¶ˆê°€ëŠ¥.

- (3) weight ì—…ë°ì´íŠ¸ì—ì„œ ë“±ìž¥í•˜ëŠ” í•­ì´ 0ì´ë©´ ì•ˆ ëœë‹¤
```math
\gamma s-\alpha \neq 0
```
- ì´ê±´ ë‚˜ì¤‘ì— weightë¥¼ ì—…ë°ì´íŠ¸í•  ë•Œ í•„ìš”í•œ ì¡°ê±´ì´ë‹¤.

## ðŸ”¥ 3. Knot ë³€í™˜ ìˆ˜ì‹
- ì›ëž˜ knot vectorê°€:
```math
U=\{ u_0,u_1,\dots ,u_m\} 
```
- ì´ë¼ë©´, ìƒˆ knot vectorëŠ”:
```math
s_i=g(u_i)=\frac{\alpha u_i+\beta }{\gamma u_i+\delta }
```
- ì¦‰, ëª¨ë“  knotì— ëŒ€í•´ ë™ì¼í•œ ë³€í™˜ì„ ì ìš©í•œë‹¤.
- ì½”ë“œ ë¶€ë¶„:
```rust
uq[i] = (alf * up[i] + bet) / (gam * up[i] + del);
```


## ðŸ”¥ 4. Control point ë³€í™˜ì˜ í•µì‹¬ ì›ë¦¬
- ì´ ë¶€ë¶„ì´ ê°€ìž¥ ì¤‘ìš”í•˜ë‹¤.
### 4.1 ê¸°ì¡´ control pointëŠ” homogeneous ì¢Œí‘œ
```math
P_i^h=(w_ix_i,w_iy_i,w_iz_i,w_i)
```

## 4.2 ë¨¼ì € dehomogenize (w=1ë¡œ ë§Œë“¤ê¸°)
```math
(x_i,y_i,z_i,1)
```
- ì½”ë“œ:
```rust
cur_q.ctrl[i].x *= inv;
cur_q.ctrl[i].y *= inv;
cur_q.ctrl[i].z *= inv;
cur_q.ctrl[i].w = 1.0;
```
### 4.3 ìƒˆ weight ê³„ì‚°
- ì´ê²Œ ì´ ì•Œê³ ë¦¬ì¦˜ì˜ í•µì‹¬ ê³µì‹ì´ë‹¤.
```math
w_i'=w_i\cdot \prod _{j=1}^p|\gamma s_{i+j}-\alpha |
```
- ì—¬ê¸°ì„œ:
    - p = degree
    - $s_{i+j}$ = ìƒˆ knot vectorì˜ ê°’
    - ì ˆëŒ“ê°’ì„ ì·¨í•˜ëŠ” ì´ìœ ëŠ” orientation ë³´ì¡´ ë•Œë¬¸
- ì½”ë“œ:
```rust
for j in 1..=p {
    let t = gam * uq[i + j] - alf;
    fact *= t.abs();
}
w_new = w_old[i] * fact;
```


### 4.4 ë‹¤ì‹œ homogeneousë¡œ ìŠ¤ì¼€ì¼
```math
P_i'^h=(w_i'x_i,w_i'y_i,w_i'z_i,w_i')
```
- ì½”ë“œ:
```rust
cur_q.ctrl[i].x *= w_new;
cur_q.ctrl[i].y *= w_new;
cur_q.ctrl[i].z *= w_new;
cur_q.ctrl[i].w *= w_new;
```


## ðŸ”¥ 5. ì™œ weightê°€ ì´ë ‡ê²Œ ë³€í•˜ëŠ”ê°€? (ìˆ˜ì‹ì  ê·¼ê±°)
- ì„ í˜• ìœ ë¦¬ ë§¤ê°œë³€ìˆ˜ ë³€í™˜ì€ B-spline basisì— ë‹¤ìŒ ë³€í™˜ì„ ìœ ë„í•œë‹¤:
```math
N_{i,p}(u)=N_{i,p}(g^{-1}(s))\cdot |g'(g^{-1}(s))|
```
- ì—¬ê¸°ì„œ:
```math
g'(u)=\frac{\alpha \delta -\beta \gamma }{(\gamma u+\delta )^2}
```
- ì´ ë¯¸ë¶„í•­ì´ basis functionì— ê³±í•´ì§€ê¸° ë•Œë¬¸ì—  
    ê²°êµ­ control pointì˜ weightì— ì˜í–¥ì„ ì¤€ë‹¤.
- ê·¸ ê²°ê³¼ê°€:
```math
w_i'=w_i\cdot \prod _{j=1}^p|\gamma s_{i+j}-\alpha |
```
- ì´ ê³µì‹ì´ë‹¤.

## ðŸ”¥ 6. Domain ì—…ë°ì´íŠ¸
- ìƒˆ domainì€ clamped knot vector ê¸°ì¤€:
```math
[\mathrm{new\_ umin},\mathrm{new\_ umax}]=[UQ[p],UQ[n+1]]
```
- ì½”ë“œ:
```rust
let umin = cur_q.kv.knots[p];
let umax = cur_q.kv.knots[n + 1];
cur_q.domain = Interval::new(umin, umax);
```


## ðŸ”¥ 7. ì „ì²´ ì•Œê³ ë¦¬ì¦˜ íë¦„ ìš”ì•½
- ì•„ì£¼ ê°„ë‹¨í•˜ê²Œ ì •ë¦¬í•˜ë©´:

- âœ” Step 1: ì„ í˜• ìœ ë¦¬ ë³€í™˜ì˜ ìœ íš¨ì„± ê²€ì‚¬
```math
\alpha \delta -\beta \gamma >0
```
- âœ” Step 2: ìƒˆ knot vector ê³„ì‚°
```math
s_i=\frac{\alpha u_i+\beta }{\gamma u_i+\delta }
```
- âœ” Step 3: control point dehomogenize
```math
(x_i,y_i,z_i,1)
```
- âœ” Step 4: ìƒˆ weight ê³„ì‚°
```math
w_i'=w_i\cdot \prod _{j=1}^p|\gamma s_{i+j}-\alpha |
```
- âœ” Step 5: ë‹¤ì‹œ homogeneousë¡œ ë³€í™˜
```math
P_i'^h=(w_i'x_i,w_i'y_i,w_i'z_i,w_i')
```
- âœ” Step 6: domain ì—…ë°ì´íŠ¸

## ðŸ”¥ 8. ì´ í•¨ìˆ˜ê°€ ì‹¤ì œë¡œ í•˜ëŠ” ì¼ (í•œ ì¤„ ìš”ì•½)
- ì»¤ë¸Œì˜ ë§¤ê°œë³€ìˆ˜ uë¥¼ ì„ í˜• ìœ ë¦¬ í•¨ìˆ˜ë¡œ ë³€í™˜í•˜ë©´ì„œ  
    knot vectorì™€ control point weightë¥¼ ì •í™•ížˆ ìž¬ê³„ì‚°í•˜ì—¬  
    ë™ì¼í•œ ê¸°í•˜ë¥¼ ìœ ì§€í•˜ëŠ” ìƒˆë¡œìš´ NURBS ì»¤ë¸Œë¥¼ ë§Œë“ ë‹¤.

---

## ðŸ”¥ 1. ì™œ â€œë‹¨ìˆœ u ë²”ìœ„ ë³€ê²½â€ì€ ì»¤ë¸Œë¥¼ ë°”ê¾¸ì§€ ì•ŠëŠ”ê°€?
- ë‹¨ìˆœí•œ affine ë³€í™˜:
```math
s=au+b\quad (a>0)
```
- ì´ ê²½ìš°ëŠ” basis functionì˜ í˜•íƒœê°€ ê·¸ëŒ€ë¡œ ìœ ì§€ëœë‹¤.
- ì™œëƒí•˜ë©´ B-spline basisëŠ” ë‹¤ìŒ ì„±ì§ˆì„ ê°–ê¸° ë•Œë¬¸ì´ì•¼:
```math
N_{i,p}(u)=N_{i,p}(au+b)\quad \mathrm{(ë‹¨,\  knotë„\  ë™ì¼í•˜ê²Œ\  affine\  ë³€í™˜)}
```
- ì¦‰:
    - knot vectorë¥¼ ë™ì¼í•œ affine ë³€í™˜ìœ¼ë¡œ ë°”ê¾¸ë©´
    - basis functionì˜ ëª¨ì–‘ì´ ê·¸ëŒ€ë¡œ ìœ ì§€ë˜ê³ 
    - control pointëŠ” ê·¸ëŒ€ë¡œ ë‘¬ë„
    - ê³¡ì„ ì˜ ê¸°í•˜(shape)ëŠ” 100% ë™ì¼

- ì¦‰ : **u ë²”ìœ„ë¥¼ 0â†’1ì—ì„œ 0â†’2Ï€ë¡œ ë°”ê¿”ë„ ì»¤ë¸ŒëŠ” ì•ˆ ë°”ë€Œê³  ì†ë„ë§Œ ë°”ë€ë‹¤**
    - âœ” knot vectorëŠ” ë°”ë€ë‹¤
    - âœ” control pointëŠ” ê·¸ëŒ€ë¡œ
    - âœ” shapeëŠ” ê·¸ëŒ€ë¡œ
    - âœ” ì†ë„/ê°€ì†ë„ëŠ” ë°”ë€œ

## ðŸ”¥ 2. ê·¸ëŸ°ë° ì´ë²ˆ í•¨ìˆ˜ëŠ” affineì´ ì•„ë‹ˆë¼ MÃ¶bius ë³€í™˜ì´ë‹¤
- ì´ë²ˆ í•¨ìˆ˜ëŠ”:
```math
s=\frac{\alpha u+\beta }{\gamma u+\delta }
```
- ì´ê±´ ì„ í˜• ìœ ë¦¬ í•¨ìˆ˜(MÃ¶bius transform) ì´ê³ , affine ë³€í™˜ë³´ë‹¤ í›¨ì”¬ ê°•ë ¥í•œ ë³€í™˜.
    - ì´ ë³€í™˜ì€ ë‹¤ìŒ íŠ¹ì§•ì„ ê°€ì§„ë‹¤:
    - ë¶„ëª¨ê°€ ìžˆë‹¤
    - ë¯¸ë¶„í•­ì´ ìƒìˆ˜ê°€ ì•„ë‹ˆë‹¤
    - basis functionì— ë‹¨ìˆœížˆ **ìŠ¤ì¼€ì¼** ë¡œ í¡ìˆ˜ë˜ì§€ ì•ŠëŠ”ë‹¤
    - B-spline ê³µê°„ì„ ê·¸ëŒ€ë¡œ ë³´ì¡´í•˜ì§€ ì•ŠëŠ”ë‹¤
- ì¦‰: knotë§Œ ë°”ê¿”ì„œëŠ” ë™ì¼í•œ ê³¡ì„ ì„ ìœ ì§€í•  ìˆ˜ ì—†ë‹¤.
- ê·¸ëž˜ì„œ control pointì˜ weightë¥¼ ì¡°ì •í•´ì•¼ í•œë‹¤.

## ðŸ”¥ 3. ì™œ MÃ¶bius ë³€í™˜ì€ control pointê¹Œì§€ ë°”ê¿”ì•¼ í•˜ëŠ”ê°€?
- ì›ëž˜ NURBSëŠ”:
```math
C(u)=\frac{\sum _iN_{i,p}(u)w_iP_i}{\sum _iN_{i,p}(u)w_i}
```
- ì—¬ê¸°ì„œ uë¥¼ së¡œ ë°”ê¾¸ë©´:
```math
C(u(s))=\frac{\sum _iN_{i,p}(u(s))w_iP_i}{\sum _iN_{i,p}(u(s))w_i}
```
- ë¬¸ì œëŠ”:
```math
N_{i,p}(u(s))
```
- ì´ê²Œ ìƒˆë¡œìš´ knot vectorì—ì„œì˜ B-spline basisë¡œ ê¹”ë”í•˜ê²Œ í‘œí˜„ë˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì .
- Affine ë³€í™˜ì´ë©´ ê°€ëŠ¥í•˜ì§€ë§Œ MÃ¶bius ë³€í™˜ì€ ë¶ˆê°€ëŠ¥.
- ê·¸ëž˜ì„œ ì›ë³¸ C ì•Œê³ ë¦¬ì¦˜ì€ ì´ë ‡ê²Œ í•œë‹¤:
- âœ” basis functionì˜ ë³€í™”ëŸ‰ì„ weightì— í¡ìˆ˜í•œë‹¤
- ì¦‰:
```math
w_i'=w_i\cdot \prod _{j=1}^p|\gamma s_{i+j}-\alpha |
```
- ì´ weight ë³´ì •ì´ ìžˆì–´ì•¼ ìƒˆë¡œìš´ basis ê³µê°„ì—ì„œ ë™ì¼í•œ 3D ê³¡ì„ ì„ ìž¬í˜„í•  ìˆ˜ ìžˆë‹¤.

## ðŸ”¥ 4. ì´ í•¨ìˆ˜ê°€ í•˜ëŠ” ì¼ì€ â€œê¸°í•˜ ë³´ì¡´ ìž¬ë§¤ê°œë³€ìˆ˜í™”â€
- ì •í™•ížˆ ë§í•˜ë©´:
- ê³¡ì„ ì˜ ê¸°í•˜ëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€í•˜ë©´ì„œ ìƒˆë¡œìš´ íŒŒë¼ë¯¸í„° sì— ë§žëŠ” NURBS í‘œí˜„ì„ ìž¬êµ¬ì„±í•˜ëŠ” ê²ƒ

- ì¦‰:
    - knot vector â†’ MÃ¶bius ë³€í™˜
    - control point â†’ weight ë³´ì •
    - homogeneous ì¢Œí‘œ â†’ ë‹¤ì‹œ êµ¬ì„±
    - domain â†’ ì—…ë°ì´íŠ¸
    - shape â†’ ë™ì¼

## ðŸ”¥ 5. â€œì™œ ë‹¨ìˆœ u ë³€ê²½ê³¼ ë‹¤ë¥´ê²Œ CPê¹Œì§€ ë°”ê¾¸ëŠ”ê°€?â€ë¥¼ í•œ ì¤„ë¡œ ì •ë¦¬í•˜ë©´
- âœ” ë‹¨ìˆœ affine ë³€í™˜
```math
s=au+b
```
- basis functionì´ ê·¸ëŒ€ë¡œ
- knotë§Œ ë°”ê¾¸ë©´ ë¨
- CPëŠ” ê·¸ëŒ€ë¡œ
- shape ê·¸ëŒ€ë¡œ

- âœ” MÃ¶bius ë³€í™˜
```math
s=\frac{\alpha u+\beta }{\gamma u+\delta }
```
- basis functionì´ ë°”ë€œ
- knotë§Œ ë°”ê¾¸ë©´ shapeê°€ ë‹¬ë¼ì§
- CP weightë¥¼ ë³´ì •í•´ì•¼ shape ìœ ì§€
- ê²°ê³¼ëŠ” rational NURBSê°€ ë¨

## ðŸ”¥ 6. ì‹¤ë¬´ì ìœ¼ë¡œ ì¤‘ìš”í•œ í¬ì¸íŠ¸

- âœ” gam == 0 
    - affine ë³€í™˜
- ì´ ê²½ìš°ëŠ” ì‚¬ì‹¤ìƒ:
```math
s=\frac{\alpha u+\beta }{\delta }
```
- ì¦‰:
```math
s=au+b
```
- ì´ë¯€ë¡œ:
    - knotë§Œ ë°”ê¾¸ë©´ ì¶©ë¶„
    - CP/weightëŠ” ê±´ë“œë¦´ í•„ìš” ì—†ìŒ
    - non-rationalì´ë©´ ê·¸ëŒ€ë¡œ ìœ ì§€ ê°€ëŠ¥
- âœ” gam != 0 
    - MÃ¶bius ë³€í™˜
- weight ë³´ì • í•„ìˆ˜
- CPë„ ë°”ë€œ
- non-rationalë„ rationalë¡œ ë³€í•¨
- shapeëŠ” ë™ì¼

# MÃ¶bius
- MÃ¶bius scalingì€ â€œê³¡ì„ ì„ ë°”ê¾¸ëŠ” ë„êµ¬â€ê°€ ì•„ë‹ˆë¼  
    **ìˆ˜ì¹˜í•´ì„ì„ ì•ˆì •í™”í•˜ê¸° ìœ„í•œ íŒŒë¼ë¯¸í„° ê³µê°„ ì¡°ìž‘ ë„êµ¬** ë‹¤.


## 1. MÃ¶bius ìž¬íŒŒë¼ë¯¸í„°í™”ê°€ í•˜ëŠ” ì¼ì˜ ë³¸ì§ˆ
- MÃ¶bius ë³€í™˜:
```math
s=\frac{\alpha u+\beta }{\gamma u+\delta }
```
- ì´ê±´ íŒŒë¼ë¯¸í„° ì¶•(uì¶•)ì„ ë¹„ì„ í˜•ìœ¼ë¡œ íœ˜ê²Œ ë§Œë“œëŠ” ìž‘ì—….
    - ê³¡ì„ ì˜ 3D ëª¨ì–‘ì€ ê·¸ëŒ€ë¡œ ìœ ì§€í•˜ë ¤ê³  í•œë‹¤.
    - ëŒ€ì‹  **ì–´ë””ì— íŒŒë¼ë¯¸í„°ë¥¼ ë” ì´˜ì´˜ížˆ ì“¸ì§€ / ëœ ì“¸ì§€** ë¥¼ ê°•í•˜ê²Œ ì¡°ì ˆí•œë‹¤.
    - ì¦‰, íŒŒë¼ë¯¸í„° ë°€ë„(distribution)ë¥¼ ìž¬ë°°ì¹˜í•˜ëŠ” ë„êµ¬ë‹¤.
- ê·¸ëž˜ì„œ ì´ê±´:
    - ê¸°í•˜ë¥¼ ë°”ê¾¸ë ¤ëŠ” ê²Œ ì•„ë‹ˆë¼
    - ìˆ˜ì¹˜í•´ì„(ë‰´í„´, íŠ¸ë ˆì´ì‹±, ì˜¤í”„ì…‹, í•„ë › ë“±)ì„ ë§ì¹˜ì§€ ì•Šê¸° ìœ„í•œ íŒŒë¼ë¯¸í„° ê³µê°„ì˜ ìž¬ì¡°ì •ì´ë‹¤.

## 2. ì™œ ì´ëŸ° ê²Œ í•„ìš”í•˜ëƒ? (ì‹¤ì œ CAD ì»¤ë„ ê´€ì )
### 2-1. Intersection / Tracing ê³„ì—´
- ë¬¸ì œ ìƒí™©:
    - ê³¡ì„ â€“ê³¡ë©´, ê³¡ë©´â€“ê³¡ë©´ êµì°¨ì—ì„œ
    - ë‰´í„´ + íŠ¸ë ˆì´ì‹±ì„ í•  ë•Œ,
- ì–´ë–¤ êµ¬ê°„ì€:
    - uëŠ” ê±°ì˜ ì•ˆ ë³€í•˜ëŠ”ë° 3D ì ì€ í™• íŠ€ê³ ,
    - ì–´ë–¤ êµ¬ê°„ì€ uëŠ” ë§Žì´ ì›€ì§ì´ëŠ”ë° 3D ë³€í™”ëŠ” ê±°ì˜ ì—†ìŒ.
- ì´ë•Œ:
- uë¥¼ ì„ í˜•ìœ¼ë¡œ ì“°ë©´:
    - ë‰´í„´ ìŠ¤í…ì´ íŠ€ê±°ë‚˜,
    - ì§€ë‚˜ì¹˜ê²Œ ìž‘ì€ ìŠ¤í…ìœ¼ë¡œë§Œ ì›€ì§ì´ê²Œ ë¨.
    - ê³¡ì„ ì„ ìž˜ë¼ì„œ ì„¸ê·¸ë¨¼íŠ¸ë¡œ ë‚˜ëˆ„ë©´:
    - í† í´ë¡œì§€ ê´€ë¦¬, ë°ì´í„° êµ¬ì¡°, í›„ì²˜ë¦¬ê°€ ë³µìž¡í•´ì§.
- ê·¸ëž˜ì„œ:
ê³¡ì„ ì„ ìžë¥´ì§€ ì•Šê³ , **íŒŒë¼ë¯¸í„° ì¶•ë§Œ íœ˜ì–´ì„œ**  
    ë‰´í„´/íŠ¸ë ˆì´ì‹±ì„ ì•ˆì •í™”ì‹œí‚¤ëŠ” ë„êµ¬ê°€ í•„ìš”í•˜ë‹¤.
- ê·¸ê²Œ MÃ¶bius scaling.

### 2-2. Offset / Fillet / Blend
- ë¬¸ì œ ìƒí™©:
    - ì˜¤í”„ì…‹/í•„ë › ê³¡ì„ ì€ ë³´í†µ:
    - í•œìª½ì€ ê³¡ë¥ ì´ í¬ê³ (ë¯¼ê°),
    - ë‹¤ë¥¸ ìª½ì€ ê±°ì˜ ì§ì„ (ë‘”ê°).
    - íŒŒë¼ë¯¸í„°ë¥¼ ì„ í˜•ìœ¼ë¡œ ì“°ë©´:
    - ê³¡ë¥  í° ìª½ì—ì„œ ì˜¤ì°¨ê°€ ì»¤ì§€ê³ ,
    - ë‰´í„´ ë³´ì •ì´ ë¶ˆì•ˆì •í•´ì§.
- MÃ¶bius scalingìœ¼ë¡œ:
    - ê³¡ë¥  í° ìª½ì— íŒŒë¼ë¯¸í„°ë¥¼ ëª°ì•„ì£¼ê³ ,
    - ê³¡ë¥  ìž‘ì€ ìª½ì€ ëŠìŠ¨í•˜ê²Œ ì“´ë‹¤.
- ê²°ê³¼:
    - ìƒ˜í”Œ ìˆ˜ë¥¼ ëŠ˜ë¦¬ì§€ ì•Šê³ ë„ ì•ˆì •ì„± í–¥ìƒ.
    - ê³¡ì„ ì„ ìª¼ê°œì§€ ì•Šê³ ë„ ìˆ˜ì¹˜ì ìœ¼ë¡œ ìž˜ ë²„í‹´ë‹¤.

### 2-3. ê·¹ì  / íŠ¹ì´ì (singularity) ì£¼ë³€
- ì˜ˆ:
    - ì›ì¶” apex
    - íšŒì „ì²´ì˜ pole
    - seam ê·¼ì²˜ì˜ trimmed surface
- ì´ëŸ° ê³³ì€:
    - knot/CP ë¶„í• ë¡œ í•´ê²°í•˜ë©´ topologyê°€ ê¹¨ì§€ê³ ,
    - ë‹¨ìˆœ ì„ í˜• reparamì€ íš¨ê³¼ê°€ ê±°ì˜ ì—†ë‹¤.
- MÃ¶bius ë³€í™˜ì€:
    - íŠ¹ì´ì  ê·¼ì²˜ë¥¼ íŒŒë¼ë¯¸í„° ìƒì—ì„œ â€œë¬´í•œëŒ€ ìª½ìœ¼ë¡œ ë°€ì–´ë‚´ëŠ”â€ íš¨ê³¼ë¥¼ ì¤„ ìˆ˜ ìžˆë‹¤.
    - ì‹¤ì œ ê³„ì‚°ì€ ìœ í•œí•œ êµ¬ê°„ì—ì„œ ìˆ˜í–‰í•˜ë©´ì„œ,  
        íŠ¹ì´ì  ê·¼ì²˜ì˜ ìˆ˜ì¹˜ í­ì£¼ë¥¼ ì™„í™”í•œë‹¤.
- ì´ê²Œ ë§ ê·¸ëŒ€ë¡œ â€œsingularity desingularizationâ€ ìš©ë„ë‹¤.

## 3. ì™œ ë‹¨ìˆœ knot scalingìœ¼ë¡œëŠ” ì•ˆ ë˜ë‚˜?
- í•µì‹¬ë§Œ ë‹¤ì‹œ ì •ë¦¬í•˜ë©´:
- ì„ í˜• scaling (affine):
    - íŒŒë¼ë¯¸í„° ë°€ë„ëŠ” ì—¬ì „ížˆ â€œê· ì¼â€
    - knotë§Œ ë°”ê¾¸ë©´ ë˜ê³ , CPëŠ” ê·¸ëŒ€ë¡œ
    - ê¸°í•˜ ìœ ì§€, êµ¬í˜„ ê°„ë‹¨
- MÃ¶bius scaling:
    - íŒŒë¼ë¯¸í„° ë°€ë„ë¥¼ ë¹„ê· ì¼í•˜ê²Œ ê°•í•˜ê²Œ ì¡°ì ˆ ê°€ëŠ¥
    - knotë§Œ ë°”ê¿”ì„œëŠ” ì•ˆ ë˜ê³ , weight/CPê¹Œì§€ ì¡°ì •í•´ì•¼
    - ê¸°í•˜ ìœ ì§€, êµ¬í˜„ ë³µìž¡í•˜ì§€ë§Œ íš¨ê³¼ ê°•ë ¥
- ì¦‰:
    - **ê³¡ì„ ì„ ê·¸ëŒ€ë¡œ ë‘ê³ , íŒŒë¼ë¯¸í„°ë§Œ ë¹„ì„ í˜•ìœ¼ë¡œ íœ˜ê²Œ** í•˜ëŠ” ìœ ì¼í•˜ê²Œ  
    ê°•ë ¥í•œ ë„êµ¬ê°€ MÃ¶bius scalingì´ë‹¤.


## 4. ì™œ í•­ìƒ Rationalì´ ë˜ëŠ”ê°€?
- ì´ê±´ ì•„ì£¼ ì¤‘ìš”í•œ í¬ì¸íŠ¸.
    - MÃ¶bius ë³€í™˜ì€ ìœ ë¦¬í•¨ìˆ˜ë‹¤.
    - polynomial B-spline basisì— ê·¸ëŒ€ë¡œ í•©ì„±í•˜ë©´:
    - ë” ì´ìƒ polynomialì´ ì•„ë‹ˆë‹¤.
    - rational í˜•íƒœê°€ ëœë‹¤.
- ê·¸ëž˜ì„œ:
    - ê¸°ì¡´ì´ non-rational B-splineì´ì–´ë„,
    - MÃ¶bius ìž¬íŒŒë¼ë¯¸í„°í™”ë¥¼ ì ìš©í•˜ë©´
    - ë°˜ë“œì‹œ rational NURBSê°€ ëœë‹¤.
- ì¦‰:
    - **ê¸°í•˜ë¥¼ ìœ ì§€í•˜ê¸° ìœ„í•´ ì–´ì©” ìˆ˜ ì—†ì´ rationalë¡œ ë§Œë“ ë‹¤.**


## 5. ì–¸ì œ ì“°ë©´ ì•ˆ ë˜ëŠ”ê°€? (ì‹¤ë¬´ì—ì„œ ì¤‘ìš”í•œ ê²½ê³„ì„ )
- MÃ¶bius scalingì€ ê°•ë ¥í•˜ì§€ë§Œ, ì•„ë¬´ ë°ë‚˜ ì“°ë©´ ì•ˆ ë˜ëŠ” ë„êµ¬ë‹¤.
- âŒ ì“°ì§€ ë§ì•„ì•¼ í•  ê³³:
    - ë‹¨ìˆœ UI íŒŒë¼ë¯¸í„° ë§¤í•‘ (ì˜ˆ: ìŠ¬ë¼ì´ë” 0T)
    - ì• ë‹ˆë©”ì´ì…˜ ì‹œê°„ ìŠ¤ì¼€ì¼
    - arc-length reparam (ì´ê±´ ì ë¶„ ê¸°ë°˜ìœ¼ë¡œ ë”°ë¡œ í•´ì•¼ í•¨)
    - mesh tessellation ì „ì²˜ë¦¬
- ì´ëŸ° ë°ì„œ ì“°ë©´:
    - ë¶ˆí•„ìš”í•˜ê²Œ rational ê³¡ì„ ì´ ëŠ˜ì–´ë‚˜ê³ ,
    - ì´í›„ knot/degree ì—°ì‚°ì´ ë¬´ê±°ì›Œì§€ê³ ,
    - ì»¤ë„ ì „ì²´ê°€ ì ì  **rational ì§€ì˜¥** ìœ¼ë¡œ ê°„ë‹¤.

## 6. ì‹¤ì „ì—ì„œì˜ íŒë‹¨ ê¸°ì¤€
- ì´ í•œ ì¤„ì´ ë˜ê²Œ ì¤‘ìš”í•˜ë‹¤:
    - **ê³¡ì„ ì„ ìžë¥´ì§€ ì•Šê³ , Newton/traceë¥¼ ì•ˆì •í™”í•´ì•¼ í•˜ëŠ”ê°€?**
    - YES â†’ MÃ¶bius scaling ê³ ë ¤
    - NO â†’ ì„ í˜• reparam ë˜ëŠ” knot ì¡°ì •, í˜¹ì€ ê·¸ëƒ¥ ì•ˆ í•¨
- ì¦‰, MÃ¶bius scalingì€:
    - **ìµœì¢… ë°ì´í„° êµ¬ì¡°ë¥¼ ë°”ê¾¸ê¸° ìœ„í•œ ë„êµ¬** ê°€ ì•„ë‹ˆë¼
    - **ìˆ˜ì¹˜í•´ì„ì„ ì•ˆì •í™”í•˜ê¸° ìœ„í•œ ìž„ì‹œ íŒŒë¼ë¯¸í„° ì¡°ìž‘ ë„êµ¬**ì— ê°€ê¹ë‹¤.
- ì‹¤ì œ ì»¤ë„ì—ì„œëŠ”:
    - ë‚´ë¶€ ê³„ì‚° ì¤‘ì—ë§Œ MÃ¶bius scalingì„ ì ìš©í•˜ê³ ,
- ìµœì¢… ê²°ê³¼ curveë¥¼ ì €ìž¥í•  ë•ŒëŠ”:
    - scalingì„ ë˜ëŒë¦¬ê±°ë‚˜,
    - ì •ë§ í•„ìš”í•  ë•Œë§Œ ì ìš©ëœ ìƒíƒœë¡œ ë‚¨ê¸´ë‹¤.

## 7. ì½”ë“œ ë§¥ë½ì—ì„œ ë”± ë§žëŠ” ìžë¦¬
- MÃ¶bius scalingì€ ì´ëŸ° ê³³ì— ìž˜ ë“¤ì–´ê°„ë‹¤:
    - ON_FindInitialSeedPoint
    - TraceIntersectionCurve
    - Project3DToUV + Newton
    - Fillet center ì°¾ê¸°
    - Offset curve refine
- ì¦‰:
    - **í•´ì„/ì¶”ì /ë³´ì • ê³¼ì •ì—ì„œ, íŒŒë¼ë¯¸í„° ì¶•ì„ ìž ê¹ ë¹„í‹€ì–´ì„œ ìˆ˜ì¹˜ì ìœ¼ë¡œ íŽ¸í•˜ê²Œ ë§Œë“œëŠ” ë„êµ¬**

---
## ì†ŒìŠ¤ ì½”ë“œ
```rust
///
///   s = g(u) = (alf*u + bet) / (gam*u + del)
///
/// ê°€ì •:
///   (1) alf*del - bet*gam > 0
///   (2) gam*u + del != 0   (ëª¨ë“  knot uì— ëŒ€í•´)
///   (3) gam*s - alf != 0   (ì‹¤ì œë¡œëŠ” ì•„ëž˜ weight factorì— ë“±ìž¥í•˜ëŠ” (gam*s - alf) í•­ì´ 0ì´ ë˜ë©´ ì•ˆ ë¨)
///
/// í•µì‹¬ ë™ìž‘:
/// - knot: u -> s ë¡œ ë³€í™˜í•˜ì—¬ ìƒˆ knot vector ìƒì„±
/// - control points: ê¸°ì¡´ homogeneous(cp = (w*x, w*y, w*z, w))ì—ì„œ
///   1) dehomogenize (ë‚˜ëˆ ì„œ w=1ë¡œ ë§Œë“  ë’¤)
///   2) ìƒˆ weight = old_w * Î _{j=1..p} |gam*UQ[i+j] - alf|
///   3) homogeneousë¡œ ë‹¤ì‹œ ìŠ¤ì¼€ì¼ (xyz,w ëª¨ë‘ ìƒˆ weightë¡œ ê³±)
///
/// ì£¼ì˜:
/// - ìž…ë ¥ì´ ë¹„ìœ ë¦¬(curve non-rational)ë¼ë„ ë‚´ë¶€ì ìœ¼ë¡œ w=1 ìœ ë¦¬ë¡œ ë§Œë“¤ì–´ ì²˜ë¦¬í•˜ë©°,
///   ê²°ê³¼ëŠ” ë³´í†µ ìœ ë¦¬ ê³¡ì„ ì´ ë©ë‹ˆë‹¤(ê°€ì¤‘ì¹˜ê°€ ë°”ë€œ).
pub fn on_curve_reparam_linear_rational(
    cur_p: &NurbsCurve,
    alf: Real,
    bet: Real,
    gam: Real,
    del: Real,
    cur_q: &mut NurbsCurve,
) -> Result<()> {
    // ---- check coefficients (alf*del - bet*gam > PTOL) ----
    let det = alf * del - bet * gam;
    if det <= ON_TOL12 {
        return Err(NurbsError::InvalidArgument {
            msg: "on_curve_reparam_linear_rational: invalid coefficients (alf*del-bet*gam <= tol)".into(),
        });
    }

    // ---- basic shape checks ----
    if cur_p.ctrl.is_empty() {
        return Err(NurbsError::InvalidArgument {
            msg: "on_curve_reparam_linear_rational: cur_p.ctrl is empty".into(),
        });
    }
    if cur_p.kv.knots.is_empty() {
        return Err(NurbsError::InvalidArgument {
            msg: "on_curve_reparam_linear_rational: cur_p.kv is empty".into(),
        });
    }

    let p = cur_p.degree as usize;
    let n = cur_p.ctrl.len() - 1;
    let m = cur_p.kv.knots.len() - 1;

    // m = n + p + 1  (ì—¬ê¸°ì„œëŠ” "highest index" ê¸°ë°˜)
    if m != n + p + 1 {
        return Err(NurbsError::InvalidArgument {
            msg: format!(
                "on_curve_reparam_linear_rational: invalid sizes (m={}, n={}, p={})",
                m, n, p
            ),
        });
    }

    // ---- prepare output as a copy of input  ----
    *cur_q = cur_p.clone();

    // ---- new knots: UQ[i] = (alf*UP[i]+bet)/(gam*UP[i]+del) ----
    {
        let up = &cur_p.kv.knots;
        let uq = &mut cur_q.kv.knots;

        for i in 0..=m {
            let num = alf * up[i] + bet;
            let den = gam * up[i] + del;
            if den.abs() <= ON_ZERO_TOL {
                return Err(NurbsError::InvalidArgument {
                    msg: "on_curve_reparam_linear_rational: division by zero in knot map (gam*u+del == 0)".into(),
                });
            }
            uq[i] = num / den;
        }
    }

    // ---- extract old weights, dehomogenize output ctrl to w=1 ----
    let mut w_old: Vec<Real> = Vec::with_capacity(n + 1);
    for i in 0..=n {
        let w = cur_q.ctrl[i].w;
        if w.abs() <= ON_ZERO_TOL {
            return Err(NurbsError::InvalidArgument {
                msg: "on_curve_reparam_linear_rational: zero weight encountered in input control point".into(),
            });
        }
        w_old.push(w);

        // dehomogenize: (w*x, w*y, w*z, w) -> (x, y, z, 1)
        let inv = 1.0 / w;
        cur_q.ctrl[i].x *= inv;
        cur_q.ctrl[i].y *= inv;
        cur_q.ctrl[i].z *= inv;
        cur_q.ctrl[i].w = 1.0;
    }

    // ---- apply new weights: w[i] = old_w[i] * Î _{j=1..p} |gam*UQ[i+j] - alf| ----
    {
        let uq = &cur_q.kv.knots;

        for i in 0..=n {
            let mut fact = 1.0 as Real;

            // product_{j=1..p} (gam*UQ[i+j] - alf)
             for j in 1..=p {
                let t = gam * uq[i + j] - alf;
                if t.abs() <= ON_ZERO_TOL {
                    return Err(NurbsError::InvalidArgument {
                        msg: "on_curve_reparam_linear_rational: invalid factor (gam*s-alf == 0) in weight update".into(),
                    });
                }
                fact *= t;
            }
            fact = fact.abs();

            let w_new = w_old[i] * fact;

            // homogeneous ìž¬êµ¬ì„±: (x,y,z,1) -> (w*x, w*y, w*z, w)
            cur_q.ctrl[i].x *= w_new;
            cur_q.ctrl[i].y *= w_new;
            cur_q.ctrl[i].z *= w_new;
            cur_q.ctrl[i].w *= w_new; // 1.0 * w_new
        }
    }

    // ---- update domain from (clamped) knot endpoints ----
    let umin = cur_q.kv.knots[p];
    let umax = cur_q.kv.knots[n + 1];
    cur_q.domain = Interval::new(umin, umax);

    Ok(())
}

/// In-place convenience wrapper
pub fn on_curve_reparam_linear_rational_in_place(
    cur: &mut NurbsCurve,
    alf: Real,
    bet: Real,
    gam: Real,
    del: Real,
) -> Result<()> {
    let src = cur.clone();
    on_curve_reparam_linear_rational(&src, alf, bet, gam, del, cur)
}
```
---
