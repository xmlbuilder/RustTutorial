# 5차 베지어 고석

## 1. 5차 베지어 곡선과 제어점 표현
- 제어점이 6개이므로, 차수는 5입니다.
- 제어점들을 호모지니어스 4D로

$$
P_0,P_1,P_2,P_3,P_4,P_5\in \mathbb{R^{\mathnormal{4}}}
$$

- 라 두고, 각 제어점은

$$
P_i=(x_i,y_i,z_i,w_i)
$$

- 형태입니다.
- 5차 베지어 곡선의 호모지니어스 표현은

$$
\mathbf{C_{\mathnormal{h}}}(u)=\sum _{i=0}^5B_{i,5}(u)\, P_i,\quad u\in [0,1]
$$

- 여기서 $B_{i,5}(u)$ 는 5차 Bernstein 다항식입니다.

$$
B_{i,5}(u)={5 \choose i}(1-u)^{5-i}u^i
$$

- 코드의 on_bezier5_eval_point 안에서 바로 이걸 계산하고 있음:

```rust
let v = 1.0 - u;

let b0 = v.powi(5);
let b1 = 5.0 * u * v.powi(4);
let b2 = 10.0 * u.powi(2) * v.powi(3);
let b3 = 10.0 * u.powi(3) * v.powi(2);
let b4 = 5.0 * u.powi(4) * v;
let b5 = u.powi(5);
```

- 즉

$$
\begin{aligned}B_{0,5}(u)&=(1-u)^5\end{aligned}
$$

$$
\begin{aligned}B_{1,5}(u)&=5u(1-u)^4\end{aligned}
$$

$$
\begin{aligned}B_{2,5}(u)&=10u^2(1-u)^3\end{aligned}
$$

$$
\begin{aligned}B_{3,5}(u)&=10u^3(1-u)^2\end{aligned}
$$

$$
\begin{aligned}B_{4,5}(u)&=5u^4(1-u)\end{aligned}
$$

$$
\begin{aligned}B_{5,5}(u)&=u^5\end{aligned}
$$

- 입니다.
- 그리고 호모지니어스 좌표 합성은

$$
\begin{aligned}h_x(u)&=\sum _{i=0}^5x_iB_{i,5}(u)\end{aligned}
$$

$$
\begin{aligned}h_y(u)&=\sum _{i=0}^5y_iB_{i,5}(u)\end{aligned}
$$

$$
\begin{aligned}h_z(u)&=\sum _{i=0}^5z_iB_{i,5}(u)\end{aligned}
$$

$$
\begin{aligned}h_w(u)&=\sum _{i=0}^5w_iB_{i,5}(u)\end{aligned}
$$

- 이걸 코드에서 그대로 계산한 것이 아래 부분입니다:

```rust
let hx = cp[0].x * b0 + cp[1].x * b1 + ... + cp[5].x * b5;
...
let hw = cp[0].w * b0 + cp[1].w * b1 + ... + cp[5].w * b5;
```


## 2. 호모지니어스 → 3D 디호모지니제이션
- 실제 3D 점은 호모지니어스 좌표를 w로 나누어 얻습니다.

$$
\mathbf{C}(u)=\left( \frac{h_x(u)}{h_w(u)},\quad \frac{h_y(u)}{h_w(u)},\quad \frac{h_z(u)}{h_w(u)}\right) .
$$

- 코드:
```rust
if hw.abs() < 1e-300 {
    return Point3D::new(0.0, 0.0, 0.0);
}
Point3D::new(hx / hw, hy / hw, hz / hw)
```

- 즉, 호모지니어스 4D에서 한 번 계산해 놓고 마지막에 디호모지니제이션 하는 구조입니다.

## 3. de Casteljau 알고리즘과 5차 곡선 분할
- on_bezier5_subdivide_homogenous는 de Casteljau 알고리즘으로 5차 베지어 곡선을 파라미터 t에서 둘로 나누는 함수입니다.

### 3.1 de Casteljau의 기본 아이디어
- 제어점 $P_0,\dots ,P_5$ 에 대해, 파라미터 $t\in [0,1]$ 에서 새로운 점들을 반복 선형보간으로 만듭니다.
- 1단계:

$$
Q_i=(1-t)P_i+tP_{i+1},\quad i=0,\dots ,4
$$

- 2단계:

$$
R_i=(1-t)Q_i+tQ_{i+1},\quad i=0,\dots ,3
$$

- 3단계:

$$
S_i=(1-t)R_i+tR_{i+1},\quad i=0,\dots ,2
$$

- 4단계:

$$
U_i=(1-t)S_i+tS_{i+1},\quad i=0,\dots ,1
$$

- 5단계:

$$
V_0=(1-t)U_0+tU_1
$$

- 여기서 V_0가 곡선 위의 점 $\mathbf{C_{\mathnormal{h}}}(t)$ 입니다.
- 코드에서:

```rust
let q0 = lerp(p0, p1, t);
...
let r0 = lerp(q0, q1, t);
...
let s0 = lerp(r0, r1, t);
...
let u0 = lerp(s0, s1, t);
...
let v0 = lerp(u0, u1, t); // point on curve at t
```

- 이게 바로 위 수식을 그대로 구현한 것입니다.

### 3.2 분할 후 왼쪽/오른쪽 곡선의 제어점
de Casteljau 알고리즘은 **값 평가** 뿐 아니라 원래 곡선을 정확히 재현하는 두 개의 서브 베지어 곡선의 제어점도 동시에 만들어줍니다.
- 왼쪽 곡선의 제어점:

$$
\mathrm{left}=[P_0,\; Q_0,\; R_0,\; S_0,\; U_0,\; V_0]
$$

- 오른쪽 곡선의 제어점:

$$
\mathrm{right}=[V_0,\; U_1,\; S_2,\; R_3,\; Q_4,\; P_5]
$$

- 코드:

```rust
let left = [p0, q0, r0, s0, u0, v0];
let right = [v0, u1, s2, r3, q4, p5];
```

- 이렇게 하면 원래 곡선을 $[0,t]$, $[t,1]$ 두 구간으로 정확히 나눈 것과 같습니다.

## 4. 구간 [a, b]만 떼어내는 수식 (on_bezier5_extract_homogenous)
- 이 함수는 원래 곡선 $\mathbf{C_{\mathnormal{h}}}(u),u\in [0,1]$ 에서
- 서브 곡선 $\mathbf{C_{\mathnormal{h}}}(u)의 u\in [a,b]$ 구간만 새로운 베지어로 추출하는 역할입니다.
### 4.1 아이디어를 수식으로 쓰면
- 원래 곡선을

$$
\mathbf{C_{\mathnormal{h}}}(u),\quad u\in [0,1]
$$

- 라고 할 때, 서브 곡선 를 새 베지어 곡선으로 다시 표현하는 작업입니다.
### 4.2 코드에서의 두 번 분할 절차
- 먼저 u=a에서 한 번 분할:

그래서:
```rust
let ( _l1, r1 ) = on_bezier5_subdivide_homogenous(cp, a);
```
- 여기서 r1은 파라미터 축으로 [a,1]에 해당하는 부분 곡선의 제어점입니다.
- 이제 r1에서 다시 u=b에 해당하는 지점을 기준으로 잘라야 하는데, r1의 파라미터는 이미 축이 $[a,1]$ 로 축소되어 있으니,
- 새로운 파라미터 t_2는

$$
t_2=\frac{b-a}{1-a}
$$

- 입니다.
- 이건 **원래 u=b가 r1 의 구간 $[a,1]$ 에서 몇 퍼센트 지점인가?** 를 나타내는 값입니다.
```rust
let t2 = (b - a) / (1.0 - a);
let ( l2, _r2 ) = on_bezier5_subdivide_homogenous(&r1, t2);
```

- 여기서 l2는 곡선의 구간 [a,b]에 해당하는 베지어 곡선의 제어점이고, 최종 반환값입니다.
- 정리하면:
  - l2가 표현하는 곡선 $\tilde {C}는 C^{(1)}의 [0,t_2]$ 구간을 다시 $[0,1]$ 로 리매핑한 것입니다:

$$
\tilde {C}(\tilde {u})=C^{(1)}(t_2\tilde {u}),\quad \tilde {u}\in [0,1].
$$

- 이고,  입니다.

## 5. 곡선 위의 점과 타겟 점 사이 거리 최소화
- bezier5_find_param_by_distance_min는 타겟 점 $P\in \mathbb{R^{\mathnormal{3}}}$ 에 대해 거리 제곱
  - $g(u)=\| \mathbf{C}(u)-P\| ^2$ 을 최소로 만드는 를 찾는 함수입니다.

### 5.1 최적화 문제 수식

- 여기서 $\mathbf{C}(u)$ 는 앞에서 디호모지니제이션한 3D 베지어 곡선입니다.
- 거리 제곱을 쓰는 이유:
  - $\| \mathbf{C}(u)-P\| ^2$ 와 $\| \mathbf{C}(u)-P\|$ 는 최소값을 만드는 u가 같음.
  - 제곱을 쓰면 루트를 피할 수 있어 계산이 더 간단.
### 5.2 1단계: coarse 샘플링으로 초기 후보 찾기
- 코드에서:
```rust
let n = 200;
for i in 0..=n {
    let u = (i as f64) / (n as f64);
    let p = on_bezier5_eval_point(cp, u);
    let g = p.distance_square(&target);
    ...
}
```

- 이는 [0,1] 구간을 200등분한 샘플에서 가장 작은 g(u)를 가진 u를 찾는 과정입니다.
- 수식으로는

$$
u_k=\frac{k}{n},\quad k=0,\dots ,n
$$

$$
g_k=g(u_k)
$$

$$
\hat {u}=\arg \min _kg_k
$$

- 이 $\hat {u}$ 를 초기 추정 값으로 쓰고, 그 주변에서 더 정밀하게 1D 최소화를 수행합니다.

### 5.3 2단계: Brent 방법을 이용한 1D 최소화
- 브렌트 방법(Brent’s method)은 **파라볼라 보간 + 황금 분할** 을 섞은 1D 최소화 알고리즘입니다.
- 코드는 이 고전 알고리즘을 거의 그대로 Rust로 옮긴 형태.
- 최적화할 함수는

$$
f(u)=g(u)=\| \mathbf{C}(u)-P\| ^2
$$

- 이고,
- 매 반복마다 새로운 u를 선택해서 on_bezier5_eval_point(cp, u)로 $\mathbf{C}(u)$ 를 평가하고,  
  distance_square로 f(u)를 계산합니다.

- 브렌트 알고리즘 수식 골격은 대략 이렇게 정리할 수 있습니다:
  - 초기 구간 $[a,b]$ 에서 시작, 내부점 x,w,v와 그 함수값 f(x),f(w),f(v) 저장.
  - 반복하면서
  - 포물선 보간(parabolic interpolation) 후보 $u_{\mathrm{parabola}}$ 를 만들고,
  - 그게 조건을 만족하면 사용, 아니면
  - 황금분할 스텝(golden-section) 으로 구간을 줄입니다.
- 수렴 조건:

$$
|x-m|\leq 2\cdot \mathrm{tol1}-\frac{b-a}{2}
$$

- 같은 기준을 충족하면 반복 종료.
- 코드 중 핵심 부분:

```rust
for _ in 0..80 {
    let m = 0.5 * (a + b);
    let tol1 = tol * x.abs() + 1e-15;
    let tol2 = 2.0 * tol1;

    if (x - m).abs() <= (tol2 - 0.5 * (b - a)) {
        break;
    }

    // 포물선 보간을 위한 p, q, r 계산 ...
    // 조건 안되면 황금분할 스텝
    ...
    let u = x + step;
    let fu = on_bezier5_eval_point(cp, u).distance_square(&target);
    // f(u)와 f(x), f(w), f(v) 비교하며 [a,b] 업데이트
}
```

- 마지막에
```rust
x.clamp(0.0, 1.0)
```
으로 를 [0,1] 안으로 다시 한 번 보정합니다.

## 6. 전체 흐름을 한 번에 정리
- 수식 기반으로 전체 로직을 간단히 적어보면:
- 곡선 정의 (호모지니어스 베지어)

$$
\mathbf{C_{\mathnormal{h}}}(u)=\sum _{i=0}^5B_{i,5}(u)\, P_i
$$

- 디호모지니제이션

$$
\mathbf{C}(u)=\left( \frac{h_x(u)}{h_w(u)},\frac{h_y(u)}{h_w(u)},\frac{h_z(u)}{h_w(u)}\right) 
$$


- 곡선 분할 (de Casteljau)

- 중간 점들 $Q_i,R_i,S_i,U_i,V_0$ 를 선형 보간으로 생성
- 왼쪽/오른쪽 제어점 배열로 분할
  - 서브 곡선 추출 $[a,b]$
- u=a에서 분할 → 오른쪽 곡선이 $[a,1]$
  - 그 위에서  에서 분할 → 왼쪽 곡선이 $[a,b]$
- 최단 거리 파라미터 찾기
  - 함수 $f(u)=\| \mathbf{C}(u)-P\| ^2$ 최소화
  - coarse 샘플링으로 좋은 초기값 $\hat {u}$ 찾기
  - $\hat {u}$ 근처의 $[a,b]$ 에서 브렌트 1D 최소화 수행
- 결과  리턴

---

## 수식
```rust
fn on_bezier5_subdivide_homogenous(cp: &[Point4D; 6], t: f64) -> ([Point4D; 6], [Point4D; 6]) {
    // de Casteljau in homogeneous 4D
    let lerp = |a: Point4D, b: Point4D, t: f64| -> Point4D {
        Point4D::new(
            a.x + (b.x - a.x) * t,
            a.y + (b.y - a.y) * t,
            a.z + (b.z - a.z) * t,
            a.w + (b.w - a.w) * t,
        )
    };

    let p0 = cp[0];
    let p1 = cp[1];
    let p2 = cp[2];
    let p3 = cp[3];
    let p4 = cp[4];
    let p5 = cp[5];

    let q0 = lerp(p0, p1, t);
    let q1 = lerp(p1, p2, t);
    let q2 = lerp(p2, p3, t);
    let q3 = lerp(p3, p4, t);
    let q4 = lerp(p4, p5, t);

    let r0 = lerp(q0, q1, t);
    let r1 = lerp(q1, q2, t);
    let r2 = lerp(q2, q3, t);
    let r3 = lerp(q3, q4, t);

    let s0 = lerp(r0, r1, t);
    let s1 = lerp(r1, r2, t);
    let s2 = lerp(r2, r3, t);

    let u0 = lerp(s0, s1, t);
    let u1 = lerp(s1, s2, t);

    let v0 = lerp(u0, u1, t); // point on curve at t

    let left = [p0, q0, r0, s0, u0, v0];
    let right = [v0, u1, s2, r3, q4, p5];
    (left, right)
}
```
```rust
fn on_bezier5_extract_homogenous(cp: &[Point4D; 6], a: f64, b: f64) -> [Point4D; 6] {
    // Extract [a,b] from Bezier using two subdivisions:
    // 1) split at a => take right
    // 2) split that right at t=(b-a)/(1-a) => take left
    if b <= a {
        return *cp; // caller should avoid seam case; keep safe no-op
    }
    let a = a.clamp(0.0, 1.0);
    let b = b.clamp(0.0, 1.0);
    if (b - a) < 1e-15 {
        return *cp;
    }

    let ( _l1, r1 ) = on_bezier5_subdivide_homogenous(cp, a);
    let t2 = (b - a) / (1.0 - a);
    let ( l2, _r2 ) = on_bezier5_subdivide_homogenous(&r1, t2);
    l2
}
```
```rust
fn on_bezier5_eval_point(cp: &[Point4D; 6], u: f64) -> Point3D {
    // Bernstein basis for degree 5 in homogeneous then dehom
    let u = u.clamp(0.0, 1.0);
    let v = 1.0 - u;

    let b0 = v.powi(5);
    let b1 = 5.0 * u * v.powi(4);
    let b2 = 10.0 * u.powi(2) * v.powi(3);
    let b3 = 10.0 * u.powi(3) * v.powi(2);
    let b4 = 5.0 * u.powi(4) * v;
    let b5 = u.powi(5);

    let hx = cp[0].x * b0 + cp[1].x * b1 + cp[2].x * b2 + cp[3].x * b3 + cp[4].x * b4 + cp[5].x * b5;
    let hy = cp[0].y * b0 + cp[1].y * b1 + cp[2].y * b2 + cp[3].y * b3 + cp[4].y * b4 + cp[5].y * b5;
    let hz = cp[0].z * b0 + cp[1].z * b1 + cp[2].z * b2 + cp[3].z * b3 + cp[4].z * b4 + cp[5].z * b5;
    let hw = cp[0].w * b0 + cp[1].w * b1 + cp[2].w * b2 + cp[3].w * b3 + cp[4].w * b4 + cp[5].w * b5;

    if hw.abs() < 1e-300 {
        return Point3D::new(0.0, 0.0, 0.0);
    }
    Point3D::new(hx / hw, hy / hw, hz / hw)
}
```
```rust
/// 1D 최소화(브렌트)로 u 찾기: argmin_u ||C(u)-P||^2, u in [0,1]
fn bezier5_find_param_by_distance_min(cp: &[Point4D; 6], target: Point3D) -> f64 {
    // Brent minimization (간단 구현)
    // 안정성 위해 먼저 coarse 샘플로 초기 bracket 잡고, 그 구간에서 Brent
    let n = 200;
    let mut best_u = 0.0;
    let mut best_g = f64::INFINITY;
    for i in 0..=n {
        let u = (i as f64) / (n as f64);
        let p = on_bezier5_eval_point(cp, u);
        let g = p.distance_square(&target);
        if g < best_g {
            best_g = g;
            best_u = u;
        }
    }

    let mut a = (best_u - 1.0 / (n as f64)).max(0.0);
    let mut b = (best_u + 1.0 / (n as f64)).min(1.0);
    if (b - a) < 1e-6 {
        a = (best_u - 0.02).max(0.0);
        b = (best_u + 0.02).min(1.0);
    }

    // Brent parameters
    let tol = 1e-12;
    let c = (3.0 - 5.0_f64.sqrt()) * 0.5;

    let mut x = a + c * (b - a);
    let mut w = x;
    let mut v = x;

    let mut fx = on_bezier5_eval_point(cp, x).distance_square(&target);
    let mut fw = fx;
    let mut fv = fx;

    let mut d = 0.0_f64;
    let mut e = 0.0_f64;

    for _ in 0..80 {
        let m = 0.5 * (a + b);
        let tol1 = tol * x.abs() + 1e-15;
        let tol2 = 2.0 * tol1;

        if (x - m).abs() <= (tol2 - 0.5 * (b - a)) {
            break;
        }

        let mut p = 0.0;
        let mut q = 0.0;
        let mut r = 0.0;

        if e.abs() > tol1 {
            r = (x - w) * (fx - fv);
            q = (x - v) * (fx - fw);
            p = (x - v) * q - (x - w) * r;
            q = 2.0 * (q - r);
            if q > 0.0 { p = -p; }
            q = q.abs();
            let etemp = e;
            e = d;

            if p.abs() < 0.5 * q * etemp && p > q * (a - x) && p < q * (b - x) {
                d = p / q;
            } else {
                e = if x >= m { a - x } else { b - x };
                d = c * e;
            }
        } else {
            e = if x >= m { a - x } else { b - x };
            d = c * e;
        }

        let u = {
            let step = if d.abs() >= tol1 { d } else { if d > 0.0 { tol1 } else { -tol1 } };
            x + step
        };

        let fu = on_bezier5_eval_point(cp, u).distance_square(&target);

        if fu <= fx {
            if u >= x { a = x; } else { b = x; }
            v = w; fv = fw;
            w = x; fw = fx;
            x = u; fx = fu;
        } else {
            if u < x { a = u; } else { b = u; }
            if fu <= fw || (w - x).abs() < 1e-18 {
                v = w; fv = fw;
                w = u; fw = fu;
            } else if fu <= fv || (v - x).abs() < 1e-18 || (v - w).abs() < 1e-18 {
                v = u; fv = fu;
            }
        }
    }
    x.clamp(0.0, 1.0)
}
```
---

## 수식 검증

## 1. 5차 베지어 평가 on_bezier5_eval_point
### 1.1. Bernstein 다항식 검증
- 코드는 다음을 쓰고 있습니다:

$$
\begin{aligned}b_0&=(1-u)^5\end{aligned}
$$

$$
\begin{aligned}b_1&=5u(1-u)^4\end{aligned}
$$

$$
\begin{aligned}b_2&=10u^2(1-u)^3\end{aligned}
$$

$$
\begin{aligned}b_3&=10u^3(1-u)^2\end{aligned}
$$

$$
\begin{aligned}b_4&=5u^4(1-u)\end{aligned}
$$

$$
\begin{aligned}b_5&=u^5\end{aligned}
$$


- 이는 정확히

$$
B_{i,5}(u)={5 \choose i}(1-u)^{5-i}u^i
$$

- 이고, 이로부터

$$
\sum _{i=0}^5B_{i,5}(u)=1
$$

- 이 성립합니다. (Bernstein basis의 기본 성질)
- 따라서 호모지니어스 좌표

$$
h_x(u)=\sum _{i=0}^5x_iB_{i,5}(u),\quad \dots ,\quad h_w(u)=\sum _{i=0}^5w_iB_{i,5}(u)
$$

- 는 정확한 5차 베지어 보간입니다.
### 1.2. 디호모지니제이션
- 3D 점은

$$
C(u)=\left( \frac{h_x(u)}{h_w(u)},\frac{h_y(u)}{h_w(u)},\frac{h_z(u)}{h_w(u)}\right) 
$$

- 으로 정의됩니다.
- 코드는 hw.abs() < 1e-300일 때만 0 벡터로 대응하고, 그 외는 그대로 나누므로,
- 수학적으로는 **호모지니어스 베지어 곡선 → 투영(프로젝티브) 곡선** 정의와 일치합니다.
- ✅ 결론: on_bezier5_eval_point는 정의적으로 정확한 5차 호모지니어스 베지어 평가입니다.

## 2. 분할 on_bezier5_subdivide_homogenous
### 2.1. de Casteljau 알고리즘 자체
- 제어점 $\{ P_0,\dots ,P_5\}$ 와 $t\in [0,1]$ 에서, 코드는 반복 선형보간을 다음과 같이 합니다:

- 이는 정석 de Casteljau 알고리즘입니다.
- 이 알고리즘의 잘 알려진 성질:
- $V_0=C_h(t)$ (곡선 위의 점)
- 생성된 점들로부터 두 개의 베지어 곡선을 구성하면, 원래 곡선을 정확히 $[0,t]$, $[t,1]$ 구간으로 나눈 것과 같습니다.

### 2.2. left / right 제어점 배열이 맞는지
- 알려진 결과:
- 왼쪽 구간 [0,t]의 제어점은

$$
P_0,\  Q_0,\  R_0,\  S_0,\  U_0,\  V_0
$$

- 오른쪽 구간 [t,1]의 제어점은

$$
V_0,\  U_1,\  S_2,\  R_3,\  Q_4,\  P_5
$$

- 입니다.
- 코드:
```rust
let left  = [p0, q0, r0, s0, u0, v0];
let right = [v0, u1, s2, r3, q4, p5];
```
- 구조가 수식과 완전히 일치합니다.
- ✅ 결론: on_bezier5_subdivide_homogenous는 교과서적인 de Casteljau 분할과 정확히 동일합니다.

## 3. 구간 [a,b] 추출 on_bezier5_extract_homogenous
- 이 부분이 수학적으로 가장 헷갈릴 수 있는 곳이라, 식을 정확히 기술.
### 3.1. 우리가 하고 싶은 일
- 원래 곡선:

$$
C_h(u),\quad u\in [0,1].
$$

- 여기서 부분 구간 [a,b]만 잘라서, 새로운 파라미터 $\tilde {u}\in [0,1]$ 에 대해  
  베지어 곡선(제어점 6개)로 다시 표현하고 싶습니다.

### 3.2. 코드의 두 단계 분할과 수식 대응
- 1단계: u=a 에서 분할
```rust
let ( _l1, r1 ) = on_bezier5_subdivide_homogenous(cp, a);
```
- r1은 원래 곡선의 구간 [a,1]을 다시 [0,1]로 리매핑한 베지어입니다.
- 즉, r1이 표현하는 곡선을 $C^{(1)}$ 라 하면:

- 2단계: r1에서 또 분할. 우리는 원래 파라미터 u=b 위치에서 잘라야 합니다.
- r1의 파라미터 s와 원래 u의 관계는:

$$  
u=a+(1-a)s.
$$

- 여기서 u=b가 되는 s=t_2는:

$$
b=a+(1-a)t_2\quad \Rightarrow \quad t_2=\frac{b-a}{1-a}.
$$

- 코드:
```rust
let t2 = (b - a) / (1.0 - a);
let ( l2, _r2 ) = on_bezier5_subdivide_homogenous(&r1, t2);
```
- l2는 $C^{(1)}$ 의 구간 $s\in [0,t_2]$ 을 $[0,1]$ 로 다시 리매핑한 베지어입니다.
- 즉, l2가 표현하는 곡선을 $\tilde {C}_h$ 라 하면:

- 그런데 를 대입하면:
  - 이건 우리가 처음에 “이렇게 되고 싶다”고 정의한 바로 그 식입니다.
- ✅ 결론: on_bezier5_extract_homogenous는  
  수학적으로 정확하게 [a,b] 구간을 재파라미터화한 베지어 제어점을 반환합니다.
- ※ 단, a=1인 극단적 경우엔 분모 1-a=0이 되니, 그 전에 a와 b를 clamp 하고 (b-a) < 1e-15 등으로 방어하는 것도 코드 상 타당합니다.

## 4. 거리 최소화 bezier5_find_param_by_distance_min
- 우리가 풀고 있는 문제는:

$$
\begin{aligned}\mathrm{Minimize\  }&g(u)=\| C(u)-P\| ^2,\\ \mathrm{subject\  to\  }&u\in [0,1].\end{aligned}
$$

- 여기서 C(u)는 위에서 설명한 3D 베지어 곡선, P는 고정된 목표점입니다.
### 4.1. 거리 제곱 사용의 타당성

$$
d(u)=\| C(u)-P\|
$$

- 대신

$$
g(u)=d(u)^2=\| C(u)-P\| ^2
$$

- 를 최소화해도, 최소점 는 같습니다. 이유:
  - $\| \cdot \| \geq 0$ 이고, $x\mapsto x^2$ 는 $x\geq 0$ 에서 단조 증가.
  - 따라서 $d(u_1)<d(u_2)\Longleftrightarrow d(u_1)^2<d(u_2)^2$.
  그래서 거리 제곱을 목적함수로 쓰는 건 수학적으로 완전히 정당합니다.

### 4.2. 1차원 최소화 문제 맞는지
- 매 u마다
  - on_bezier5_eval_point(cp,u)로 $C(u)$ 계산
  - distance_square(&target)로 $\| C(u)-P\| ^2$ 계산
- 따라서 실제로 구현된 함수는

$$
f(u)=g(u)=\| C(u)-P\| ^2
$$

- 이고, Brent 알고리즘은 미분 없이도 1D 최소값을 찾는 알고리즘이므로 수학적 전제와도 잘 맞습니다.

### 4.3. coarse 샘플 + Brent
- 먼저 균일 샘플로 “대략 최소인 u”를 찾고
  - 그 주변의 작은 구간에서 Brent를 돌리는 전략은
  - 전역적으로 복잡한 함수에서도 꽤 안정적인 초기 bracket을 주기 때문에 수학적으로도 합리적입니다.
  - Brent 자체는 수학적으로 잘 연구된 구간 축소 기반 알고리즘이고, 코드도 그 틀을 잘 따르고 있습니다.
- ✅ 결론: bezier5_find_param_by_distance_min는  
  **정의된 목적함수 g(u)=\| C(u)-P\| ^2를 1D에서 최소화한다** 는 수학적 문제 설정과 일치하고,
- coarse 샘플 + Brent 구조도 이론적으로 타당합니다.
- 다만, 브렌트는 **전역 최소** 를 보장하지 않지만, 베지어 + 거리 함수의 성질상 로컬 최소도 실제로는 충분히 유의미하며,  
  coarse 샘플링(200분할)이 전역 근사에 도움을 줍니다.

## 5. 전체적인 수학적 정합성 요약
| 부분                               | 수학적 정합성 요약                                       |
|------------------------------------|----------------------------------------------------------|
| on_bezier5_eval_point              | 5차 Bernstein + 호모지니어스 → 디호모, 정의와 정확히 일치 |
| on_bezier5_subdivide_homogenous    | de Casteljau 분할 공식과 완전히 동일                    |
| on_bezier5_extract_homogenous      | C(a+(b-a)u) 형태로 재파라미터화, 식으로 검증됨          |
| bezier5_find_param_by_distance_min | argmin ||C(u)-P||^2 정의 그대로, Brent로 1D 최소화      |

---



