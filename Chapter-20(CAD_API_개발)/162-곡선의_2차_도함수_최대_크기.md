
## Í≥°ÏÑ†Ïùò 2Ï∞® ÎèÑÌï®ÏàòÏùò ÏµúÎåÄ ÌÅ¨Í∏∞
- NURBS Í≥°ÏÑ†Ïùò **2Ï∞® ÎèÑÌï®ÏàòÏùò ÏµúÎåÄ ÌÅ¨Í∏∞(Í≥°Î•† Í¥ÄÎ†® ÏÉÅÌïú)** ÏùÑ  
    Îπ†Î•¥Í≥† ÏïàÏ†ïÏ†ÅÏúºÎ°ú Ï∂îÏ†ïÌïòÎäî ÌïµÏã¨ ÏïåÍ≥†Î¶¨Ï¶ò.
- CAD Ïª§ÎÑêÏóêÏÑú offset, tolerance control,  
    adaptive subdivision, knot removal ÏïàÏ†ïÏÑ± ÌåêÎã® Îì±Ïóê  
    Î∞òÎìúÏãú ÌïÑÏöîÌïú Í∞í.
- ÏïÑÎûòÎäî ÎÑ§ Ìï®ÏàòÏùò ÏàòÌïôÏ†Å ÏùòÎØ∏, ÏàòÏãù, ÏïåÍ≥†Î¶¨Ï¶ò ÏÑ§Î™Ö, ÌôúÏö©Î≤ï ÏÑ§Î™Ö

## üìò on_estimate_max_second_derivative_bound 
- ÏàòÌïôÏ†Å ÏùòÎØ∏ Î∞è ÌôúÏö© Î¨∏ÏÑú
### 1. Î™©Ï†Å 
- on_estimate_max_second_derivative_bound Ìï®ÏàòÎäî Îã§Ïùå Í∞íÏùÑ Ï∂îÏ†ïÌïúÎã§:
```math
M=\max _{u\in [u_0,u_m]}\| C''(u)\|
``` 
- Ï¶â, Í≥°ÏÑ†Ïùò 2Ï∞® ÎèÑÌï®ÏàòÏùò ÏµúÎåÄ ÌÅ¨Í∏∞(upper bound).
    - C''(u)Îäî Í≥°ÏÑ†Ïùò **Í∞ÄÏÜçÎèÑ Î≤°ÌÑ∞**
    - $\| C''(u)\|$ Îäî Í≥°Î•†Í≥º ÏßÅÏ†ëÏ†ÅÏúºÎ°ú Ïó∞Í¥Ä
    - CADÏóêÏÑú offset, subdivision, tolerance controlÏóê Îß§Ïö∞ Ï§ëÏöî
- Ï†ïÌôïÌïú $\max \| C''(u)\|$  Í≥ÑÏÇ∞ÏùÄ ÎπÑÏã∏ÎØÄÎ°ú,  
    Bezier Ï°∞Í∞Å Îã®ÏúÑÎ°ú ÏÉòÌîåÎßÅÌïòÏó¨ Îπ†Î•¥Í≥† ÏïàÏ†ÑÌïú ÏÉÅÌïúÍ∞íÏùÑ Ï∂îÏ†ïÌïúÎã§.

## 2. ÏàòÌïôÏ†Å Î∞∞Í≤Ω
### 2.1 NURBS Í≥°ÏÑ†Ïùò Bezier Î∂ÑÌï¥
- NURBS Í≥°ÏÑ†ÏùÄ knot vectorÏùò Í∞Å non-zero spanÎßàÎã§ Bezier Ï°∞Í∞ÅÏúºÎ°ú Î∂ÑÌï¥Ìï† Ïàò ÏûàÎã§.
- Í∞Å Ï°∞Í∞ÅÏùÄ:
    - Ï∞®Ïàò p
    - Íµ¨Í∞Ñ [a,b]
    - Bezier ÌòïÌÉúÏùò Ï†úÏñ¥Ï†ê ÏßëÌï© ÏúºÎ°ú ÌëúÌòÑÎêúÎã§.
- Bezier Í≥°ÏÑ†ÏùÄ ÌååÎùºÎØ∏ÌÑ∞ Î≥ÄÌôîÍ∞Ä Îã®Ï°∞Ïù¥ÎØÄÎ°ú,  
    2Ï∞® ÎèÑÌï®ÏàòÏùò ÏµúÎåÄÍ∞íÏùÄ Ï°∞Í∞Å ÎÇ¥Î∂ÄÏóêÏÑú ÏïàÏ†ïÏ†ÅÏúºÎ°ú ÏÉòÌîåÎßÅÌïòÏó¨ Ï∂îÏ†ï Í∞ÄÎä•ÌïòÎã§.

### 2.2 Bezier Í≥°ÏÑ†Ïùò 2Ï∞® ÎèÑÌï®Ïàò
- Ï∞®Ïàò p Bezier Í≥°ÏÑ†Ïùò 2Ï∞® ÎèÑÌï®ÏàòÎäî:
```math
C''(u)=p(p-1)\sum _{i=0}^{p-2}\Delta ^2P_i\, B_{i,p-2}(u)
```
- Ïó¨Í∏∞ÏÑú:
```math
\Delta ^2P_i=P_{i+2}-2P_{i+1}+P_i
```
- Ï¶â, **2Ï∞® Ï∞®Î∂Ñ(second difference)** Ïù¥ 2Ï∞® ÎèÑÌï®ÏàòÏùò ÌïµÏã¨.
- ÌäπÌûà quadratic(2Ï∞®) BezierÏóêÏÑúÎäî:
```math
C''(u)=2(P_2-2P_1+P_0)
```
- Ï¶â, ÏÉÅÏàòÏù¥Îã§.

### 2.3 ÏÉòÌîåÎßÅ ÏßÄÏ†ê ÏÑ†ÌÉù
- Bezier Ï°∞Í∞ÅÏùò ÌååÎùºÎØ∏ÌÑ∞ Íµ¨Í∞Ñ [a,b]ÏóêÏÑú:
```math
u_k=a+\frac{k}{p}(b-a),\quad k=0,1,\dots ,p
```
- Ï¶â, Í∑†Îì± Î∂ÑÌï†Îêú p+1Í∞úÏùò ÎÖ∏Îìú.
- Ïù¥ ÏßÄÏ†êÎì§ÏùÄ:
    - Bezier basisÏùò Î≥ÄÌôîÍ∞Ä Í∞ÄÏû• ÌÅ∞ ÏßÄÏ†ê
    - 2Ï∞® ÎèÑÌï®ÏàòÏùò Í∑πÍ∞íÏù¥ ÎÇòÌÉÄÎÇ† Í∞ÄÎä•ÏÑ±Ïù¥ ÎÜíÏùÄ ÏßÄÏ†ê
    - Í≥ÑÏÇ∞ ÎπÑÏö©Ïù¥ Îß§Ïö∞ ÎÇÆÏùå
- Îî∞ÎùºÏÑú Ïù¥ ÏÉòÌîåÎßÅÏùÄ ÏïàÏ†ÑÌïú upper boundÎ•º Ï†úÍ≥µÌïúÎã§.

## 3. ÏïåÍ≥†Î¶¨Ï¶ò ÏÑ§Î™Ö
- Ìï®ÏàòÏùò ÌïµÏã¨ Îã®Í≥ÑÎäî Îã§ÏùåÍ≥º Í∞ôÎã§.

### Step 1. ÏûÖÎ†• Í≤ÄÏ¶ù
- Í≥°ÏÑ†Ïù¥ Ïú†Ìö®ÌïúÏßÄ Í≤ÄÏÇ¨
- Ï∞®ÏàòÍ∞Ä 2 ÎØ∏ÎßåÏù¥Î©¥ 2Ï∞® ÎèÑÌï®ÏàòÎäî 0 ‚Üí Î∞îÎ°ú Î∞òÌôò

### Step 2. Bezier Ï°∞Í∞Å Î∂ÑÌï¥
```rust
let pieces = cur.decompose_into_bezier_pieces_with_no_refined()?;
```
- knot refinement ÏóÜÏù¥ Ï°∞Í∞ÅÏùÑ Î∂ÑÌï¥
- Í∞Å Ï°∞Í∞ÅÏùÄ clamped Bezier ÌòïÌÉú

### Step 3. Í∞Å Ï°∞Í∞ÅÏóêÏÑú ÏÉòÌîåÎßÅ
- Ï°∞Í∞ÅÏùò knot:
    - [a, a, ..., a, b, b, ..., b]  (p+1Í∞úÏî©)

### ÏÉòÌîåÎßÅ ÏßÄÏ†ê:
```math
u_k=a+\frac{k}{p}(b-a)
```
- Îã®, Ï°∞Í∞Å Í≤ΩÍ≥Ñ Ï§ëÎ≥µÏùÑ ÌîºÌïòÍ∏∞ ÏúÑÌï¥:
    - Ï≤´ Ï°∞Í∞ÅÏùÄ k=0..p Î™®Îëê ÏÇ¨Ïö©
    - Ïù¥ÌõÑ Ï°∞Í∞ÅÏùÄ k=1..pÎßå ÏÇ¨Ïö©

### Step 4. 2Ï∞® ÎèÑÌï®Ïàò Í≥ÑÏÇ∞
```rust
let d2 = bez.eval_second_derivative(ua)?;
let muu = d2.length();
```

- Í∞Å ÏÉòÌîåÏóêÏÑú:
```math
m_k=\| C''(u_k)\| 
```
### Step 5. Ï†ÑÏ≤¥ Ï°∞Í∞ÅÏóêÏÑú ÏµúÎåÄÍ∞í Î∞òÌôò
```math
M=\max _{i,k}m_{i,k}
```
## 4. ÌÖåÏä§Ìä∏ ÏºÄÏù¥Ïä§Ïùò ÏàòÌïôÏ†Å ÏùòÎØ∏
- ÌÖåÏä§Ìä∏Îäî quadratic BezierÎ•º ÏÇ¨Ïö©ÌïúÎã§.
- Quadratic Bezier:
```math
C(u)=(1-u)^2P_0+2u(1-u)P_1+u^2P_2
```
- 2Ï∞® ÎèÑÌï®ÏàòÎäî ÏÉÅÏàò:
```math
C''(u)=2(P_2-2P_1+P_0)
```
- Îî∞ÎùºÏÑú:
```math
\| C''(u)\| =\mathrm{constant}
```
- ÌÖåÏä§Ìä∏Îäî Ïù¥ ÏÉÅÏàòÎ•º ÏßÅÏ†ë Í≥ÑÏÇ∞ÌïòÏó¨ Ìï®ÏàòÏùò Í≤∞Í≥ºÏôÄ ÎπÑÍµêÌïúÎã§.

## 5. ÌôúÏö©Î≤ï (Where this is used)
- Ïù¥ Ìï®ÏàòÎäî CAD/NURBS ÏóîÏßÑÏóêÏÑú Îß§Ïö∞ Ï§ëÏöîÌïú Ïó≠Ìï†ÏùÑ ÌïúÎã§.

### 1) Offset Í≥°ÏÑ†Ïùò tolerance Ï†úÏñ¥
- offset Í≥°ÏÑ†Ïùò Ïò§Ï∞®Îäî Îã§ÏùåÍ≥º Í∞ôÏù¥ 2Ï∞® ÎèÑÌï®ÏàòÏóê ÎπÑÎ°ÄÌïúÎã§:
```math
\mathrm{offset\  error}\approx \frac{d^2}{2}\max \| C''(u)\|
``` 
- Îî∞ÎùºÏÑú:
    - offset Í±∞Î¶¨ dÍ∞Ä ÌÅ¥ÏàòÎ°ù
    - Í≥°ÏÑ†Ïùò Í≥°Î•†Ïù¥ ÌÅ¥ÏàòÎ°ù
- Ïò§Ï∞®Í∞Ä Ïª§ÏßÑÎã§.
- Ïù¥ Ìï®ÏàòÎäî offset ÏïåÍ≥†Î¶¨Ï¶òÏóêÏÑú adaptive samplingÏù¥ÎÇò Ïò§Ï∞®  
    Î≥¥Ï†ïÏóê ÏÇ¨Ïö©ÎêúÎã§.

### 2) Adaptive subdivision
- Í≥°ÏÑ†ÏùÑ ÏùºÏ†ï tolerance Ïù¥ÌïòÎ°ú Í∑ºÏÇ¨ÌïòÎ†§Î©¥:
```math
\| C''(u)\| \mathrm{Í∞Ä\  ÌÅ∞\  Íµ¨Í∞ÑÏùÄ\  Îçî\  Ï¥òÏ¥òÌûà\  subdivide}
```

- Ïù¥ Ìï®ÏàòÎäî subdivision ÍπäÏù¥Î•º Í≤∞Ï†ïÌïòÎäî Í∏∞Ï§ÄÏù¥ ÎêúÎã§.

### 3) Knot removal ÏïàÏ†ïÏÑ± ÌåêÎã®
- knot removal Ïãú Ïò§Ï∞® ÏÉÅÌïúÏùÄ:
```math
\mathrm{error}\leq \frac{(b-a)^2}{8}\max \| C''(u)\| 
```
- Îî∞ÎùºÏÑú:
    - 2Ï∞® ÎèÑÌï®Ïàò ÏÉÅÌïúÏù¥ ÌÅ¨Î©¥ knot removalÏù¥ ÏúÑÌóò
    - ÏûëÏúºÎ©¥ ÏïàÏ†ÑÌïòÍ≤å Ï†úÍ±∞ Í∞ÄÎä•
- Ïù¥ Ìï®ÏàòÎäî knot removal ÏïåÍ≥†Î¶¨Ï¶òÏùò ÌïµÏã¨ Íµ¨ÏÑ± ÏöîÏÜåÎã§.

### 4) Í≥°Î•† Í∏∞Î∞ò Î∂ÑÏÑù
- Í≥°Î•†:
```math
\kappa (u)=\frac{\| C'(u)\times C''(u)\| }{\| C'(u)\| ^3}
```
- Îî∞ÎùºÏÑú:
- $\| C''(u)\|$  ÏÉÅÌïúÏùÄ Í≥°Î•† ÏÉÅÌïúÏùò Í∑ºÏÇ¨Ïπò
- Í≥°ÏÑ†Ïùò ‚ÄúÌúòÏñ¥Ïßê Ï†ïÎèÑ‚ÄùÎ•º Îπ†Î•¥Í≤å ÌåêÎã® Í∞ÄÎä•

## 6. ÏöîÏïΩ
| Ìï≠Î™© | ÏÑ§Î™Ö |
|------|------|
| Î™©Ï†Å | Í≥°ÏÑ†Ïùò 2Ï∞® ÎèÑÌï®Ïàò ÏµúÎåÄÍ∞í(upper bound)ÏùÑ Îπ†Î•¥Í≥† ÏïàÏ†ïÏ†ÅÏúºÎ°ú Ï∂îÏ†ï |
| Î∞©Ïãù | Bezier Ï°∞Í∞Å Î∂ÑÌï¥ ÌõÑ Í∞Å Ï°∞Í∞ÅÏóêÏÑú p+1Í∞úÏùò Í∑†Îì± ÎÖ∏Îìú ÏÉòÌîåÎßÅ |
| ÏàòÌïôÏ†Å Í∑ºÍ±∞ | Bezier basisÏùò Í∑πÍ∞íÏù¥ ÎÖ∏Îìú Í∑ºÏ≤òÏóê Ï°¥Ïû¨ÌïòÎØÄÎ°ú ÏÉòÌîåÎßÅÎßåÏúºÎ°ú ÏïàÏ†Ñ

---

## ÏÜåÏä§ ÏΩîÎìú
```rust
/// N_CURBSD (Rust):
/// Computes an upper bound / reasonable approximation of max |C''(u)|
/// by sampling each Bezier segment at knot nodes (endpoints + uniform internal nodes).
///
/// - Decomposes curve into Bezier pieces (without global refinement)
/// - For each piece:
///     u[0]=a, u[p]=b, u[a]=a + a*(b-a)/p for a=1..p-1
///     sample 2nd derivative at those u values
/// - Skip the first node of pieces after the first one (avoid duplicate at shared boundary)
pub fn on_estimate_max_second_derivative_bound(cur: &NurbsCurve) -> Result<Real> {
    if !cur.is_valid() {
        return Err(NurbsError::InvalidInput {
            msg: "estimate_max_second_derivative_bound: invalid curve".into(),
        });
    }

    let p = cur.degree as usize;
    if p < 2 {
        // degree < 2 => second derivative is zero (line) or undefined (degree1)
        return Ok(0.0);
    }

    // N_toocdc equivalent: Bezier pieces (no global refinement)
    let pieces = cur.decompose_into_bezier_pieces_with_no_refined()?;
    if pieces.is_empty() {
        return Ok(0.0);
    }

    let mut duu_max: Real = 0.0;

    for (i_piece, bez) in pieces.iter().enumerate() {
        // Each piece is a Bezier segment represented as clamped NURBS:
        // knots: [a..a] (p+1 times), [b..b] (p+1 times)
        let knots = &bez.kv.knots;

        // For a Bezier piece in this representation:
        // knot count = 2p+2, highest index r = 2p+1
        let r = knots.len().checked_sub(1).ok_or_else(|| NurbsError::InvalidInput {
            msg: "estimate_max_second_derivative_bound: empty knot vector in bezier piece".into(),
        })?;

        // a = U[0], b = U[r]
        let a0 = knots[0];
        let b0 = knots[r];
        if (b0 - a0).abs() <= 0.0 {
            // degenerate span: skip
            continue;
        }

        // ui = (b-a)/p
        let ui = (b0 - a0) / (p as Real);

        // build sample params u[0..=p]
        // u[0]=a, u[p]=b, u[a]=a + a*ui
        let mut u = vec![0.0 as Real; p + 1];
        u[0] = a0;
        u[p] = b0;
        for a in 1..p {
            u[a] = a0 + (a as Real) * ui;
        }

        // al = 0 for first piece, else 1 (skip first node)
        let al = if i_piece == 0 { 0 } else { 1 };

        for a in al..=p {
            let ua = u[a];

            // ---- get 2nd derivative vector at ua ----
            // Option A: if you already have eval_second_derivative(u) -> Option<Point3D/Vector3D>
            // Option B: if you have eval_derivatives(u, 2) -> returns (p, d1, d2)
            //
            // ÏïÑÎûòÎäî "Option A" ÌòïÌÉúÎ°ú ÏûëÏÑ±. ÎÑàÌù¨ Ìï®ÏàòÎ™ÖÏóê ÎßûÍ≤å Ïó∞Í≤∞Ìï¥.
            let d2 = bez.eval_second_derivative(ua).ok_or_else(|| NurbsError::NumericError {
                msg: "estimate_max_second_derivative_bound: eval_second_derivative failed".into(),
            })?;

            let muu = d2.length();

            if muu > duu_max {
                duu_max = muu;
            }
        }
    }

    Ok(duu_max)
}
```
```rust
/// N_TOOCDC: Decompose curve into Bezier pieces (without global knot refinement).
///
/// Returns Bezier segments represented as NurbsCurve objects.
/// Each piece has:
/// - degree = p
/// - ctrl count = p+1
/// - knot count = 2p+2 (clamped): [a..a] (p+1 times), [b..b] (p+1 times)
pub fn decompose_into_bezier_pieces_with_no_refined(&self) -> Result<Vec<NurbsCurve>> {
    if !self.is_valid() {
        return Err(NurbsError::InvalidInput {
            msg: "to_bezier_pieces_no_refine: invalid curve".into(),
        });
    }

    let p = self.degree as usize;
    let pw = &self.ctrl;
    let up = &self.kv.knots;

    // Basic structural checks (similar spirit to U_curbre usage)
    if pw.len() < p + 1 || up.len() < pw.len() + p + 1 {
        // Degenerate curve -> treat as single piece
        return Ok(vec![self.clone()]);
    }

    // number of non-zero spans
    let nsp = self.knot_nonzero_span_count();
    if nsp == 0 {
        return Ok(vec![self.clone()]);
    }

    // Allocate output curves (each will be a Bezier segment represented as NurbsCurve)
    let mut pieces: Vec<NurbsCurve> = Vec::with_capacity(nsp);
    for _ in 0..nsp {
        let ctrl = vec![Point4D::homogeneous(0.0, 0.0, 0.0, 1.0); p + 1];
        let knots = KnotVector { knots: vec![0.0; 2 * p + 2] };
        let mut seg = NurbsCurve::new(self.degree, ctrl, knots)?;
        seg.dimension = self.dimension; // preserve 2D/3D tag
        pieces.push(seg);
    }

    // ---- Initialize first piece ctrl = Pw[0..p] ----
    for i in 0..=p {
        pieces[0].ctrl[i] = pw[i];
    }

    // ---- Loop through knot vector and extract each segment ----
    let m = up.len() - 1; // highest index, as in C
    let mut is_ = p;      // is = p
    let mut ie = p + 1;   // ie = p+1
    let mut iq = 0usize;  // iq starts at 0 for first segment

    // Temporary alpha arrays (size p like C alfs/omas)
    let mut alfs = vec![0.0f64; p];
    let mut omas = vec![0.0f64; p];

    while ie < m {
        // split mutable borrows safely: current piece and optional next piece
        let (left, right) = pieces.split_at_mut(iq + 1);
        let cur = &mut left[iq];


        let qw = &mut cur.ctrl;
        let uq = &mut cur.kv.knots;

        // ---- knot multiplicity at UP[ie] ----
        let i0 = ie;
        while ie < m && up[ie] == up[ie + 1] {
            ie += 1;
        }
        let mlt = ie - i0 + 1;
        let r = p.saturating_sub(mlt);

        // ---- Insert knot locally (alpha blending) ----
        if mlt < p {
            let num = up[ie] - up[is_];
            // for i=p; i>mlt; i-- : fill alpha arrays
            for ii in (mlt + 1..=p).rev() {
                let den = up[is_ + ii] - up[is_];
                let a = if den.abs() <= ON_TOL14 { 0.0 } else { num / den };
                let idx = ii - mlt - 1;
                alfs[idx] = a;
                omas[idx] = 1.0 - a;
            }

            // for i=1..r
            for ins_i in 1..=r {
                let s = mlt + ins_i;
                let save = r - ins_i;

                // for j=p down to s
                for j in (s..=p).rev() {
                    let a = alfs[j - s];
                    let b = omas[j - s];

                    // A_comcpt(a,Qw[j], b,Qw[j-1], &Qw[j])
                    // => Qw[j] = a*Qw[j] + b*Qw[j-1]  (homogeneous blend)
                    qw[j] = Point4D {
                        x: a * qw[j].x + b * qw[j - 1].x,
                        y: a * qw[j].y + b * qw[j - 1].y,
                        z: a * qw[j].z + b * qw[j - 1].z,
                        w: a * qw[j].w + b * qw[j - 1].w,
                    };
                }

                // if (ie < m) NQw[save] = Qw[p]
                if ie < m {
                    if let Some(next) = right.get_mut(0) {
                        next.ctrl[save] = qw[p];
                    }
                }
            }
        }

        // ---- Set Bezier piece knot vector: [UP[is_]..] and [UP[ie]..] clamped ----
        for i in 0..=p {
            uq[i] = up[is_];
            uq[i + p + 1] = up[ie];
        }

        // ---- Segment completed: prepare next piece initial ctrl ----
        if ie < m {
            if let Some(next) = right.get_mut(0) {
                // for i=r..p: NQw[i] = Pw[ie-p+i]
                for i in r..=p {
                    let src = ie - p + i;
                    next.ctrl[i] = pw[src];
                }
            }
        }

        // advance
        is_ = ie;
        ie += 1;
        iq += 1;

        // safety: iq should never exceed nsp-1
        if iq >= nsp {
            break;
        }
    }

    Ok(pieces)
}
```

### ÌÖåÏä§Ìä∏ ÏΩîÎìú
```rust
#[cfg(test)]
mod decompose_tests {

    use nurbslib::core::prelude::{Point3D, Point4D};
    use nurbslib::core::nurbs_curve::NurbsCurve;
    use nurbslib::core::types::Degree;

    fn approx3(a: Point3D, b: Point3D, tol: f64) -> bool {
        (a.x - b.x).abs() <= tol && (a.y - b.y).abs() <= tol && (a.z - b.z).abs() <= tol
    }

    /// uÍ∞Ä Îì§Ïñ¥Í∞ÄÎäî non-zero spanÏùò "ÏàúÎ≤à"(0..nsp-1)ÏùÑ Íµ¨ÌïúÎã§.
    /// (CÏùò N_toocdcÍ∞Ä ÎßåÎìúÎäî Ï°∞Í∞Å ÏàúÏÑúÏôÄ ÎèôÏùº)
    fn span_piece_index(knots: &[f64], p: usize, u: f64) -> usize {
        let m = knots.len() - 1;
        // ÎÇ¥Î∂Ä spanÎì§ÏùÑ ÏàúÏÑúÎåÄÎ°ú ÏÑ∏Î©¥ÏÑú uÍ∞Ä Ìè¨Ìï®Îêú spanÏùÑ Ï∞æÎäîÎã§.
        // span iÎäî [U[i], U[i+1]) (ÎßàÏßÄÎßâÏùÄ Îã´ÌûòÏúºÎ°ú Ï∑®Í∏â)
        let mut idx = 0usize;
        for i in p..(m - p) {
            let a = knots[i];
            let b = knots[i + 1];
            if a == b {
                continue; // zero span
            }
            let in_span = if i + 1 == m - p {
                // ÎßàÏßÄÎßâ spanÏùÄ Ïò§Î•∏Ï™Ω Ìè¨Ìï®
                u >= a && u <= b
            } else {
                u >= a && u < b
            };
            if in_span {
                return idx;
            }
            idx += 1;
        }
        // fallback (uÍ∞Ä ÎÅùÏ†êÏù¥Î©¥ ÎßàÏßÄÎßâ Ï°∞Í∞Å)
        idx.saturating_sub(1)
    }

    #[test]
    fn decompose_piece_count_matches_nonzero_spans() {
        // ÎÇ¥Î∂Ä knotÎ•º ÎßåÎì§Í∏∞ Ïâ¨Ïö¥ Î∞©Î≤ï: clamped uniform curve ÌõÑ
        // knot ÏÇΩÏûÖ/ÏàòÏ†ïÏù¥ Ïù¥ÎØ∏ ÌîÑÎ°úÏ†ùÌä∏Ïóê ÏûàÏúºÎ©¥ Í∑∏Í±∏ Ïì∞Î©¥ Îçî Ï¢ãÏùå.
        // Ïó¨Í∏∞ÏÑ† Í∞ÑÎã®Ìûà "Ïª®Ìä∏Î°§ÏùÑ ÎäòÎ¶∞ clamped uniform"ÏúºÎ°ú spanÏù¥ Ïó¨Îü¨ Í∞ú ÏÉùÍ∏∞Í≤å ÎßåÎì†Îã§.
        let degree = 3usize;
        let ctrl = vec![
            Point4D::homogeneous(0.0, 0.0, 0.0, 1.0),
            Point4D::homogeneous(1.0, 0.2, 0.0, 1.0),
            Point4D::homogeneous(2.0, 0.0, 0.0, 1.0),
            Point4D::homogeneous(3.0, 1.0, 0.0, 1.0),
            Point4D::homogeneous(4.0, 0.0, 0.0, 1.0),
            Point4D::homogeneous(5.0, 0.3, 0.0, 1.0),
            Point4D::homogeneous(6.0, 0.0, 0.0, 1.0),
        ];
        let c = NurbsCurve::from_ctrl_clamped_uniform(degree as Degree, ctrl);
        let nsp = c.knot_nonzero_span_count();
        let pieces = c.decompose_into_bezier_pieces_with_no_refined().unwrap();
        assert_eq!(pieces.len(), nsp);
    }

    #[test]
    fn decompose_bezier_pieces_match_original_evaluation() {
        let degree = 3usize;
        let ctrl = vec![
            Point4D::homogeneous(0.0, 0.0, 0.0, 1.0),
            Point4D::homogeneous(1.0, 0.5, 0.0, 1.0),
            Point4D::homogeneous(2.0, -0.2, 0.0, 1.0),
            Point4D::homogeneous(3.0, 0.8, 0.0, 1.0),
            Point4D::homogeneous(4.0, 0.0, 0.0, 1.0),
            Point4D::homogeneous(5.0, 0.4, 0.0, 1.0),
            Point4D::homogeneous(6.0, 0.0, 0.0, 1.0),
        ];
        let c = NurbsCurve::from_ctrl_clamped_uniform(degree as Degree, ctrl);

        let pieces = c.decompose_into_bezier_pieces_with_no_refined().unwrap();
        let p = c.degree as usize;
        let knots = &c.kv.knots;

        // Ïó¨Îü¨ uÏóêÏÑú ÏõêÎ≥∏Í≥º Ìï¥Îãπ Ï°∞Í∞ÅÏùò ÌèâÍ∞ÄÍ∞Ä ÎèôÏùºÌï¥Ïïº Ìï®
        let us = [0.0, 0.07, 0.12, 0.23, 0.35, 0.49, 0.51, 0.68, 0.77, 0.89, 1.0];
        for &u in &us {
            let pi = span_piece_index(knots, p, u);
            let p0 = c.eval_point(u);
            let p1 = pieces[pi].eval_point(u);
            assert!(
                approx3(p0, p1, 1e-8),
                "mismatch at u={}: orig={:?}, piece[{}]={:?}",
                u, p0, pi, p1
            );
        }
    }
}
```
```rust
use nurbslib::core::prelude::Degree;
use nurbslib::core::geom::{Point4D, Point3D};
use nurbslib::core::knot::KnotVector;
use nurbslib::core::nurbs_curve::{on_estimate_max_second_derivative_bound, NurbsCurve};

#[test]
fn test_estimate_max_second_derivative_bound_quadratic_bezier() {
    // degree 2, single Bezier piece
    // knots: [0,0,0,  2,2,2]  => a=0, b=2
    let degree: Degree = 2;
    let ctrl = vec![
        Point4D::homogeneous(0.0, 0.0, 0.0, 1.0),  // P0
        Point4D::homogeneous(1.0, 1.0, 0.0, 1.0),  // P1
        Point4D::homogeneous(2.0, 0.0, 0.0, 1.0),  // P2
    ];
    let kv = KnotVector { knots: vec![0.0, 0.0, 0.0, 2.0, 2.0, 2.0] };
    let c = NurbsCurve::new(degree, ctrl, kv).unwrap();

    let muu = on_estimate_max_second_derivative_bound(&c).unwrap();

    // expected magnitude:
    // v = 2*(P2 - 2P1 + P0) in Euclidean
    let p0 = Point3D::new(0.0, 0.0, 0.0);
    let p1 = Point3D::new(1.0, 1.0, 0.0);
    let p2 = Point3D::new(2.0, 0.0, 0.0);

    let vx = 2.0 * (p2.x - 2.0*p1.x + p0.x);
    let vy = 2.0 * (p2.y - 2.0*p1.y + p0.y);
    let vz = 2.0 * (p2.z - 2.0*p1.z + p0.z);

    let span = 2.0 - 0.0; // b-a
    let expected = ((vx*vx + vy*vy + vz*vz).sqrt()) / (span*span);

    // Í∑ºÏÇ¨/ÏÉòÌîå Í∏∞Î∞òÏù¥ÏßÄÎßå quadraticÏùÄ ÏÉÅÏàòÎùº Îß§Ïö∞ Ï†ïÌôïÌï¥Ïïº Ìï®
    assert!((muu - expected).abs() <= 1e-9, "muu={}, expected={}", muu, expected);
}
```
---
