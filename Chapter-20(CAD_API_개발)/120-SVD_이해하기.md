# SVD
## ğŸŒŸ SVDê°€ ë­”ì§€ ì´ˆê°„ë‹¨ ì§ê´€ìœ¼ë¡œ ì´í•´í•˜ê¸°
## ğŸ¯ SVDë€?
- ì–´ë–¤ ì•„ë¬´ í–‰ë ¬ì´ë¼ë„

```math
A=U\Sigma V^T
```

- ì´ë ‡ê²Œ ì„¸ ê°œì˜ íŠ¹ë³„í•œ í–‰ë ¬ë¡œ ìª¼ê°œëŠ” ë°©ë²•.
  - U: ì›ë˜ ë°ì´í„°ê°€ ì–´ë–¤ ë°©í–¥ìœ¼ë¡œ í¼ì ¸ ìˆëŠ”ì§€ ë‚˜íƒ€ë‚´ëŠ” íšŒì „(ë˜ëŠ” ë°©í–¥)
  - Î£(ì‹œê·¸ë§ˆ): ë°ì´í„°ê°€ ê° ë°©í–¥ìœ¼ë¡œ ì–¼ë§ˆë‚˜ í¬ê²Œ í¼ì ¸ ìˆëŠ”ì§€ ë‚˜íƒ€ë‚´ëŠ” í¬ê¸°(ìŠ¤ì¼€ì¼)
  - Váµ€: ì›ë˜ ì¢Œí‘œê³„ë¥¼ ì–´ë–¤ ë°©í–¥ìœ¼ë¡œ ëŒë ¤ì•¼ í•˜ëŠ”ì§€ ì•Œë ¤ì£¼ëŠ” íšŒì „
- ì¦‰, íšŒì „ â†’ ëŠ˜ë¦¬ê¸°/ì¤„ì´ê¸° â†’ ë‹¤ì‹œ íšŒì „
- ì´ ì„¸ ë‹¨ê³„ë¡œ ì–´ë–¤ í–‰ë ¬ì´ë“  í‘œí˜„í•  ìˆ˜ ìˆë‹¤ëŠ” ëœ».

## ğŸ• ë¹„ìœ ë¡œ ì´í•´í•˜ê¸°
- í–‰ë ¬ Aë¥¼ í”¼ìë¥¼ ë§Œë“œëŠ” ê³¼ì •ì´ë¼ê³  ìƒê°í•´ë³´ì.
  - Váµ€: ë°˜ì£½ì„ íŠ¹ì • ë°©í–¥ìœ¼ë¡œ ëŒë ¤ì„œ ë†“ê¸°
  - Î£: ë°˜ì£½ì„ ê° ë°©í–¥ìœ¼ë¡œ ë‹¤ë¥´ê²Œ ëŠ˜ë¦¬ê¸°(ê°€ë¡œë¡œ ê¸¸ê²Œ, ì„¸ë¡œë¡œ ì§§ê²Œ ë“±)
  - U: ë§ˆì§€ë§‰ìœ¼ë¡œ ë‹¤ì‹œ ëŒë ¤ì„œ ì›í•˜ëŠ” ëª¨ì–‘ìœ¼ë¡œ ë§Œë“¤ê¸°
- ì´ ì„¸ ë‹¨ê³„ë§Œ ìˆìœ¼ë©´ ì–´ë–¤ ëª¨ì–‘ì˜ í”¼ìë“  ë§Œë“¤ ìˆ˜ ìˆìŒ.
- í–‰ë ¬ë„ ë§ˆì°¬ê°€ì§€ë¡œ, ì–´ë–¤ ë³€í™˜ì´ë“  ì´ ì„¸ ë‹¨ê³„ë¡œ í‘œí˜„ ê°€ëŠ¥.

## ğŸ§  ì™œ SVDê°€ ë“±ì¥í–ˆì„ê¹Œ?
- âœ” ì–´ë–¤ í–‰ë ¬ì´ë“  ë‹¤ ë¶„í•´í•  ìˆ˜ ìˆëŠ” ê°€ì¥ ê°•ë ¥í•œ ë°©ë²•ì´ í•„ìš”í–ˆê¸° ë•Œë¬¸
  - ì—­í–‰ë ¬ì´ ì—†ì–´ë„ ë¨
  - ì •ë°©í–‰ë ¬ì´ ì•„ë‹ˆì–´ë„ ë¨
  - ëŒ€ì¹­ì¼ í•„ìš”ë„ ì—†ìŒ
- ëª¨ë“  í–‰ë ¬ì— ì ìš© ê°€ëŠ¥í•œ ë¶„í•´ë²•ì´ ë°”ë¡œ SVD.

## ğŸ“Œ SVDëŠ” ì–´ë””ì— ì“°ì¼ê¹Œ?
### 1ï¸âƒ£ ì°¨ì› ì¶•ì†Œ (PCA)
- ë°ì´í„°ì—ì„œ ê°€ì¥ ì¤‘ìš”í•œ ë°©í–¥(ì£¼ì„±ë¶„)ì„ ì°¾ëŠ” ë° ì‚¬ìš©
  - ì´ë¯¸ì§€ ì••ì¶•, ë°ì´í„° ë…¸ì´ì¦ˆ ì œê±° ë“±
### 2ï¸âƒ£ ì´ë¯¸ì§€ ì••ì¶•
- ì´ë¯¸ì§€ë¥¼ SVDë¡œ ë¶„í•´í•˜ë©´
  - í° íŠ¹ì´ê°’ë§Œ ë‚¨ê¸°ê³  ì‘ì€ ê±´ ë²„ë ¤ë„ ì›ë³¸ê³¼ ê±°ì˜ ë¹„ìŠ·í•œ ì´ë¯¸ì§€ê°€ ë‚˜ì˜´.
### 3ï¸âƒ£ ì¶”ì²œ ì‹œìŠ¤í…œ (ë„·í”Œë¦­ìŠ¤, ìœ íŠœë¸Œ)
- ì‚¬ìš©ìâ€“ì•„ì´í…œ í–‰ë ¬ì„ SVDë¡œ ë¶„í•´
  - ìˆ¨ê²¨ì§„ ì·¨í–¥ íŒ¨í„´ì„ ì°¾ì•„ ì¶”ì²œ
### 4ï¸âƒ£ ì„ í˜• ë°©ì •ì‹ì˜ ìµœì†Œì œê³± í•´
- í•´ê°€ ì—†ê±°ë‚˜ ë„ˆë¬´ ë§ì€ ê²½ìš°ì—ë„ ê°€ì¥ â€œê·¸ëŸ´ë“¯í•œâ€ í•´ë¥¼ ì°¾ì•„ì¤Œ
### 5ï¸âƒ£ ì‹ í˜¸ ì²˜ë¦¬, ìì—°ì–´ ì²˜ë¦¬, ë¨¸ì‹ ëŸ¬ë‹ ì „ë°˜
- ë°ì´í„° êµ¬ì¡°ë¥¼ ê°€ì¥ ì˜ ì„¤ëª…í•˜ëŠ” ë°©í–¥ì„ ì°¾ëŠ” ë° í•„ìˆ˜

## ğŸ‰ í•œ ì¤„ ìš”ì•½
- SVDëŠ” ì–´ë–¤ í–‰ë ¬ì´ë“  â€˜íšŒì „â€“ëŠ˜ë¦¬ê¸°â€“íšŒì „â€™ìœ¼ë¡œ ë¶„í•´í•˜ëŠ” ë°©ë²•ì´ë©°, ë°ì´í„°ì˜ ì¤‘ìš”í•œ êµ¬ì¡°ë¥¼ íŒŒì•…í•˜ê±°ë‚˜ ì••ì¶•í•˜ëŠ” ë° ë§¤ìš° ìœ ìš©í•œ ë„êµ¬.

---

## ì‹¤ìš© ì ì¸ ì˜ˆ
- ê·¸ë¦¼ì„ â€˜ë§ë¡œ ê·¸ë ¤ì„œâ€™ SVDê°€ ì–´ë–»ê²Œ ìƒê²¼ëŠ”ì§€ ì•„ì£¼ ì§ê´€ì ìœ¼ë¡œ ì„¤ëª….
  - (ì •í™•í•œ ê·¸ë¦¼ íŒŒì¼ì€ ë§Œë“¤ ìˆ˜ ì—†ì§€ë§Œ, ë¨¸ë¦¿ì†ì— ë°”ë¡œ ë– ì˜¤ë¥¼ ì •ë„ë¡œ ì‹œê°ì ìœ¼ë¡œ ì„¤ëª….)

### ğŸ¨ 1. ë¨¼ì €, ì›ì„ í•˜ë‚˜ ê·¸ë ¤ë´„
- ì•„ë˜ì²˜ëŸ¼ ë™ê·¸ë€ ì›ì´ ìˆë‹¤ê³  ìƒìƒ.
```
     *****
   **     **
  *         *
  *         *
   **     **
     *****
```

- ì´ ì›ì€ **ê¸°ë³¸ ì¢Œí‘œê³„ì—ì„œì˜ ë°ì´í„°** ë¼ê³  ìƒê°í•˜ë©´ ë¨.

## ğŸ¨ 2. í–‰ë ¬ Aê°€ ì´ ì›ì„ ì–´ë–»ê²Œ ë°”ê¾¸ëŠ”ì§€ ë´„
- í–‰ë ¬ AëŠ” ì›ì„ íƒ€ì›ìœ¼ë¡œ ë³€í˜•ì‹œí‚¤ëŠ” ì‘ì—…ì´ë¼ê³  ë³´ë©´ ë¨.
- SVDëŠ” ì´ ë³€í˜•ì„ 3ë‹¨ê³„ë¡œ ë‚˜ëˆ ì„œ ì„¤ëª….

### ğŸŒ€ ë‹¨ê³„ 1: Váµ€ â€” ì›ì„ ë¨¼ì € â€˜ëŒë¦°ë‹¤â€™
- (ì›) â†’  â†»  â†’  (ê¸°ìš¸ì–´ì§„ ì›)

- Váµ€ëŠ” ì›ì„ ì–´ë–¤ ê°ë„ë¡œ ëŒë ¤ì„œ
  - â€œë°ì´í„°ê°€ ê°€ì¥ ì˜ í¼ì§€ëŠ” ë°©í–¥â€ê³¼ ì¼ì¹˜ì‹œí‚¤ëŠ” ì—­í• ì„ í•¨.

### ğŸ“ ë‹¨ê³„ 2: Î£ â€” ê°€ë¡œÂ·ì„¸ë¡œë¡œ â€˜ëŠ˜ë¦¬ê¸°/ì¤„ì´ê¸°â€™
- ì´ì œ ê¸°ìš¸ì–´ì§„ ì›ì„ ê°€ë¡œë¡œ ëŠ˜ë¦¬ê³ , ì„¸ë¡œë¡œ ì¤„ì´ë©´ íƒ€ì›ì´ ë¨.
```
(ê¸°ìš¸ì–´ì§„ ì›)
      â†“ ëŠ˜ë¦¬ê¸°/ì¤„ì´ê¸°
(ê¸°ìš¸ì–´ì§„ íƒ€ì›)
```

- Î£(ì‹œê·¸ë§ˆ) ì•ˆì˜ ê°’ë“¤ì´
  - ì–¼ë§ˆë‚˜ ëŠ˜ë¦´ì§€
  - ì–¼ë§ˆë‚˜ ì¤„ì¼ì§€
ê²°ì •í•˜ëŠ” ìˆ«ì.

## ğŸ”„ ë‹¨ê³„ 3: U â€” íƒ€ì›ì„ ë‹¤ì‹œ â€˜ëŒë ¤ì„œâ€™ ìµœì¢… ìœ„ì¹˜ë¡œ
- ë§ˆì§€ë§‰ìœ¼ë¡œ íƒ€ì›ì„ ë‹¤ì‹œ í•œ ë²ˆ ëŒë¦¬ë©´ í–‰ë ¬ Aê°€ ë§Œë“  ìµœì¢… íƒ€ì›.
  - (ê¸°ìš¸ì–´ì§„ íƒ€ì›) â†’ â†» â†’ (ìµœì¢… íƒ€ì›)

## ğŸ¯ ì „ì²´ ê·¸ë¦¼ ìš”ì•½
```
ì›
 â†“ Váµ€ (ì²« ë²ˆì§¸ íšŒì „)
ê¸°ìš¸ì–´ì§„ ì›
 â†“ Î£ (ëŠ˜ë¦¬ê¸°/ì¤„ì´ê¸°)
ê¸°ìš¸ì–´ì§„ íƒ€ì›
 â†“ U (ë‘ ë²ˆì§¸ íšŒì „)
ìµœì¢… íƒ€ì› = Aê°€ ë§Œë“  ê²°ê³¼
```

- ì¦‰, SVDëŠ” ì–´ë–¤ í–‰ë ¬ì´ë“  â€œíšŒì „ â†’ ëŠ˜ë¦¬ê¸° â†’ íšŒì „â€ì˜ ì¡°í•©ìœ¼ë¡œ ì„¤ëª…í•˜ëŠ” ë°©ë²•.

## ğŸŒŸ ì™œ ì´ê²Œ ì§ê´€ì ì¼ê¹Œ?
- ì›ì€ ëŒ€ì¹­ì ì´ë¼ ì–´ë–¤ ë°©í–¥ìœ¼ë¡œ ëŒë ¤ë„ ë˜‘ê°™ìŒ
- ê·¸ë˜ì„œ **íšŒì „ â†’ ëŠ˜ë¦¬ê¸° â†’ íšŒì „** ìœ¼ë¡œ ëª¨ë“  ë³€í˜•ì„ ì„¤ëª…í•  ìˆ˜ ìˆìŒ
- ì´ ê³¼ì •ì—ì„œ **ë°ì´í„°ê°€ ê°€ì¥ ë§ì´ í¼ì§„ ë°©í–¥(íŠ¹ì´ë²¡í„°)** ê³¼ **ê·¸ í¼ì§„ ì •ë„(íŠ¹ì´ê°’)** ê°€ ìì—°ìŠ¤ëŸ½ê²Œ ë“œëŸ¬ë‚¨

---
# Curve Fitting

## ğŸ¯ ì „ì²´ íë¦„ ë¨¼ì € ë³´ê¸°
- Curve fittingì€ ê²°êµ­ ë°ì´í„°ì— ê°€ì¥ ì˜ ë§ëŠ” ê³¡ì„ (ë˜ëŠ” ì§ì„ )ì„ ì°¾ëŠ” ë¬¸ì œ
- ìˆ˜í•™ì ìœ¼ë¡œ í’€ë©´ ì„ í˜• ë°©ì •ì‹ì˜ ìµœì†Œì œê³± ë¬¸ì œê°€ ë¨.

- ê·¸ë¦¬ê³  ìµœì†Œì œê³± ë¬¸ì œë¥¼ ê°€ì¥ ì•ˆì •ì ì´ê³  ì •í™•í•˜ê²Œ í‘¸ëŠ” ë°©ë²•ì´ SVD.

## ğŸ§© 1ë‹¨ê³„: ë°ì´í„°ë¥¼ í–‰ë ¬ë¡œ ë§Œë“ ë‹¤
- ì˜ˆë¥¼ ë“¤ì–´, ì§ì„  $y=ax+b$ ì„ ë°ì´í„°ì— ë§ì¶”ê³  ì‹¶ë‹¤ê³  ê°€ì •.
- ë°ì´í„°ê°€ ì´ë ‡ê²Œ ìˆë‹¤ê³  ê°€ì •:
```
(1, 2)
(2, 3)
(3, 5)
(4, 4)
```

- ì´ê±¸ í–‰ë ¬ë¡œ ë§Œë“¤ë©´:
```
A = [ 1  1 ]
    [ 2  1 ]
    [ 3  1 ]
    [ 4  1 ]
```
```
x = [ a ]
    [ b ]
```
```
y = [ 2 ]
    [ 3 ]
    [ 5 ]
    [ 4 ]
```

- ìš°ë¦¬ê°€ ì›í•˜ëŠ” ê±´ $Ax\approx y$ ë¥¼ ë§Œì¡±í•˜ëŠ” a, bë¥¼ ì°¾ëŠ” ê²ƒ.

## ğŸ“‰ 2ë‹¨ê³„: í•˜ì§€ë§Œ Ax = yëŠ” ë³´í†µ ì •í™•íˆ í’€ë¦¬ì§€ ì•ŠëŠ”ë‹¤
- ë°ì´í„°ê°€ ì™„ë²½íˆ ì§ì„  ìœ„ì— ìˆì§€ ì•Šê¸° ë•Œë¬¸.
- ê·¸ë˜ì„œ ìš°ë¦¬ëŠ” ì˜¤ì°¨ê°€ ìµœì†Œê°€ ë˜ëŠ” xë¥¼ ì°¾ëŠ” ë¬¸ì œë¡œ ë°”ê¾¼ë‹¤.
- ì¦‰,
```math
\| Ax-y\| ^2\mathrm{\  ë¥¼\  ìµœì†Œí™”í•˜ëŠ”\  }x
```
- ì´ê²Œ ë°”ë¡œ ìµœì†Œì œê³± ë¬¸ì œ.

## ğŸ” 3ë‹¨ê³„: ìµœì†Œì œê³± í•´ë¥¼ êµ¬í•˜ëŠ” ê°€ì¥ ì•ˆì •ì ì¸ ë°©ë²• = SVD
- ì—¬ê¸°ì„œ SVDê°€ ë“±ì¥í•œë‹¤.
- í–‰ë ¬ Aë¥¼ SVDë¡œ ë¶„í•´í•˜ë©´:
```math
A=U\Sigma V^T
```
- ì´ê±¸ ì´ìš©í•˜ë©´ ìµœì†Œì œê³± í•´ëŠ”
```math
x=V\Sigma ^+U^Ty
```
ì—¬ê¸°ì„œ $\Sigma ^+$ ëŠ” ì‹œê·¸ë§ˆì˜ ì—­ìˆ˜ë§Œ ë’¤ì§‘ì–´ë†“ì€ ê²ƒ(ì˜ì‚¬ì—­í–‰ë ¬).

## ğŸ¨ 4ë‹¨ê³„: ê·¸ë¦¼ìœ¼ë¡œ ì§ê´€ì ìœ¼ë¡œ ì´í•´í•˜ê¸°
### (1) ë°ì´í„° ì ë“¤
```
   *
 *    *
      * 
    *
```

### (2) ì´ ì ë“¤ì„ ê°€ì¥ ì˜ í†µê³¼í•˜ëŠ” ì§ì„ ì„ ì°¾ê³  ì‹¶ë‹¤
```
   *
 *    *
      * 
    *
---------
```

### (3) ì´ ë¬¸ì œë¥¼ í–‰ë ¬ Aë¡œ í‘œí˜„í•˜ë©´, AëŠ” **ê¸°ì € ë°©í–¥** ì„ ê°€ì§„ë‹¤
- SVDëŠ” Aë¥¼
  - íšŒì „(Váµ€)
  - ëŠ˜ë¦¬ê¸°/ì¤„ì´ê¸°(Î£)
  - ë‹¤ì‹œ íšŒì „(U)
- ë¡œ ë¶„í•´í•œë‹¤.
### (4) ì´ ê³¼ì •ì—ì„œ Aê°€ ê°€ì§„ â€œì¤‘ìš”í•œ ë°©í–¥â€ì´ ë“œëŸ¬ë‚œë‹¤
- ë°ì´í„°ê°€ ê°€ì¥ ë§ì´ í¼ì§„ ë°©í–¥
- ëœ í¼ì§„ ë°©í–¥
- ì´ ë‘ ë°©í–¥ì´ ì§ì„ ì˜ ê¸°ìš¸ê¸°ì™€ ì ˆí¸ì„ ê²°ì •í•˜ëŠ” í•µì‹¬ ì •ë³´ê°€ ëœë‹¤.
### (5) ê·¸ë˜ì„œ SVDëŠ” ë°ì´í„°ì˜ êµ¬ì¡°ë¥¼ ê°€ì¥ ì˜ ë°˜ì˜í•œ í•´ë¥¼ ì¤€ë‹¤
- íŠ¹íˆ:
  - ë°ì´í„°ê°€ ë…¸ì´ì¦ˆê°€ ë§ì„ ë•Œ
  - Aê°€ ê±°ì˜ ì„ í˜•ì¢…ì†ì¼ ë•Œ
  - ìˆ˜ì¹˜ì ìœ¼ë¡œ ë¶ˆì•ˆì •í•  ë•Œ
- SVDëŠ” ê°€ì¥ ì•ˆì •ì ì¸ í•´ë¥¼ ì œê³µí•œë‹¤.

## ğŸ§  ì™œ SVDë¥¼ ì“°ëŠ”ê°€? (Curve fitting ê´€ì )

| ì´ìœ                       | ì„¤ëª… |
|---------------------------|-------------------------------------------------------------|
| ìˆ˜ì¹˜ì ìœ¼ë¡œ ê°€ì¥ ì•ˆì •ì     | Aáµ€Aë¥¼ ì§ì ‘ ê³„ì‚°í•˜ë©´ ì˜¤ì°¨ê°€ ì»¤ì§€ì§€ë§Œ, SVDëŠ” ì•ˆì •ì ìœ¼ë¡œ í•´ë¥¼ êµ¬í•  ìˆ˜ ìˆë‹¤. |
| ë…¸ì´ì¦ˆì— ê°•í•¨             | ì‘ì€ íŠ¹ì´ê°’ì„ ë¬´ì‹œí•˜ë©´ ìì—°ìŠ¤ëŸ½ê²Œ ë…¸ì´ì¦ˆê°€ ì œê±°ë˜ì–´ ë” ë¶€ë“œëŸ¬ìš´ ê³¡ì„ ì´ ë‚˜ì˜¨ë‹¤. |
| í•´ê°€ ì—†ê±°ë‚˜ ë„ˆë¬´ ë§ì•„ë„ í•´ê²° ê°€ëŠ¥ | SVDëŠ” ì˜ì‚¬ì—­í–‰ë ¬(pseudoinverse)ì„ í†µí•´ í•­ìƒ í•´ë¥¼ ë§Œë“¤ ìˆ˜ ìˆì–´ under/over-determined ë¬¸ì œ ëª¨ë‘ í•´ê²°ëœë‹¤. |
| ëª¨ë“  í–‰ë ¬ì— ì ìš© ê°€ëŠ¥     | ì •ë°©í–‰ë ¬ì´ ì•„ë‹ˆì–´ë„, ì‹¬ì§€ì–´ ë­í¬ê°€ ë¶€ì¡±í•´ë„ SVDëŠ” ì ìš©ëœë‹¤. |
| ë°ì´í„° êµ¬ì¡°ë¥¼ ì˜ ë°˜ì˜     | íŠ¹ì´ê°’ê³¼ íŠ¹ì´ë²¡í„°ê°€ ë°ì´í„°ê°€ í¼ì§„ ë°©í–¥ì„ ì •í™•íˆ ì¡ì•„ì£¼ì–´ ê°€ì¥ ì˜ë¯¸ ìˆëŠ” fitting ê²°ê³¼ë¥¼ ì¤€ë‹¤. |

## ğŸ‰ í•œ ì¤„ ìš”ì•½
Curve fittingì—ì„œ SVDëŠ” **ë°ì´í„°ì— ê°€ì¥ ì˜ ë§ëŠ” ê³¡ì„ ì„ ì°¾ê¸° ìœ„í•œ ìµœì†Œì œê³± í•´** ë¥¼ ê°€ì¥ ì•ˆì •ì ì´ê³  ì •í™•í•˜ê²Œ êµ¬í•˜ëŠ” í•µì‹¬ ë„êµ¬ë‹¤.

-----

# ì „ì²´ ìš”ì•½

## 1. SVDë€ ë¬´ì—‡ì¸ê°€
### 1.1 ì •ì˜
- ì–´ë–¤ í–‰ë ¬ Aê°€ ìˆì„ ë•Œ, SVD(Singular Value Decomposition)ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë¶„í•´ì…ë‹ˆë‹¤.
  - $A=U\Sigma V^T$
  - $A$ : ì„ì˜ì˜ $m\times n$ í–‰ë ¬ (ì •ë°©í–‰ë ¬ì¼ í•„ìš” ì—†ìŒ)
  - $U$ : $m\times m$ ì§êµ í–‰ë ¬ (ì—´ë²¡í„°: ì™¼ìª½ íŠ¹ì´ë²¡í„°)
  - $\Sigma : m\times n$ ëŒ€ê°(ë˜ëŠ” ì§ì‚¬ê°) í–‰ë ¬, ëŒ€ê°ì›ì†ŒëŠ” íŠ¹ì´ê°’ $\sigma _i\geq 0$
  - $V$ : $n\times n$ ì§êµ í–‰ë ¬ (ì—´ë²¡í„°: ì˜¤ë¥¸ìª½ íŠ¹ì´ë²¡í„°)
- í•µì‹¬ ìš”ì•½:
  - $V^T$: ì¢Œí‘œê³„ë¥¼ â€œì¢‹ì€ ë°©í–¥â€ìœ¼ë¡œ íšŒì „ì‹œí‚¤ëŠ” ë³€í™˜
  - $\Sigma$ : ê° ë°©í–¥ìœ¼ë¡œ ëŠ˜ë¦¬ê¸°/ì¤„ì´ê¸°(ìŠ¤ì¼€ì¼ ë³€í™”)
  - $U$ : ë‹¤ì‹œ íšŒì „ì‹œì¼œ ìµœì¢… ì¢Œí‘œê³„ë¡œ ë³´ë‚´ëŠ” ë³€í™˜
- ì¦‰, SVDëŠ” ì„ì˜ì˜ ì„ í˜•ë³€í™˜ Aë¥¼ `íšŒì „ â†’ ëŠ˜ë¦¬ê¸°/ì¤„ì´ê¸° â†’ íšŒì „` ì„¸ ë‹¨ê³„ë¡œ ìª¼ê°  í‘œí˜„ì…ë‹ˆë‹¤.


### 1.2 ì›ì´ íƒ€ì›ìœ¼ë¡œ ë³€í•˜ëŠ” ê¸°í•˜ì  ì§ê´€
- 2ì°¨ì›ì—ì„œ ë‹¨ìœ„ ì›(ëª¨ë“  ë°©í–¥ì—ì„œ ê¸¸ì´ê°€ 1ì¸ ì ë“¤ì˜ ì§‘í•©)ì„ ìƒê°í•´ ë´…ì‹œë‹¤.
- ì²˜ìŒ ìƒíƒœ: ë‹¨ìœ„ ì›
```
     *****
   **     **
  *         *
  *         *
   **     **
     *****
```
- $V^T$ ì ìš©: ì¢Œí‘œê³„ íšŒì „ â†’ ì›ì€ ì—¬ì „íˆ ì›
- íšŒì „ì€ ê±°ë¦¬ì™€ ê°ë„ë¥¼ ë³´ì¡´í•˜ë¯€ë¡œ, ëª¨ì–‘ì€ ë³€í•˜ì§€ ì•Šê³  ë°©í–¥ë§Œ ë°”ë€œ
- $\Sigma$  ì ìš©: ê° ì¶• ë°©í–¥ìœ¼ë¡œ ë‹¤ë¥¸ ë¹„ìœ¨ë¡œ ëŠ˜ë¦¬ê¸°/ì¤„ì´ê¸°
- ì›ì´ íƒ€ì›ìœ¼ë¡œ ë³€í•˜ëŠ” í•µì‹¬ ë‹¨ê³„
  - ì˜ˆ: ê°€ë¡œ 3ë°°, ì„¸ë¡œ 1ë°° ë“±
- U ì ìš©: ë‹¤ì‹œ íšŒì „ â†’ íƒ€ì›ì˜ ë°©í–¥ì´ ë°”ë€œ
  - ëª¨ì–‘ì€ ê·¸ëŒ€ë¡œ, ë°©í–¥ë§Œ ë°”ë€œ
- ì •ë¦¬í•˜ë©´:
  - í˜•íƒœ(ì›â†’íƒ€ì›) ë³€í™”ì˜ í•µì‹¬ì€ $\Sigma$ 
  - **$U$, $V^T$** ëŠ” íšŒì „ë§Œ ë‹´ë‹¹ (ëª¨ì–‘ì€ ìœ ì§€, ë°©í–¥ë§Œ ë³€ê²½)

## 2. $\Sigma$ ë¥¼ ë°”ê¾¸ë©´ ë¬´ì—‡ì´ ë‹¬ë¼ì§€ëŠ”ê°€
### 2.1 $A=U\Sigma V^T$ ì˜ ì˜ë¯¸
- ì¤‘ìš”í•œ ì :
```math
A=U\Sigma V^T
```

- ì´ ì‹ì€ ê·¸ëƒ¥ Aë¥¼ ì •í™•í•˜ê²Œ í‘œí˜„í•œ ë¶„í•´ì…ë‹ˆë‹¤.
  - $U$, $\Sigma$ , $V^T$ ë¥¼ ê·¸ëŒ€ë¡œ ê³±í•˜ë©´ ë‹¤ì‹œ ì›ë˜ì˜ Aê°€ ë©ë‹ˆë‹¤.
  - **ë¶„í•´í–ˆë‹¤** ëŠ” ê²ƒì€ Aë¥¼ ë°”ê¿¨ë‹¤ëŠ” ëœ»ì´ ì•„ë‹ˆë¼,
  - Aë¥¼ ì„¸ ê°œì˜ **ì˜ë¯¸ ìˆëŠ” ë³€í™˜** ìœ¼ë¡œ ë‚˜ëˆ ì„œ ë³¸ë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤.
### 2.2 $\Sigma$ ë¥¼ ë°”ê¾¸ë©´?
- $\Sigma$ ë¥¼ ë¡œ ë°”ê¾¸ë©´ ê°€ ë˜ë©°, ì´ê²ƒì€ ì›ë˜ Aê°€ ì•„ë‹Œ ìƒˆë¡œìš´ ì„ í˜•ë³€í™˜ì…ë‹ˆë‹¤.
- ì´ë•Œ:
  - $U$, $V^T$: ì—¬ì „íˆ íšŒì „(ë°©í–¥ ì •ë³´)
  - $\Sigma$ : ëŠ˜ë¦¬ê¸°/ì¤„ì´ê¸° ê°•ë„ë¥¼ ë°”ê¾¸ë¯€ë¡œ, ì›ì´ íƒ€ì›ìœ¼ë¡œ ë³€í•˜ëŠ” ì •ë„, íƒ€ì›ì˜ ë‚©ì‘í•¨ ë“± í˜•íƒœ ë³€í™”ê°€ ë‹¬ë¼ì§‘ë‹ˆë‹¤.
  - ì¦‰,- **$U,V^T$**ëŠ” ê±´ë“œë¦¬ë©´ Aì˜ **ë°©í–¥ íŠ¹ì„±** ì´ ë³€í•´ë²„ë¦½ë‹ˆë‹¤.
- **$\Sigma$** ë¥¼ ì¡°ì •í•˜ë©´ Aì˜ **í¬ê¸°/ììœ ë„** ë§Œ ì¡°ì ˆí•˜ë©´ì„œ ìƒˆë¡œìš´ ë³€í™˜ A'ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## 3. Curve fitting ë¬¸ì œì˜ ê¸°ë³¸ í˜•íƒœ
### 3.1 ë¬¸ì œ ì„¤ì •ì˜ˆë¥¼ ë“¤ì–´ ì§ì„  y=ax+bë¥¼ ë°ì´í„°ì— fittingí•œë‹¤ê³  í•©ì‹œë‹¤.
- ë°ì´í„° $(x_i,y_i)$ ê°€ $i=1,\dots ,n$ ê°œ ìˆì„ ë•Œ:
```math
  A=\left[ \begin{matrix}x_1&1\\ x_2&1\\ \vdots &\vdots \\ x_n&1\end{matrix}\right] ,\quad x=\left[ \begin{matrix}a\\ b\end{matrix}\right] ,\quad y=\left[ \begin{matrix}y_1\\ y_2\\ \vdots \\ y_n\end{matrix}\right]
```
- ìš°ë¦¬ê°€ ì›í•˜ëŠ” ê²ƒì€:
  - $Ax\approx y$ ë¥¼ ë§Œì¡±í•˜ëŠ”
```math
x=\left[ \begin{matrix}a\\ b\end{matrix}\right]
```
- ì…ë‹ˆë‹¤.
### 3.2 ìµœì†Œì œê³± ë¬¸ì œë¡œì˜ ë³€í™˜ë°ì´í„°ëŠ” ë³´í†µ ì§ì„  ìœ„ì— ì •í™•íˆ ìˆì§€ ì•Šìœ¼ë¯€ë¡œ:
$Ax=y$ ë¥¼ ì •í™•íˆ ë§Œì¡±í•˜ëŠ” $x$ ëŠ” ì¡´ì¬í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- ê·¸ë˜ì„œ ìš°ë¦¬ëŠ” ì˜¤ì°¨ë¥¼ ìµœì†Œí™”í•©ë‹ˆë‹¤.
  - $\min _x\| Ax-y\| ^2$ ì´ê²ƒì´ ìµœì†Œì œê³±(least squares) ë¬¸ì œì…ë‹ˆë‹¤.

## 4. ê³ ì „ì ì¸ í•´ë²•ê³¼ ê·¸ í•œê³„
### 4.1 Normal equationê³ ì „ì ìœ¼ë¡œëŠ” ë‹¤ìŒ ê³µì‹ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
$x=(A^TA)^{-1}A^Ty$ í•˜ì§€ë§Œ ì´ ë°©ì‹ì€ ë‹¤ìŒê³¼ ê°™ì€ ë¬¸ì œë¥¼ ê°€ì§‘ë‹ˆë‹¤.
- ë¬¸ì œ 1: $A^TA$ ê°€ ì—­í–‰ë ¬ì„ ê°€ì§ˆ ë§Œí¼ ì˜ conditioned ë˜ì–´ ìˆì–´ì•¼ í•¨
- ë¬¸ì œ 2: Aì˜ ì—´ì´ ì„œë¡œ ë¹„ìŠ·í•˜ë©´ $A^TA$ ëŠ” ê±°ì˜ `singular`
- ë¬¸ì œ 3: ìˆ˜ì¹˜ì ìœ¼ë¡œ ë§¤ìš° ë¶ˆì•ˆì • (floating point ì˜¤ì°¨ ì¦í­)
- ê·¸ë˜ì„œ ì‹¤ì „ì—ì„œëŠ” ë” ì•ˆì •ì ì¸ ë°©ë²•ì´ í•„ìš”í•©ë‹ˆë‹¤.
- ê±°ê¸°ì„œ SVDê°€ ë“±ì¥í•©ë‹ˆë‹¤.

## 5. SVDë¥¼ ì‚¬ìš©í•œ ìµœì†Œì œê³± í•´ êµ¬í•˜ê¸°
### 5.1 SVD ë¶„í•´ë¨¼ì € Aë¥¼ SVDë¡œ ë¶„í•´í•©ë‹ˆë‹¤.
- $A=U\Sigma V^T$ ì—¬ê¸°ì„œ $\Sigma$ ëŠ” ëŒ€ê° ì„±ë¶„ì— íŠ¹ì´ê°’ $\sigma _i$ ë¥¼ ê°€ì§„ í–‰ë ¬ì…ë‹ˆë‹¤.
### 5.2 ì˜ì‚¬ì—­í–‰ë ¬(pseudoinverse)ì„ ì´ìš©í•œ í•´SVDë¥¼ ì´ìš©í•˜ë©´ ìµœì†Œì œê³± í•´ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- $x=V\Sigma ^+U^Ty- \Sigma ^+: \Sigma$ ì˜ ì˜ì‚¬ì—­í–‰ë ¬
- $\sigma _i\neq 0$ ì¸ ê²½ìš°, $\frac{1}{\sigma _i}$ ë¡œ ë°”ê¿”ì„œ ëŒ€ê°ì— ë°°ì¹˜
- 0ì¸ íŠ¹ì´ê°’ì— ëŒ€í•´ì„œëŠ” 0ìœ¼ë¡œ ë‘ 
- ì´ ì‹ì€ normal equationì„ ì§ì ‘ í’€ì§€ ì•Šê³ ë„ ìµœì†Œì œê³± í•´ë¥¼ êµ¬í•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤.
## 6. ì´ ê³¼ì •ì„ ê¸°í•˜ì ìœ¼ë¡œ í•´ì„í•˜ê¸°
- $x=V\Sigma ^+U^Ty$ ì´ ì‹ì„ ë‹¨ê³„ë³„ ê¸°í•˜ì  ë³€í™˜ìœ¼ë¡œ ë³´ë©´:
- $U^Ty$
  - ì—­í• : yë¥¼ Aê°€ **í‘œí˜„í•  ìˆ˜ ìˆëŠ” ë°©í–¥** ìœ¼ë¡œ íˆ¬ì˜
  - í•´ì„: Aê°€ ë§Œë“¤ì–´ë‚´ëŠ” ê³µê°„(ì—´ê³µê°„/ì´ë¯¸ì§€)ì— yë¥¼ ê°€ì ¸ë‹¤ ë†“ëŠ” ê³¼ì •
- $\Sigma ^+$
  - ì—­í• : ê° íŠ¹ì´ê°’ ë°©í–¥ìœ¼ë¡œ ë‚˜ëˆ„ê¸°(ìŠ¤ì¼€ì¼ ì¡°ì •)
  - í•´ì„:
    - íŠ¹ì´ê°’ì´ í° ë°©í–¥: ì •ë³´ê°€ ë§ì€ ë°©í–¥ â†’ ê·¸ëŒ€ë¡œ ì˜ ì‚¬ìš©
    - íŠ¹ì´ê°’ì´ ì‘ì€ ë°©í–¥: ë…¸ì´ì¦ˆ ë°©í–¥ â†’ ê³¼ë„í•˜ê²Œ í™•ëŒ€í•˜ì§€ ì•Šë„ë¡ ì œì–´
- $V$
  - ì—­í• : ë³€í™˜ëœ ê³„ìˆ˜ë“¤ì„ ë‹¤ì‹œ ì›ë˜ ë³€ìˆ˜ ê³µê°„ìœ¼ë¡œ íšŒì „
  - í•´ì„: ë‹¨ìˆœí™”ëœ ì¢Œí‘œê³„ì—ì„œ ê³„ì‚°ëœ í•´ë¥¼ ì›ë˜ ì¢Œí‘œê³„ë¡œ ëŒë ¤ë†“ìŒ
## 7. ììœ ë„ ê°ì†Œì˜ ì˜ë¯¸ (SVD ê´€ì )
### 7.1 íŠ¹ì´ê°’ê³¼ ììœ ë„
```math
\Sigma =\mathrm{diag}(\sigma _1,\sigma _2,\dots ,\sigma _r)
```
- í° $\sigma _i$: ë°ì´í„°ê°€ ë§ì´ í¼ì ¸ ìˆëŠ” ì¤‘ìš”í•œ ë°©í–¥
- ì‘ì€ $\sigma _i$: ë°ì´í„°ê°€ ê±°ì˜ ì—†ëŠ” ë°©í–¥, ë…¸ì´ì¦ˆ ë°©í–¥
- ì—¬ê¸°ì„œ ììœ ë„ ê°ì†Œë€:
  - ì‘ì€ íŠ¹ì´ê°’ì„ 0ìœ¼ë¡œ ë§Œë“¤ê±°ë‚˜ ë¬´ì‹œí•˜ëŠ” ê²ƒ
- ì´ë•Œ:
  - ë­í¬ê°€ ê°ì†Œ â†’ ì‚¬ìš©ë˜ëŠ” ë…ë¦½ëœ ë°©í–¥(ììœ ë„)ì´ ì¤„ì–´ë“¦
  - ëª¨ë¸ì´ ë” ë‹¨ìˆœí•´ì§€ê³  ì•ˆì •ì ì´ ë¨
### 7.2 **ì‚¼ì°¨ì› ê³¡ë©´ì´ UV í‰ë©´ì´ ë˜ëŠ” ëŠë‚Œ** 
- ë°ì´í„°ê°€ 3ì°¨ì› ê³µê°„ì— ìˆì§€ë§Œ ì‹¤ì œë¡œëŠ” ê±°ì˜ ì–´ë–¤ 2ì°¨ì› í‰ë©´(ë˜ëŠ” 1ì°¨ì› ì„ ) ê·¼ì²˜ì— ëª°ë ¤ ìˆë‹¤ê³  í•©ì‹œë‹¤.
- V^T: 3D ê³µê°„ì„ íšŒì „ì‹œì¼œ
  - ë°ì´í„°ê°€ ê°€ì¥ í¼ì ¸ ìˆëŠ” ë°©í–¥ë“¤ì„ ì¶•ê³¼ ì •ë ¬
  - ì´ë•Œ, ì‹¤ì œ ì •ë³´ê°€ ìˆëŠ” ë°©í–¥ì€ 2ê°œ, ë‚˜ë¨¸ì§€ 1ê°œëŠ” ê±°ì˜ ì •ë³´ ì—†ìŒ
- $\Sigma$ : ì´ ì„¸ ì¶•ì˜ ì¤‘ìš”ë„ë¥¼ íŠ¹ì´ê°’ìœ¼ë¡œ í‘œí˜„
  - $\sigma _1,\sigma _2$: í¼ (ì‹¤ì œ í‰ë©´)
  - $\sigma _3$: ë§¤ìš° ì‘ìŒ (í‰ë©´ì—ì„œ ì¡°ê¸ˆ ë²—ì–´ë‚œ ë…¸ì´ì¦ˆ)
  - $\sigma _3$ ë¥¼ 0ìœ¼ë¡œ ë§Œë“ ë‹¤ â†’ ììœ ë„ 1 ê°ì†Œ
  - 3Dì—ì„œ 2D í‰ë©´ìœ¼ë¡œ **ëˆ•í˜€ì§€ëŠ”** ëŠë‚Œ
- ê³¡ë©´ì´ ì•„ë‹ˆë¼ **ì‹¤ì œë¡œ ì˜ë¯¸ ìˆëŠ” í‰ë©´(uv plane)** ë§Œ ë‚¨ëŠ” ê²ƒ
  - Curve fittingì—ì„œëŠ” **ë°ì´í„°ê°€ ì‹¤ì œë¡œ ì°¨ì§€í•˜ëŠ” ìœ íš¨í•œ ì°¨ì›ë§Œ ì‚¬ìš©í•˜ê³ , ë‚˜ë¨¸ì§€ëŠ” ë²„ë ¤ì„œ ê³¼ì í•©ê³¼ ë¶ˆì•ˆì •ì„ ë§‰ëŠ” ê³¼ì •** ì´ë¼ê³  ì´í•´í•˜ë©´ ë©ë‹ˆë‹¤.

## 8. Curve fittingì—ì„œ SVDë¥¼ ì“°ëŠ” ì´ìœ  ì •ë¦¬
- ì•„ë˜ëŠ” Curve fitting ê´€ì ì—ì„œ SVDë¥¼ ì“°ëŠ” ì´ìœ ë¥¼ ìš”ì•½.

| ì´ìœ                           | ì„¤ëª… |
|-------------------------------|------|
| ìˆ˜ì¹˜ì ìœ¼ë¡œ ì•ˆì •ì              | \(A^T A\)ë¥¼ ì§ì ‘ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ, ill-conditioned ë¬¸ì œì—ì„œë„ í•´ë¥¼ ë³´ë‹¤ ì•ˆì •ì ìœ¼ë¡œ êµ¬í•  ìˆ˜ ìˆë‹¤. |
| ë…¸ì´ì¦ˆì— ê°•í•¨                 | ì‘ì€ íŠ¹ì´ê°’(ë…¸ì´ì¦ˆ ë°©í–¥)ì„ ì˜ë¼ë‚´ê±°ë‚˜ ì™„í™”í•¨ìœ¼ë¡œì¨ ë” ë¶€ë“œëŸ¬ìš´ fitting ê²°ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆë‹¤. |
| ììœ ë„(ë­í¬) ì¡°ì ˆ ê°€ëŠ¥        | íŠ¹ì´ê°’ì„ ì„ íƒì ìœ¼ë¡œ ì‚¬ìš©í•˜ì—¬ ëª¨ë¸ì˜ ë³µì¡ë„ë¥¼ ì¤„ì´ê³ , ì‹¤ì œ ë°ì´í„°ê°€ ìˆëŠ” ì°¨ì›ë§Œ ì‚¬ìš©í•œë‹¤. |
| í•´ê°€ ì—†ê±°ë‚˜ ë„ˆë¬´ ë§ì€ ê²½ìš° í•´ê²° | under-determined, over-determined ì‹œìŠ¤í…œ ëª¨ë‘ì—ì„œ ì˜ì‚¬ì—­í–‰ë ¬ì„ í†µí•´ ì˜ë¯¸ ìˆëŠ” í•´ë¥¼ êµ¬í•  ìˆ˜ ìˆë‹¤. |
| ë°ì´í„° êµ¬ì¡°ë¥¼ ì˜ ë°˜ì˜         | íŠ¹ì´ë²¡í„°ê°€ ë°ì´í„°ê°€ í¼ì§„ ë°©í–¥ì„ ì˜ í¬ì°©í•˜ì—¬, ê°€ì¥ ì˜ë¯¸ ìˆëŠ” ë°©í–¥ì„ ê¸°ì¤€ìœ¼ë¡œ fittingì„ ìˆ˜í–‰í•œë‹¤. |

## 9. ì „ì²´ íë¦„ í•œ ë²ˆì— ìš”ì•½
- SVD ë¶„í•´
```math 
A=U\Sigma V^T
```
- Curve fitting ë¬¸ì œ
```math
\min _x\| Ax-y\| ^2
```
- SVDë¥¼ ì´ìš©í•œ ìµœì†Œì œê³± í•´
```math
x=V\Sigma ^+U^Ty
```
- ê¸°í•˜ì  í•´ì„
- $V^T$: ì¢Œí‘œê³„ íšŒì „ â†’ ë°ì´í„°ê°€ ì˜ í¼ì§„ ë°©í–¥ìœ¼ë¡œ ì •ë ¬
- $\Sigma$ : ê° ë°©í–¥ì˜ ì¤‘ìš”ë„(íŠ¹ì´ê°’) â†’ í•„ìš”í•˜ë©´ ì‘ì€ íŠ¹ì´ê°’ ì œê±°(ììœ ë„ ê°ì†Œ)
- $U^T$: yë¥¼ Aê°€ í‘œí˜„ ê°€ëŠ¥í•œ ê³µê°„ìœ¼ë¡œ íˆ¬ì˜
- $\Sigma ^+, V$ : ë‹¨ìˆœí™”ëœ ì¢Œí‘œê³„ì—ì„œ ê³„ì‚° í›„, ì›ë˜ ê³µê°„ìœ¼ë¡œ ë³µê·€
- ììœ ë„ ê°ì†Œ
  - ì‘ì€ íŠ¹ì´ê°’ì„ 0 ë˜ëŠ” ë¬´ì‹œ
  - ì‹¤ì œ ë°ì´í„°ê°€ ë†“ì¸ **ìœ íš¨ ì°¨ì›** ë§Œ ì‚¬ìš©
  - 3D ê³¡ë©´ì„ íšŒì „ì‹œì¼œ UV í‰ë©´ ìœ„ì— ëˆ•íˆê³ , í•„ìš” ì—†ëŠ” ì¶•ì€ ë²„ë¦¬ëŠ” ëŠë‚Œ

## ë§ˆë¬´ë¦¬

- SVDëŠ” **íšŒì „(U, V^T)** + **ìŠ¤ì¼€ì¼ ë³€í™”(Î£)** ë¡œ ëª¨ë“  ì„ í˜•ë³€í™˜ì„ í‘œí˜„í•œë‹¤.
- Curve fittingì—ì„œëŠ” SVDë¥¼ ì‚¬ìš©í•˜ì—¬
  - ìˆ˜ì¹˜ì ìœ¼ë¡œ ì•ˆì •ì ì¸ ìµœì†Œì œê³± í•´ë¥¼ êµ¬í•˜ê³ ,
  - íŠ¹ì´ê°’ì„ í†µí•´ **ììœ ë„(ë­í¬)ë¥¼ ì¡°ì ˆ** í•˜ë©°,
  - ì‹¤ì œ ë°ì´í„°ê°€ ì¡´ì¬í•˜ëŠ” ì°¨ì›ë§Œ ì‚¬ìš©í•´ **ê³¼ì í•©ê³¼ ë…¸ì´ì¦ˆ**ë¥¼ ì¤„ì¼ ìˆ˜ ìˆë‹¤.
- **ì‚¼ì°¨ì› ê³¡ë©´ì„ íšŒì „ì‹œì¼œ UV í‰ë©´ìœ¼ë¡œ ëˆ•íŒ ë’¤, í•„ìš” ì—†ëŠ” ì¶•ì€ ë²„ë¦¬ëŠ” ëŠë‚Œ** ì´ë¼ëŠ” ì§ê´€ì€  
  SVDì™€ ììœ ë„ ê°ì†Œë¥¼ ì´í•´í•˜ëŠ” ë° ë§¤ìš° ì •í™•í•œ ë¹„ìœ ì´ë‹¤.
---

## ì†ŒìŠ¤ ì½”ë“œ
```rust
use crate::core::matrix::Matrix;
use crate::core::prelude::Point4D;
use crate::core::tarray::TArray;
use crate::core::types::{ON_TOL6, Real};
use nalgebra::{DMatrix, SVD};
use std::f64::EPSILON;

#[inline]
fn hypot2(a: f64, b: f64) -> f64 {
    a.hypot(b)
}

/// ëŒ€ì¹­í–‰ë ¬ B (nÃ—n)ë¥¼ ì•¼ì½”ë¹„ íšŒì „ìœ¼ë¡œ ê³ ìœ ë¶„í•´.
/// ê²°ê³¼: BëŠ” ëŒ€ê°(ê³ ìœ ê°’), vëŠ” ì—´-ê³ ìœ ë²¡í„°(ì •ê·œì§êµ).
fn on_jacobi_symmetric_eigen(b: &mut Matrix, vals: &mut Vec<f64>, v: &mut Matrix) -> bool {
    let n = b.rows();
    if n == 0 || b.cols() != n {
        return false;
    }

    // v <- I
    if !v.create(n, n) {
        return false;
    }
    for i in 0..n {
        for j in 0..n {
            *v.at_mut(i as i32, j as i32) = if i == j { 1.0 } else { 0.0 };
        }
    }

    // ë°˜ë³µ íŒŒë¼ë¯¸í„°
    let max_sweeps = 50 * n * n;
    let tol = 1e-14_f64;

    // ë„ì›€: í•© ì˜¤í”„ëŒ€ê°ì˜ ì œê³±í•©
    let off2 = |m: &Matrix| -> f64 {
        let mut s = 0.0;
        for p in 0..n {
            for q in 0..n {
                if p != q {
                    let x = *m.at(p as i32, q as i32);
                    s += x * x;
                }
            }
        }
        s
    };

    // ë°˜ë³µ
    let mut sweep = 0usize;
    loop {
        let mut changed = false;

        for p in 0..n {
            for q in (p + 1)..n {
                let app = *b.at(p as i32, p as i32);
                let aqq = *b.at(q as i32, q as i32);
                let apq = *b.at(p as i32, q as i32);
                if apq.abs() <= tol * hypot2(app.abs(), aqq.abs()) {
                    continue;
                }

                // íšŒì „ê³„ìˆ˜ (NR ë°©ì‹)
                let tau = (aqq - app) / (2.0 * apq);
                if !tau.is_finite() || tau == 0.0 {
                    continue; // íšŒì „ ìƒëµ
                }

                let t = if tau.abs() + 1.0 == 1.0 {
                    1.0 / (2.0 * tau)
                } else {
                    let sgn = if tau >= 0.0 { 1.0 } else { -1.0 };
                    sgn / (tau.abs() + (1.0 + tau * tau).sqrt())
                };
                let c = 1.0 / (1.0 + t * t).sqrt();
                let s = t * c;

                if !t.is_finite() || !c.is_finite() || !s.is_finite() {
                    println!("âš ï¸ ìˆ˜ì¹˜ ë¶ˆì•ˆì •: t={}, c={}, s={} â†’ íšŒì „ ìƒëµ", t, c, s);
                    continue;
                }

                // B <- Jáµ€ B J  (ëŒ€ì¹­ ìœ ì§€)
                // í–‰/ì—´ p,q ì—…ë°ì´íŠ¸
                let bpp = app - t * apq;
                let bqq = aqq + t * apq;
                *b.at_mut(p as i32, p as i32) = bpp;
                *b.at_mut(q as i32, q as i32) = bqq;
                *b.at_mut(p as i32, q as i32) = 0.0;
                *b.at_mut(q as i32, p as i32) = 0.0;

                for r in 0..n {
                    if r != p && r != q {
                        let arp = *b.at(r as i32, p as i32);
                        let arq = *b.at(r as i32, q as i32);
                        let nrp = c * arp - s * arq;
                        let nrq = s * arp + c * arq;
                        *b.at_mut(r as i32, p as i32) = nrp;
                        *b.at_mut(p as i32, r as i32) = nrp;
                        *b.at_mut(r as i32, q as i32) = nrq;
                        *b.at_mut(q as i32, r as i32) = nrq;
                    }
                }

                // V <- V J (ì—´-ê³ ìœ ë²¡í„°)
                for r in 0..n {
                    let vrp = *v.at(r as i32, p as i32);
                    let vrq = *v.at(r as i32, q as i32);
                    *v.at_mut(r as i32, p as i32) = c * vrp - s * vrq;
                    *v.at_mut(r as i32, q as i32) = s * vrp + c * vrq;
                }

                changed = true;
            }
        }

        sweep += 1;
        if !changed {
            break;
        }
        if sweep > max_sweeps {
            break;
        } // ì•ˆì „ íƒˆì¶œ
        if off2(b) < tol {
            break;
        }
    }

    // ê³ ìœ ê°’ ì¶”ì¶œ
    vals.clear();
    vals.resize(n, 0.0);
    for i in 0..n {
        vals[i] = *b.at(i as i32, i as i32);
    }
    true
}
```
```rust
/// SVD via Jacobi-eigen on Aáµ€A
/// ì…ë ¥:  a (mÃ—n)  â€” ë³€ê²½ í›„ U ì €ì¥ (mÃ—n)
/// ì¶œë ¥:  w (n)    â€” íŠ¹ì´ê°’
///        v (nÃ—n)  â€” ìš°ì§êµ í–‰ë ¬
pub fn on_svdcmp_sym_left(a: &mut Matrix, w: &mut TArray<f64>, v: &mut Matrix) -> bool {
    let m = a.rows();
    let n = a.cols();
    if m == 0 || n == 0 {
        return false;
    }

    // A ë³´ì¡´
    let a0 = a.clone();

    // B = Aáµ€A (nÃ—n)
    let mut at = a0.clone();
    at.transpose(); // nÃ—m
    let mut b = &at * &a0; // (nÃ—m)*(mÃ—n) = nÃ—n

    // ëŒ€ì¹­ ìˆ˜ì¹˜í™”(ë¯¸ì„¸í•œ ë¹„ëŒ€ì¹­ ì œê±°)
    for i in 0..n {
        for j in 0..n {
            let x = 0.5 * (*b.at(i as i32, j as i32) + *b.at(j as i32, i as i32));
            *b.at_mut(i as i32, j as i32) = x;
        }
    }

    // ê³ ìœ ë¶„í•´
    let mut evals: Vec<f64> = Vec::new();
    if !on_jacobi_symmetric_eigen(&mut b, &mut evals, v) {
        return false;
    }

    // ê³ ìœ ê°’â†“ ì •ë ¬ + V ì—´ ì¬ì •ë ¬
    let mut idx: Vec<usize> = (0..n).collect();
    idx.sort_by(|&i, &j| evals[j].partial_cmp(&evals[i]).unwrap());

    let mut wvec = vec![0.0f64; n];
    let mut v_sorted = Matrix::with_dims(n, n);
    for (col, &k) in idx.iter().enumerate() {
        wvec[col] = evals[k].max(0.0).sqrt();
        for r in 0..n {
            *v_sorted.at_mut(r as i32, col as i32) = *v.at(r as i32, k as i32);
        }
    }
    *v = v_sorted;
    w.set_size(n);
    for i in 0..n {
        w[i] = wvec[i];
    }

    // U = A * V * Î£^{-1}  (Ïƒ_i > 0ë§Œ)
    if !a.create(m, n) {
        return false;
    }
    let eps = 1e-12_f64;
    for j in 0..n {
        let sigma = w[j];
        if sigma > eps {
            for r in 0..m {
                let mut s = 0.0;
                for k in 0..n {
                    s += *a0.at(r as i32, k as i32) * *v.at(k as i32, j as i32);
                }
                *a.at_mut(r as i32, j as i32) = s / sigma;
            }
        } else {
            // Ïƒ=0: ì„ì˜ì˜ ì§êµ ì™„ì„± (ì—¬ê¸°ì„œëŠ” 0 ë²¡í„°ë¡œ ë‘ê³ , í•„ìš”í•˜ë©´ ê·¸ëŒ-ìŠˆë¯¸íŠ¸ë¡œ ë³´ê°• ê°€ëŠ¥)
            for r in 0..m {
                *a.at_mut(r as i32, j as i32) = 0.0;
            }
        }
    }

    // ì„ íƒ: U ì—´ ì •ê·œí™”(ìˆ˜ì¹˜ ì•ˆì •)
    for j in 0..n {
        let mut s = 0.0;
        for r in 0..m {
            let x = *a.at(r as i32, j as i32);
            s += x * x;
        }
        let nrm = s.sqrt();
        if nrm > EPSILON {
            for r in 0..m {
                *a.at_mut(r as i32, j as i32) /= nrm;
            }
        }
    }

    true
}
```
```rust
pub fn on_solve_least_squares_svd(mut a: Matrix, b: &[f64], tol: f64) -> Vec<f64> {
    let m = a.rows();
    let n = a.cols();
    assert_eq!(b.len(), m, "b must have length m");

    // SVD
    let mut w = TArray::<f64>::with_size(n);
    let mut v = Matrix::with_dims(n, n);
    assert!(on_svdcmp_sym_left(&mut a, &mut w, &mut v)); // a=U, w=Ïƒ, v=V

    // y = Uáµ€ b  (ê¸¸ì´ n)
    let mut y = vec![0.0; n];
    for i in 0..n {
        let mut dot = 0.0;
        for r in 0..m {
            dot += a.at(r as i32, i as i32) * b[r]; // U[:,i]Â·b
        }
        let sigma = w[i].abs();
        y[i] = if sigma > tol { dot / sigma } else { 0.0 };
    }

    // x = V y  (ê¸¸ì´ n)
    let mut x = vec![0.0; n];
    for j in 0..n {
        let mut s = 0.0;
        for i in 0..n {
            s += v.at(j as i32, i as i32) * y[i]; // V[:,i]*y[i] ëˆ„ì 
        }
        x[j] = s;
    }
    x
}
```
```rust
pub fn on_svdcmp_sym_right(a: &mut Matrix, w: &mut TArray<f64>, v: &mut Matrix) -> bool {
    let m = a.rows();
    let n = a.cols();
    if m == 0 || n == 0 {
        return false;
    }

    let a0 = a.clone();

    // B = A Aáµ€ (mÃ—m)
    let mut at = a0.clone();
    at.transpose(); // nÃ—m
    let mut b = &a0 * &at; // (mÃ—n)*(nÃ—m) = mÃ—m

    // ëŒ€ì¹­í™”
    for i in 0..m {
        for j in 0..m {
            let x = 0.5 * (*b.at(i as i32, j as i32) + *b.at(j as i32, i as i32));
            *b.at_mut(i as i32, j as i32) = x;
        }
    }

    // ê³ ìœ ê°’ ë¶„í•´: B = U Î› Uáµ€
    let mut evals: Vec<f64> = Vec::new();
    if !on_jacobi_symmetric_eigen(&mut b, &mut evals, a) {
        return false;
    }

    // ê³ ìœ ê°’ ì •ë ¬
    let mut idx: Vec<usize> = (0..m).collect();
    idx.sort_by(|&i, &j| evals[j].partial_cmp(&evals[i]).unwrap());

    // íŠ¹ì´ê°’ w = sqrt(Î»)
    let mut wvec = vec![0.0f64; m];
    for (i, &k) in idx.iter().enumerate() {
        wvec[i] = evals[k].max(0.0).sqrt();
    }
    w.set_size(m);
    for i in 0..m {
        w[i] = wvec[i];
    }

    // U ì •ë ¬
    let mut u_sorted = Matrix::with_dims(m, m);
    for (col, &k) in idx.iter().enumerate() {
        for r in 0..m {
            *u_sorted.at_mut(r as i32, col as i32) = *a.at(r as i32, k as i32);
        }
    }
    *a = u_sorted;

    // V = Aáµ€ U / Ïƒ
    if !v.create(n, m) {
        return false;
    }
    let eps = 1e-12_f64;
    for j in 0..m {
        let sigma = w[j];
        if sigma > eps {
            for r in 0..n {
                let mut s = 0.0;
                for k in 0..m {
                    s += *at.at(r as i32, k as i32) * *a.at(k as i32, j as i32);
                }
                *v.at_mut(r as i32, j as i32) = s / sigma;
            }
        } else {
            for r in 0..n {
                *v.at_mut(r as i32, j as i32) = 0.0;
            }
        }
    }

    true
}
```
```rust
pub fn on_svdcmp(a: &mut Matrix, w: &mut TArray<f64>, v: &mut Matrix) -> bool {
    let m = a.rows();
    let n = a.cols();

    // 1. Matrix â†’ DMatrix ë³€í™˜
    let mut data = vec![0.0; m * n];
    for i in 0..m {
        for j in 0..n {
            data[i * n + j] = *a.at(i as i32, j as i32);
        }
    }
    let a_na = DMatrix::from_row_slice(m, n, &data);

    // 2. SVD ìˆ˜í–‰
    let svd = SVD::new(a_na.clone(), true, true);
    let u_na = match svd.u {
        Some(u) => u,
        None => return false,
    };
    let v_t_na = match svd.v_t {
        Some(vt) => vt,
        None => return false,
    };
    let sigma = svd.singular_values;

    // 3. ê²°ê³¼ ë³µì‚¬: w
    w.set_size(sigma.len());
    for i in 0..sigma.len() {
        w[i] = sigma[i];
    }

    // 4. ê²°ê³¼ ë³µì‚¬: a â† U
    if !a.create(m, u_na.ncols()) {
        return false;
    }
    for i in 0..m {
        for j in 0..u_na.ncols() {
            *a.at_mut(i as i32, j as i32) = u_na[(i, j)];
        }
    }

    // 5. ê²°ê³¼ ë³µì‚¬: v â† V
    let v_na = v_t_na.transpose();
    if !v.create(v_na.nrows(), v_na.ncols()) {
        return false;
    }
    for i in 0..v_na.nrows() {
        for j in 0..v_na.ncols() {
            *v.at_mut(i as i32, j as i32) = v_na[(i, j)];
        }
    }

    true
}
```
```rust
/// Vec<Vec<Real>> ê¸°ë°˜ SVD (OpenNURBS svdcmp ìŠ¤íƒ€ì¼)
///
/// ì…ë ¥:
/// - a: mÃ—n í–‰ë ¬ (row-major Vec of rows)
///
/// ì¶œë ¥:
/// - a: U (mÃ—k) ë¡œ overwrite, k = min(m,n)
/// - w: singular values (len = k)
/// - v: V (nÃ—n)
///
/// ë°˜í™˜:
/// - true: ì„±ê³µ
/// - false: ì‹¤íŒ¨(ì¹˜ëª…ì ìœ¼ë¡œ ë¶„í•´ ë¶ˆê°€ / shape ì˜¤ë¥˜)
pub fn on_svdcmp_vec(a: &mut Vec<Vec<Real>>, w: &mut Vec<Real>, v: &mut Vec<Vec<Real>>) -> bool {
    let m = a.len();
    if m == 0 {
        return false;
    }
    let n = a[0].len();
    if n == 0 {
        return false;
    }
    if !a.iter().all(|row| row.len() == n) {
        return false; // jagged
    }

    // 1) Vec<Vec> -> DMatrix (row-major slice)
    let mut data = vec![0.0; m * n];
    for i in 0..m {
        for j in 0..n {
            data[i * n + j] = a[i][j];
        }
    }
    let a_na = DMatrix::from_row_slice(m, n, &data);

    // 2) SVD
    // compute_u=true, compute_v=true
    let svd = SVD::new(a_na, true, true);

    let u_na = match svd.u {
        Some(u) => u,
        None => return false,
    };
    let v_t_na = match svd.v_t {
        Some(vt) => vt,
        None => return false,
    };
    let sigma = svd.singular_values;

    // k = min(m,n)
    let k = sigma.len();

    // 3) w
    w.clear();
    w.extend(sigma.iter().copied());

    // 4) a <- U (mÃ—k)
    // nalgebra UëŠ” mÃ—m ì¼ ìˆ˜ë„ ìˆê³  mÃ—k ì¼ ìˆ˜ë„ ìˆëŠ”ë°,
    // nalgebraëŠ” ì¼ë°˜ì ìœ¼ë¡œ mÃ—k(Thin U)ë¥¼ ì£¼ëŠ” í¸ì´ì§€ë§Œ ë²„ì „ì— ë”°ë¼ ë‹¤ë¥¼ ìˆ˜ ìˆì–´ì„œ
    // ì‹¤ì œ colsë¡œ ë§ì¶˜ë‹¤.
    let u_cols = u_na.ncols(); // k ë˜ëŠ” m
    a.clear();
    a.resize(m, vec![0.0; u_cols]);
    for i in 0..m {
        for j in 0..u_cols {
            a[i][j] = u_na[(i, j)];
        }
    }

    // 5) v <- V (nÃ—n)
    // v_t_na ëŠ” (kÃ—n) ë˜ëŠ” (nÃ—n)ì¼ ìˆ˜ ìˆìŒ.
    // Vë¥¼ nÃ—nìœ¼ë¡œ ë§ì¶”ë ¤ë©´ "full V"ê°€ í•„ìš”.
    // nalgebraê°€ thin Vë¥¼ ì¤„ ê²½ìš°ê°€ ìˆì–´, nÃ—nì´ ì•„ë‹ ìˆ˜ ìˆë‹¤.
    // ì—¬ê¸°ì„œëŠ” v_t_na.nrows()==n ì¸ ê²½ìš°ë§Œ fullë¡œ ì·¨ê¸‰í•˜ê³ ,
    // ì•„ë‹ˆë©´ thin(=kÃ—n)ì—ì„œ Vë¥¼ nÃ—në¡œ ë§Œë“¤ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ì‹¤íŒ¨ ì²˜ë¦¬.
    //
    // (GlobalInterpolationì€ ë³´í†µ square ì‹œìŠ¤í…œì„ í’€ì–´ì„œ nÃ—nì´ë¼ fullì´ ì˜ ë‚˜ì˜´)
    if v_t_na.nrows() != n || v_t_na.ncols() != n {
        return false;
    }
    let v_na = v_t_na.transpose(); // nÃ—n

    v.clear();
    v.resize(n, vec![0.0; n]);
    for i in 0..n {
        for j in 0..n {
            v[i][j] = v_na[(i, j)];
        }
    }

    // ê¸°ë³¸ sanity: w len == k
    k > 0
}
```
```rust
// ì™¸ë¶€ ì¸í„°í˜ì´ìŠ¤: ê¸°ì¡´ êµ¬ì¡°ë¥¼ ìœ ì§€
pub fn on_solve_least_squares_svd_na(a: Matrix, b: &[f64], tol: f64) -> Vec<f64> {
    let m = a.rows();
    let n = a.cols();
    assert_eq!(b.len(), m, "b must have length equal to row count of A");

    // 1. Matrix â†’ DMatrix ë³€í™˜
    let mut data = vec![0.0; m * n];
    for i in 0..m {
        for j in 0..n {
            data[i * n + j] = *a.at(i as i32, j as i32);
        }
    }
    let a_na = DMatrix::from_row_slice(m, n, &data);

    // 2. b â†’ DMatrix ë³€í™˜
    let b_na = DMatrix::from_column_slice(m, 1, b);

    // 3. SVD ìµœì†Œì œê³± í•´ ê³„ì‚°
    let svd = SVD::new(a_na, true, true);
    let x = svd.solve(&b_na, tol).expect("SVD solve failed");

    // 4. ê²°ê³¼ ë°˜í™˜: Vec<f64>
    x.column(0).iter().copied().collect()
}
```
```rust
/// ê³µí†µ í—¬í¼:
/// A x â‰ˆ b ìµœì†Œì œê³± í•´ë¥¼ SVD ê¸°ë°˜ìœ¼ë¡œ êµ¬í•œë‹¤.
/// ë‚´ë¶€ì ìœ¼ë¡œ:
///   - ì‘ì€/ë³´í†µ í¬ê¸° â†’ on_solve_least_squares_svd (ì§ì ‘ êµ¬í˜„ SVD)
///   - í° ì‹œìŠ¤í…œ      â†’ on_solve_least_squares_svd_na (nalgebra SVD)
pub fn on_solve_linear_system_svd(a: &Matrix, b: &Vec<Real>) -> Vec<f64> {
    let tol = ON_TOL6;
    let m = a.rows();
    let n = a.cols();
    assert_eq!(
        b.len(),
        m,
        "solve_linear_system_svd: b.len() must equal row_count of A"
    );

    // í¬ê¸° ê¸°ì¤€ì€ ì ë‹¹íˆ ì¡ì€ ê±°ë¼ í•„ìš”í•˜ë©´ ì¡°ì •í•´ë„ ë¨.
    // (ë„ˆë¬´ í° ì‹œìŠ¤í…œì€ nalgebra SVDê°€ ë” ì•ˆì •ì /ë¹ ë¥¼ ê°€ëŠ¥ì„±ì´ í¼)
    let size = m * n;

    if size <= 512 {
        // 1) ì§ì ‘ êµ¬í˜„í•œ SVD ê¸°ë°˜ ìµœì†Œì œê³±
        on_solve_least_squares_svd(a.clone(), b.as_slice(), tol)
    } else {
        // 2) nalgebra SVD ê¸°ë°˜ ìµœì†Œì œê³±
        on_solve_least_squares_svd_na(a.clone(), b.as_slice(), tol)
    }
}
```
```rust
/// ì§ì ‘ êµ¬í˜„í•œ SVD ê¸°ë°˜ ìµœì†Œì œê³± (Point4D ë²„ì „)
pub fn on_solve_least_squares_svd_point4d(a: Matrix, b: &[Point4D], tol: f64) -> Vec<Point4D> {
    let m = a.rows();
    let n = a.cols();
    assert_eq!(b.len(), m);

    // ì¢Œí‘œë³„ë¡œ RHSë¥¼ ë¶„ë¦¬
    let mut bx = vec![0.0; m];
    let mut by = vec![0.0; m];
    let mut bz = vec![0.0; m];
    let mut bw = vec![0.0; m];
    for i in 0..m {
        bx[i] = b[i].x;
        by[i] = b[i].y;
        bz[i] = b[i].z;
        bw[i] = b[i].w;
    }

    // ê° ì¢Œí‘œë³„ ìµœì†Œì œê³± í•´
    let x_sol = on_solve_least_squares_svd(a.clone(), &bx, tol);
    let y_sol = on_solve_least_squares_svd(a.clone(), &by, tol);
    let z_sol = on_solve_least_squares_svd(a.clone(), &bz, tol);
    let w_sol = on_solve_least_squares_svd(a.clone(), &bw, tol);

    // Point4Dë¡œ í•©ì„±
    let mut out = Vec::with_capacity(n);
    for i in 0..n {
        out.push(Point4D::non_homogeneous(
            x_sol[i], y_sol[i], z_sol[i], w_sol[i],
        ));
    }
    out
}
```
```rust
/// nalgebra SVD ê¸°ë°˜ ìµœì†Œì œê³± (Point4D ë²„ì „)
pub fn on_solve_least_squares_svd_point4d_na(a: Matrix, b: &[Point4D], tol: f64) -> Vec<Point4D> {
    let m = a.rows();
    let n = a.cols();
    assert_eq!(b.len(), m);

    // ì¢Œí‘œë³„ë¡œ RHS ë¶„ë¦¬
    let mut bx = vec![0.0; m];
    let mut by = vec![0.0; m];
    let mut bz = vec![0.0; m];
    let mut bw = vec![0.0; m];
    for i in 0..m {
        bx[i] = b[i].x;
        by[i] = b[i].y;
        bz[i] = b[i].z;
        bw[i] = b[i].w;
    }

    // nalgebra ê¸°ë°˜ ìµœì†Œì œê³± í•´ (ìŠ¤ì¹¼ë¼ ë²„ì „ í˜¸ì¶œ)
    let x_sol = on_solve_least_squares_svd_na(a.clone(), &bx, tol);
    let y_sol = on_solve_least_squares_svd_na(a.clone(), &by, tol);
    let z_sol = on_solve_least_squares_svd_na(a.clone(), &bz, tol);
    let w_sol = on_solve_least_squares_svd_na(a.clone(), &bw, tol);

    // Point4Dë¡œ í•©ì„±
    let mut out = Vec::with_capacity(n);
    for i in 0..n {
        out.push(Point4D::non_homogeneous(
            x_sol[i], y_sol[i], z_sol[i], w_sol[i],
        ));
    }
    out
}
```
```rust
/// ê³µí†µ í—¬í¼: A x â‰ˆ b ìµœì†Œì œê³± í•´ (RHS = Point4D)
/// ë‚´ë¶€ì ìœ¼ë¡œ:
///   - ì‘ì€/ë³´í†µ í¬ê¸° â†’ on_solve_least_squares_svd_point4d (ì§ì ‘ êµ¬í˜„ SVD)
///   - í° ì‹œìŠ¤í…œ      â†’ on_solve_least_squares_svd_point4d_na (nalgebra SVD)
pub fn on_solve_linear_system_svd_point4d(a: &Matrix, b: &Vec<Point4D>) -> Vec<Point4D> {
    let tol = ON_TOL6;
    let m = a.rows();
    let n = a.cols();
    assert_eq!(
        b.len(),
        m,
        "solve_linear_system_svd_point4d: b.len() must equal row_count of A"
    );

    let size = m * n;

    if size <= 512 {
        // 1) ì§ì ‘ êµ¬í˜„í•œ SVD ê¸°ë°˜ ìµœì†Œì œê³±
        on_solve_least_squares_svd_point4d(a.clone(), b.as_slice(), tol)
    } else {
        // 2) nalgebra SVD ê¸°ë°˜ ìµœì†Œì œê³±
        on_solve_least_squares_svd_point4d_na(a.clone(), b.as_slice(), tol)
    }
}
```
```rust
/// Piegl & Tiller ìŠ¤íƒ€ì¼ì˜ SVD ë˜í¼.
/// A: (m+1) x (n+1) í–‰ë ¬ (Uë¡œ overwrite)
/// W: singular values (n+1)
/// V: (n+1) x (n+1) orthogonal matrix
///
/// ë‚´ë¶€ êµ¬í˜„ì€ í˜„ëŒ€ì ì¸ Rust SVDë¥¼ ì‚¬ìš©í•œë‹¤.
pub fn on_svdcpf_wrapper(
    a: &mut Matrix, // (m+1) x (n+1)
    w: &mut [f64],  // length = n+1
    v: &mut Matrix, // (n+1) x (n+1)
    m: usize,
    n: usize,
) -> bool {
    // Pieglì€ m >= n ì¡°ê±´ì„ ìš”êµ¬
    if m < n {
        return false;
    }

    // AëŠ” (m+1)x(n+1) ì´ì–´ì•¼ í•œë‹¤
    if a.rows() != m + 1 || a.cols() != n + 1 {
        return false;
    }

    // 1) nalgebra ê¸°ë°˜ SVD ìˆ˜í–‰
    let mut data = vec![0.0; (m + 1) * (n + 1)];
    for i in 0..=m {
        for j in 0..=n {
            data[i * (n + 1) + j] = *a.at(i as i32, j as i32);
        }
    }

    let a_na = DMatrix::from_row_slice(m + 1, n + 1, &data);
    let svd = SVD::new(a_na.clone(), true, true);

    let u = match svd.u {
        Some(u) => u,
        None => return false,
    };
    let vt = match svd.v_t {
        Some(vt) => vt,
        None => return false,
    };

    // 2) W ì±„ìš°ê¸° (singular values)
    if w.len() != n + 1 {
        return false;
    }
    for i in 0..=n {
        w[i] = svd.singular_values[i];
    }

    // 3) A â† U (Pieglì€ Aë¥¼ Uë¡œ overwrite)
    for i in 0..=m {
        for j in 0..=n {
            *a.at_mut(i as i32, j as i32) = u[(i, j)];
        }
    }

    // 4) V â† V (nalgebraëŠ” Váµ€ì„ ì£¼ë¯€ë¡œ transpose)
    if !v.create(n + 1, n + 1) {
        return false;
    }
    let v_na = vt.transpose();
    for i in 0..=n {
        for j in 0..=n {
            *v.at_mut(i as i32, j as i32) = v_na[(i, j)];
        }
    }
    true
}
```
```rust
pub enum SvdsbfType {
    Real,
    Point,
    CPoint,
}
```
```rust
/// Wrapper for Pieglâ€™s M_SVDSBF using modern Rust SVD solvers.
/// Single Value Decomposition, substitution, full matrix
/// U: (me+1) x (nu+1)  â€” left singular vectors
/// W: singular values (nu+1)
/// V: (nu+1) x (nu+1)  â€” right singular vectors
///
/// rhs: right-hand side (REAL / Point3D / Point4D)
/// sol: output solution vector
pub fn on_svd_wrapper(
    u: &Matrix,
    w: &[f64],
    v: &Matrix,
    me: usize,
    nu: usize,
    rhs: &[f64], // REAL version
    sol: &mut [f64],
) -> bool {
    if nu > me {
        return false;
    }

    // Build Î£âº (pseudo-inverse of singular values)
    let mut w_inv = vec![0.0; nu + 1];
    let wmax = w.iter().cloned().fold(0.0, f64::max);
    let tol = wmax * (me as f64) * 1e-10;

    for i in 0..=nu {
        if w[i] > tol {
            w_inv[i] = 1.0 / w[i];
        } else {
            w_inv[i] = 0.0;
        }
    }

    // y = Uáµ€ rhs
    let mut y = vec![0.0; nu + 1];
    for i in 0..=nu {
        let mut acc = 0.0;
        for j in 0..=me {
            acc += u.get(j, i) * rhs[j];
        }
        y[i] = acc * w_inv[i];
    }

    // x = V y
    for i in 0..=nu {
        let mut acc = 0.0;
        for j in 0..=nu {
            acc += v.get(i, j) * y[j];
        }
        sol[i] = acc;
    }

    true
}
```
```rust
pub fn on_solve_linear_system_vec_svd(a: &[Vec<Real>], b: &[Real]) -> Option<Vec<Real>> {
    let n = a.len();
    if n == 0 || b.len() != n {
        return None;
    }
    if !a.iter().all(|r| r.len() == n) {
        return None;
    }

    // Aë¥¼ mutable ë³µì‚¬ (svdcmpê°€ overwrite)
    let mut u = a.to_vec();
    let mut w = vec![0.0; n];
    let mut v = vec![vec![0.0; n]; n];

    // --- SVD ---
    if !on_svdcmp_vec(&mut u, &mut w, &mut v) {
        return None;
    }

    let mut w_max = 0.0;
    for &x in &w {
        if x > w_max {
            w_max = x;
        }
    }
    let tol = w_max * 1e-6;

    // tmp = U^T * b / w
    let mut tmp = vec![0.0; n];
    for i in 0..n {
        if w[i] > tol {
            let mut s = 0.0;
            for j in 0..n {
                s += u[j][i] * b[j];
            }
            tmp[i] = s / w[i];
        } else {
            tmp[i] = 0.0; // singular direction ì œê±°
        }
    }

    // x = V * tmp
    let mut x = vec![0.0; n];
    for i in 0..n {
        for j in 0..n {
            x[i] += v[i][j] * tmp[j];
        }
    }

    Some(x)
}
```
```rust
pub fn on_solve_least_squares_svd_multi_na(a: &Matrix, bs: &[&[f64]], tol: f64) -> Vec<Vec<f64>> {
    let m = a.rows();
    let n = a.cols();
    assert!(!bs.is_empty());
    for b in bs {
        assert_eq!(b.len(), m, "all RHS vectors must have length m");
    }

    // 1. Matrix -> DMatrix
    let a_na = a.to_dmatrix(); // ì´ë¯¸ impl Into<DMatrix<f64>> ìˆìŒ

    // 2. ì˜¤ë¥¸ìª½ í•­ë“¤ì„ ì—´ë²¡í„°ë¡œ ìŒ“ì•„ì„œ (m x r) í–‰ë ¬ Bë¡œ ë§Œë“ ë‹¤.
    let r = bs.len();
    let mut b_data = Vec::with_capacity(m * r);
    for row in 0..m {
        for col in 0..r {
            b_data.push(bs[col][row]);
        }
    }
    let b_na = DMatrix::<f64>::from_column_slice(m, r, &b_data);

    // 3. SVD í•œ ë²ˆ
    let svd = SVD::new(a_na, true, true);
    let x = svd.solve(&b_na, tol).expect("SVD solve failed"); // (n x r)

    // 4. ì—´ë³„ë¡œ Vec<f64>ë¡œ ìª¼ê°œì„œ ë°˜í™˜
    let mut out = Vec::with_capacity(r);
    for col in 0..r {
        let mut v = Vec::with_capacity(n);
        for row in 0..n {
            v.push(x[(row, col)]);
        }
        out.push(v);
    }
    out
}
```
