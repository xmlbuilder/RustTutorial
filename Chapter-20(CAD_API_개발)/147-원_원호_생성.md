# NURBS ì›/ì›í˜¸ ìƒì„±ê¸°

## ğŸ“˜ Quintic NURBS Circle/Arc ìƒì„±ê¸° ì „ì²´ ë¬¸ì„œí™”
- ì´ ë¬¸ì„œëŠ” ë‹¤ìŒ í•¨ìˆ˜ë“¤ì˜ ìˆ˜í•™ì  ì •ì˜ì™€ ì•Œê³ ë¦¬ì¦˜ì„ ì„¤ëª…í•œë‹¤.
    - on_crv_point_inversion_by_newton
    - on_conic_arc_degree5_unit_tol
    - on_bezier5_extract_homogenous
    - on_bezier5_subdivide_homogenous
    - on_conic_circle_curve

## 1. on_crv_point_inversion_by_newton
- ëª©ì 
    - NURBS ê³¡ì„  C(u) ì— ëŒ€í•´, ì£¼ì–´ì§„ ì  P ì— ê°€ì¥ ê°€ê¹Œìš´ íŒŒë¼ë¯¸í„°  ë¥¼ Newton iterationìœ¼ë¡œ ì°¾ëŠ”ë‹¤.

- ìˆ˜í•™ì  ë°°ê²½
- ê³¡ì„  C(u) ì™€ ì  P ì‚¬ì´ì˜ ê±°ë¦¬ ì œê³±:
```math
f(u)=\| C(u)-P\| ^2
```
- Newton iterationì€ ë‹¤ìŒì„ ë°˜ë³µí•œë‹¤:
```math
u_{n+1}=u_n-\frac{f'(u_n)}{f''(u_n)}
```
- ì—¬ê¸°ì„œ:
```math
f'(u)=2C'(u)\cdot (C(u)-P)
```
```math
f''(u)=2\left( C''(u)\cdot (C(u)-P)+\| C'(u)\| ^2\right) 
```
- ë”°ë¼ì„œ Newton step:
```math
u_{n+1}=u_n-\frac{C'(u)\cdot (C(u)-P)}{C''(u)\cdot (C(u)-P)+\| C'(u)\| ^2}
```
- ì•Œê³ ë¦¬ì¦˜ ìš”ì•½
    - ì´ˆê¸°ê°’ u_0 ë¡œ ì‹œì‘
- ë°˜ë³µ:
    - C(u),C'(u),C''(u) ê³„ì‚°
    - ê±°ë¦¬, cosine ì¡°ê±´ ê²€ì‚¬
- Newton step ê³„ì‚°
    - íŒŒë¼ë¯¸í„° ë²”ìœ„ ë³´ì •
- ë³€í™”ëŸ‰ì´ ì‘ìœ¼ë©´ ì¢…ë£Œ

- ì¶œë ¥
    - (best_u, best_q, converged)
    - best_u: ìµœì†Œ ê±°ë¦¬ì˜ íŒŒë¼ë¯¸í„°
    - best_q: í•´ë‹¹ ì 
    - converged: Newton ìˆ˜ë ´ ì—¬ë¶€

### ì†ŒìŠ¤ ì½”ë“œ
```rust

fn on_crv_point_inversion_by_newton(
    cur: &NurbsCurve,
    p:Point3D,
    u0: f64,
    top: f64,
    toc: f64,
    it_lim: usize,
) -> (f64, Point3D, bool) {
    use crate::core::types::ON_TOL14;

    let (u_min, u_max) = (cur.domain.t0, cur.domain.t1);
    let closed = cur.is_closed();

    let mut k = 0usize;
    let mut u_new = u0;

    let mut best_u = u_new;
    let mut best_q = cur.eval_point(u_new);
    let mut best_dis = f64::INFINITY;

    let mut converged = false;

    while k < it_lim {
        // D[0], D[1], D[2]
        let q = cur.eval_point(u_new);
        let ders = cur.eval_ders_padded(u_new, 2);
        let d1 = ders.get(1).copied().unwrap_or_else(|| Vector3D::new(0.0,0.0,0.0));
        let d2 = ders.get(2).copied().unwrap_or_else(|| Vector3D::new(0.0,0.0,0.0));

        // V = D0 - P
        let v = &q - &p;

        // num = D1 Â· V
        let num = d1.dot(&v);

        // der = |D1|
        let der = d1.length();

        // dis = |V|
        let dis = v.length();

        // best ê°±ì‹  (C: best_dis)
        if dis < best_dis {
            best_dis = dis;
            best_u = u_new;
            best_q = q;
        }

        // Check #1: point coincidence
        if dis <= top {
            converged = true;
            break;
        }

        // Check #2: zero cosine  (|num|/(der*dis) <= toc)
        // C: division ì²´í¬ (der*dis == 0)
        let denom_zco = der * dis;
        if denom_zco.abs() <= ON_TOL14 {
            // CëŠ” CON_ERR ì²˜ë¦¬ì§€ë§Œ bestëŠ” ë°˜í™˜
            break;
        }
        let zco = (num.abs()) / denom_zco;
        if zco <= toc {
            converged = true;
            break;
        }

        // den = (D2 Â· V) + der^2
        let dot = d2.dot(&v);
        let den = dot + der * der;

        // division ì²´í¬
        if den.abs() <= ON_TOL14 {
            break;
        }

        // Newton update: unew = uold - num/den
        let u_old = u_new;
        u_new = u_old - num / den;

        // Check #3: parameter range
        if closed {
            // C: wrap to [U[0], U[m]]
            // ì—¬ê¸°ì„œëŠ” domainì„ ì‚¬ìš©
            let span = u_max - u_min;
            if span > 0.0 {
                while u_new < u_min { u_new += span; }
                while u_new > u_max { u_new -= span; }
            } else {
                u_new = u_min;
            }
        } else {
            if u_new < u_min { u_new = u_min; }
            if u_new > u_max { u_new = u_max; }
        }

        // Check #4: parameter change  fabs((unew-uold)*der) <= top
        if ((u_new - u_old) * der).abs() <= top {
            converged = true;
            break;
        }

        k += 1;
    }
    (best_u, best_q, converged)
}
```

## 2. on_conic_arc_degree5_unit_tol
- ëª©ì 
- ë‹¨ìœ„ ì›(unit circle) ì— ëŒ€í•´
- ì‹œì‘ê° as_deg, ëê° ae_deg ë¥¼ ê°–ëŠ” quintic Bezier NURBS ì›í˜¸ë¥¼ ìƒì„±í•œë‹¤.

- ì „ì²´ ì•Œê³ ë¦¬ì¦˜ íë¦„
### 1) ì…ë ¥ ê°ë„ ì •ê·œí™”
```math
\theta =ae-as
```
- 360Â° ì´ˆê³¼ ì‹œ clamp.

### 2) full quintic Bezier circle ìƒì„±
- í•­ìƒ 360Â° ì›ì„ ë¨¼ì € ë§Œë“ ë‹¤.

### 3) ì›í˜¸ì˜ ì‹œì‘ì /ëì  ê³„ì‚°
- ë‹¨ìœ„ ì›ì—ì„œ:
```math
P_s=(\cos (as),\sin (as))
```
```math
P_e=(\cos (ae),\sin (ae))
```
### 4) Newton ê¸°ë°˜ point inversionìœ¼ë¡œ us, ue ì°¾ê¸°
- ì´ˆê¸°ê°’:
```math
am=\frac{as+ae}{2}
```

- Newton iterationìœ¼ë¡œ:
```math
u_s=\arg \min _u\| C(u)-P_s\|
```
```math 
u_e=\arg \min _u\| C(u)-P_e\| 
```
### 5) Bezier êµ¬ê°„ ì¶”ì¶œ (Cì˜ N_toocsg)
- Bezier5ëŠ” ë‹¨ì¼ ì„¸ê·¸ë¨¼íŠ¸ì´ë¯€ë¡œ
- ë‘ ë²ˆì˜ subdivisionìœ¼ë¡œ [us, ue] êµ¬ê°„ì„ ì¶”ì¶œí•œë‹¤.

### 6) Knot vector êµ¬ì„±
- degree=5 â†’ clamped Bezier:
```rust
U=[0,0,0,0,0,0,1,1,1,1,1,1]
```
### 7) ê²°ê³¼ NURBS ë°˜í™˜

### ì†ŒìŠ¤ ì½”ë“œ
```rust
pub fn on_conic_arc_degree5_unit_tol(
    as_deg: f64,
    ae_deg: f64,
    m_tol: f64
) -> crate::core::prelude::Result<NurbsCurve> {
    let (as_deg, ae_deg, theta) = on_normalize_sweep_degree(as_deg, ae_deg);

    // 1) full quintic Bezier circle
    let full = on_conic_circle_degree5_unit_tol(as_deg, ae_deg, m_tol)?;

    // full sweep
    if (theta - 360.0).abs() < 1e-12 {
        return Ok(full);
    }

    // 2) endpoints on unit circle
    let ps = on_point_on_unit_circle_deg(as_deg);
    let pe = on_point_on_unit_circle_deg(ae_deg);

    // ---- C: compute am and seed u0 (must match on_conic_degree5_unit seam) ----
    let mut am = 0.5 * (as_deg + ae_deg);
    if as_deg < ae_deg { am += 180.0; }

    // dangle = as - am (mod 360)
    let mut dangle_s = as_deg - am;
    if dangle_s < 0.0 { dangle_s = 360.0 + dangle_s; }
    let u0s = dangle_s / 360.0;

    let mut dangle_e = ae_deg - am;
    if dangle_e < 0.0 { dangle_e = 360.0 + dangle_e; }
    let u0e = dangle_e / 360.0;

    // 3) C: N_gprpin(cur, P, u0, MTOL, MTOL, &us, &Qs)
    //    - ìˆ˜ë ´ ì‹¤íŒ¨ ì‹œì—ë„ bestë¥¼ ì£¼ì§€ë§Œ, N_conci5ëŠ” errorë¡œ OUT í•˜ë¯€ë¡œ ì—¬ê¸°ì„œë„ ì‹¤íŒ¨ ì²˜ë¦¬
    let itlim = 50usize; // Cì˜ ITLIM ì—­í•  (í”„ë¡œì íŠ¸ ì „ì—­ ìƒìˆ˜ë¡œ ë¹¼ë„ ë¨)

    let (us, _qs, ok_s) = on_crv_point_inversion_by_newton(&full, ps, u0s, m_tol, m_tol, itlim);
    if !ok_s {
        return Err(NurbsError::NoConvergence);
    }

    let (ue, _qe, ok_e) = on_crv_point_inversion_by_newton(&full, pe, u0e, m_tol, m_tol, itlim);
    if !ok_e {
        return Err(NurbsError::NoConvergence);
    }

    // 4) CëŠ” N_toocsg ë¡œ subcurve ì¶”ì¶œ (Bezier segment), ìš°ë¦¬ëŠ” homogeneous Bezier segment ì¶”ì¶œ ìœ ì§€
    if full.ctrl.len() != 6 || full.degree != 5 {
        return Err(NurbsError::InvalidInput { msg: "Invalid input".into() });
    }
    let cp: [Point4D; 6] = [
        full.ctrl[0], full.ctrl[1], full.ctrl[2],
        full.ctrl[3], full.ctrl[4], full.ctrl[5],
    ];

    // seam-crossing: CëŠ” closed wrappingì´ ê°€ëŠ¥í•˜ì§€ë§Œ,
    // ì—¬ê¸°ì„œëŠ” "ë‹¨ì¼ Bezier ì„¸ê·¸ë¨¼íŠ¸" ì •ì±…ì„ ìœ ì§€í•œë‹¤ë©´ us<ueë§Œ í—ˆìš©
    if ue <= us {
        return Err(NurbsError::Unsupported { feature: "seam-crossing arc on single Bezier".into() });
    }

    let seg_cp = on_bezier5_extract_homogenous(&cp, us, ue);

    let kv = KnotVector::new(vec![
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    ])?;

    let out = NurbsCurve {
        dimension: 3,
        degree: 5,
        ctrl: seg_cp.to_vec(),
        kv,
        domain: Interval { t0: 0.0, t1: 1.0 },
    };

    // endpoint sanity (ì„ íƒ)
    let p0 = out.eval_point(0.0);
    let p1 = out.eval_point(1.0);
    if p0.distance_square(&ps) > m_tol * m_tol * 100.0 { return Err(NurbsError::NoConvergence); }
    if p1.distance_square(&pe) > m_tol * m_tol * 100.0 { return Err(NurbsError::NoConvergence); }

    Ok(out)
}
```

## 3. on_bezier5_extract_homogenous
- ëª©ì 
    - Bezier5 ê³¡ì„ ì—ì„œ íŒŒë¼ë¯¸í„° êµ¬ê°„ [a,b] ë§Œ ì¶”ì¶œí•œë‹¤.

- ìˆ˜í•™ì  ì›ë¦¬
    - Bezier ê³¡ì„ ì€ De Casteljau subdivisionìœ¼ë¡œ ì„ì˜ì˜ êµ¬ê°„ì„ ì •í™•í•˜ê²Œ ì˜ë¼ë‚¼ ìˆ˜ ìˆë‹¤.
- ë‘ ë‹¨ê³„:
    - $t=a$ ì—ì„œ subdivision â†’ ì˜¤ë¥¸ìª½ ê³¡ì„  R
    - $t=\frac{b-a}{1-a}$ ì—ì„œ ë‹¤ì‹œ subdivision â†’ ì™¼ìª½ ê³¡ì„  L
- ê²°ê³¼ L ì´ [a,b] êµ¬ê°„ì˜ Bezier5.
```rust
pub fn on_bezier5_extract_homogenous(cp: &[Point4D; 6], a: f64, b: f64) -> [Point4D; 6] {
    // Extract [a,b] from Bezier using two subdivisions:
    // 1) split at a => take right
    // 2) split that right at t=(b-a)/(1-a) => take left
    if b <= a {
        return *cp; // caller should avoid seam case; keep safe no-op
    }
    let a = a.clamp(0.0, 1.0);
    let b = b.clamp(0.0, 1.0);
    if (b - a) < 1e-15 {
        return *cp;
    }

    let (_l1, r1) = on_bezier5_subdivide_homogenous(cp, a);
    let t2 = (b - a) / (1.0 - a);
    let (l2, _r2) = on_bezier5_subdivide_homogenous(&r1, t2);
    l2
}
```
## 4. on_bezier5_subdivide_homogenous
- ëª©ì 
    - Bezier5ë¥¼ tì—ì„œ ë‘ ê°œì˜ Bezier5ë¡œ ë¶„í• .

- ìˆ˜í•™ì  ì›ë¦¬
    - De Casteljau ì•Œê³ ë¦¬ì¦˜:
```math
P_i^{(0)}=P_i
```
```math
P_i^{(k)}=(1-t)P_i^{(k-1)}+tP_{i+1}^{(k-1)}
```
- ìµœì¢…:
- left: $P_0^{(0)},P_0^{(1)},P_0^{(2)},P_0^{(3)},P_0^{(4)},P_0^{(5)}$
- right: $P_0^{(5)},P_1^{(4)},P_2^{(3)},P_3^{(2)},P_4^{(1)},P_5^{(0)}$


```rust

pub fn on_bezier5_subdivide_homogenous(cp: &[Point4D; 6], t: f64) -> ([Point4D; 6], [Point4D; 6]) {
    // de Casteljau in homogeneous 4D
    let lerp = |a: Point4D, b: Point4D, t: f64| -> Point4D {
        Point4D::non_homogeneous(
            a.x + (b.x - a.x) * t,
            a.y + (b.y - a.y) * t,
            a.z + (b.z - a.z) * t,
            a.w + (b.w - a.w) * t,
        )
    };

    let p0 = cp[0];
    let p1 = cp[1];
    let p2 = cp[2];
    let p3 = cp[3];
    let p4 = cp[4];
    let p5 = cp[5];

    let q0 = lerp(p0, p1, t);
    let q1 = lerp(p1, p2, t);
    let q2 = lerp(p2, p3, t);
    let q3 = lerp(p3, p4, t);
    let q4 = lerp(p4, p5, t);

    let r0 = lerp(q0, q1, t);
    let r1 = lerp(q1, q2, t);
    let r2 = lerp(q2, q3, t);
    let r3 = lerp(q3, q4, t);

    let s0 = lerp(r0, r1, t);
    let s1 = lerp(r1, r2, t);
    let s2 = lerp(r2, r3, t);

    let u0 = lerp(s0, s1, t);
    let u1 = lerp(s1, s2, t);

    let v0 = lerp(u0, u1, t); // point on curve at t

    let left = [p0, q0, r0, s0, u0, v0];
    let right = [v0, u1, s2, r3, q4, p5];
    (left, right)
}

```

## 5. on_conic_circle_curve
- ëª©ì 
- 3D ê³µê°„ì—ì„œ
    - ì¤‘ì‹¬ center
    - ë‘ ì§êµ ì¶• x_axis, y_axis
    - ë°˜ì§€ë¦„ radius
    - ê°ë„ êµ¬ê°„ [as_deg, ae_deg]
- ì„ ê°–ëŠ” ì›/ì›í˜¸ë¥¼ Quadratic / Quartic / Quintic NURBS ì¤‘ í•˜ë‚˜ë¡œ ìƒì„±.

- Quintic ëª¨ë“œ íë¦„
    - ë‹¨ìœ„ ì›ì—ì„œ quintic arc ìƒì„±
        - on_conic_arc_degree5_unit_tol
    - ì´ë¥¼ 3D circleë¡œ ë§¤í•‘:
```math
P=center+radius\cdot (x\_ axis\cdot u_x+y\_ axis\cdot u_y)
```
- ì—¬ê¸°ì„œ (u_x,u_y) ëŠ” unit circle NURBSì˜ Euclidean ì¢Œí‘œ.
- weightëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€.

### ì†ŒìŠ¤ ì½”ë“œ
```rust
pub fn on_conic_circle_curve(
    center: Point3D,
    mut x_axis: Vector3D,
    mut y_axis: Vector3D,
    radius: Real,
    as_deg: Real,
    ae_deg: Real,
    ctp: CircleDegree,
    m_tol: Real, // used by quintic inversion check (C: MTOL)
) -> Result<NurbsCurve, NurbsError> {
    if radius <= ON_ZERO_TOL {
        return Err(NurbsError::InvalidInput { msg: "radius <= 0".into() });
    }
    if !(ae_deg > as_deg) {
        return Err(NurbsError::InvalidInput { msg: "ae <= as".into() });
    }
    if !x_axis.is_valid() || !y_axis.is_valid() {
        return Err(NurbsError::InvalidInput { msg: "invalid axis".into() });
    }

    // Cì—ì„œë„ X,Y normalizeë¥¼ ê°•ì œ(G_vecnip)
    x_axis.normalize_safe();
    y_axis.normalize_safe();

    match ctp {
        CircleDegree::Quadratic => {
            // ë„¤ê°€ ì´ë¯¸ ë§Œë“  rad ê¸°ë°˜ quadratic arcë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©
            let as_rad = as_deg.to_radians();
            let ae_rad = ae_deg.to_radians();
            on_make_circle_curve_quadratic(center, x_axis, y_axis, radius, as_rad, ae_rad)
                .ok_or(NurbsError::InvalidInput { msg: "failed quadratic arc".into() })
        }
        CircleDegree::Quintic => {
            // 1) unit quintic arc (XY, r=1, origin) â€” ì´ë¯¸ êµ¬í˜„ë¼ìˆìŒ
            let unit = on_conic_arc_degree5_unit_tol(as_deg, ae_deg, m_tol).expect("Invalid NurbsCurve");

            // 2) map unit arc -> 3D circle (center, axes, radius)
            Ok(on_map_unit_circle_curve_to_3d(&unit, center, x_axis, y_axis, radius))
        }
        CircleDegree::Quartic => {
            // 1) unit quartic arc (XY, r=1, origin)
            let unit = on_conic_degree4_unit(as_deg, ae_deg)?;

            // 2) map unit arc -> 3D circle
            Ok(on_map_unit_circle_curve_to_3d(&unit, center, x_axis, y_axis, radius))
        }
    }
}
```

## ğŸ“Œ ì „ì²´ íë¦„ ìš”ì•½ ë‹¤ì´ì–´ê·¸ë¨
```
Arc(as, ae)
   â†“
normalize sweep
   â†“
full quintic Bezier circle (unit)
   â†“
compute Ps, Pe
   â†“
Newton inversion â†’ us, ue
   â†“
Bezier subdivision â†’ [us, ue]
   â†“
Bezier5 arc (unit)
   â†“
map to 3D circle (center, axes, radius)
   â†“
Final Quintic NURBS Arc
```


## ğŸ‰ ë§ˆë¬´ë¦¬
ì´ì œ ë„¤ê°€ ì‘ì„±í•œ Rust ì½”ë“œ ì „ì²´ê°€:
- Newton ê¸°ë°˜ point inversionê¹Œì§€ ì™„ì „ ì¬í˜„
- Bezier subdivision ê¸°ë°˜ arc extraction ì™„ì „ êµ¬í˜„
- Arc â†’ NURBS ë³€í™˜ê¹Œì§€ ì™„ì„±

---

## Quintic NURBS Full Circle

### 1. ëª©ì 
- ë‹¨ì¼ Bezier ê³¡ì„ (degree 5, control points 6ê°œ) ë¡œ  
    ì •í™•í•œ ì›(circle)ì„ í‘œí˜„í•˜ëŠ” NURBSë¥¼ ìƒì„±í•œë‹¤.
    - ë‚´ë¶€ knot ì—†ìŒ
    - knot vector = [0Ã—6, 1Ã—6]
    - control point 6ê°œ
    - weight íŒ¨í„´ì´ ì •í™•íˆ ì›ì„ ì¬í˜„í•˜ë„ë¡ ì„¤ê³„ë¨

### 2. ìˆ˜í•™ì  ë°°ê²½
- ì›ì€ rational Bezierë¡œ ì •í™•í•˜ê²Œ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.
- degree 2(Quadratic)ë¡œëŠ” 90Â° ì´í•˜ë§Œ ì •í™•í•˜ê²Œ í‘œí˜„ ê°€ëŠ¥í•˜ì§€ë§Œ,
- degree 5(Quintic)ì—ì„œëŠ” 360Â° ì „ì²´ë¥¼ ë‹¨ì¼ Bezierë¡œ ì •í™•í•˜ê²Œ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.
- ì´ë•Œ control pointëŠ” ë‹¤ìŒê³¼ ê°™ì€ êµ¬ì¡°ë¥¼ ê°€ì§„ë‹¤:
```math
P_0=P_5=\mathrm{ì¤‘ì‹¬ê°\  }180\degree \mathrm{\  ìœ„ì¹˜ì˜\  ì \  (midpoint)}
```
```math
P_1,P_4=P_m\pm 4rT
```
```math
P_2,P_3=C+3rS\pm 2rT
```
- ì—¬ê¸°ì„œ:
    - C: ì›ì˜ ì¤‘ì‹¬
    - r: ë°˜ì§€ë¦„
    - T: ì¤‘ì‹¬ê° 180Â°ì—ì„œì˜ tangent ë°©í–¥
    - S: ì¤‘ì‹¬ê° 180Â°ì—ì„œì˜ normal ë°©í–¥

### 3. ì¢Œí‘œê³„ ì •ì˜
- ì½”ë“œì—ì„œ:
- Pm = midpoint (angle = am)
- T = tangent at midpoint
- S = normal at midpoint

- ë‹¨ìœ„ ì› ê¸°ì¤€:
```math
Pm=(\cos (\pi ),\sin (\pi ))=(-1,0)
```
```math
T=(0,-1)
```
```math
S=(-1,0)
```

### 4. Control Point ê³µì‹
- Pâ‚€, Pâ‚… (weight = 5)
```math
P_0=P_5=P_m\cdot 5
```
- Pâ‚, Pâ‚„ (weight = 1)
```math
P_1=P_m+4rT
```
```math
P_4=P_m-4rT
```
- Pâ‚‚, Pâ‚ƒ (weight = 1)
```math
P_2=C+3rS+2rT
```
```math
P_3=C+3rS-2rT
```
### 5. Knot Vector
- degree = 5 â†’ clamped Bezier:
- U=[0,0,0,0,0,0,1,1,1,1,1,1]

### 6. Rust êµ¬í˜„
```rust
pub fn on_conic_circle_degree5_unit_tol(as_deg: f64, ae_deg: f64, m_tol: f64) -> crate::core::prelude::Result<NurbsCurve> {
    let (as_deg, ae_deg, theta) = on_normalize_sweep_degree(as_deg, ae_deg);

    // 1) full quintic Bezier circle (knots 0x6,1x6)
    let full = on_conic_circle_degree5_unit(as_deg, ae_deg)?;

    // full sweep
    if (theta - 360.0).abs() < 1e-12 {
        return Ok(full);
    }

    // 2) target endpoints on unit circle
    let ps = on_point_on_unit_circle_deg(as_deg);
    let pe = on_point_on_unit_circle_deg(ae_deg);

    // 3) find us, ue by robust distance minimization (Cì˜ N_gprpin ì—­í• )
    //    - full.ctrlì€ í•­ìƒ 6ê°œ(Bezier)
    if full.ctrl.len() != 6 || full.degree != 5 {
        return Err(NurbsError::InvalidInput {
            msg: "Invalid input".into(),
        });
    }
    let cp: [Point4D; 6] = [
        full.ctrl[0],
        full.ctrl[1],
        full.ctrl[2],
        full.ctrl[3],
        full.ctrl[4],
        full.ctrl[5],
    ];

    let us = on_bezier5_find_param_by_distance_min(&cp, ps);
    let ue = on_bezier5_find_param_by_distance_min(&cp, pe);

    // seam-crossingì€ ì—¬ê¸°ì„  ì§€ì›í•˜ì§€ ì•ŠìŒ (ë‹¨ì¼ Bezier ì •ì±… ìœ ì§€)
    if ue <= us {
        return Err(NurbsError::Unsupported {
            feature: "Unsupported",
        });
    }

    // 4) extract Bezier segment, keep Bezier knots (Cì˜ â€œë¶€ë¶„ê°ë„ì—ì„œë„ ë‚´ë¶€ knot ì—†ìŒâ€ ìœ ì§€)
    let seg_cp = on_bezier5_extract_homogenous(&cp, us, ue);

    // 5) build output curve with Bezier knots 0x6,1x6
    let kv = KnotVector::new(vec![
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    ])?;
    let out = NurbsCurve {
        dimension: 3,
        degree: 5,
        ctrl: seg_cp.to_vec(),
        kv,
        domain: Interval { t0: 0.0, t1: 1.0 },
    };

    // 6) endpoint sanity (ì„ íƒ)
    let p0 = out.eval_point(0.0);
    let p1 = out.eval_point(1.0);
    if p0.distance_square(&ps) > m_tol * m_tol * 100.0 {
        return Err(NurbsError::NoConvergence);
    }
    if p1.distance_square(&pe) > m_tol * m_tol * 100.0 {
        return Err(NurbsError::NoConvergence);
    }
    Ok(out)
}
```

### 7. ì „ì²´ ì•Œê³ ë¦¬ì¦˜ ìš”ì•½
- ì…ë ¥: unit circle (center=(0,0,0), radius=1, XY-plane)

#### 1) midpoint angle am = 180Â°
#### 2) compute Pm, T, S
#### 3) compute control points:
- P0 = Pm * 5
- P1 = Pm + 4*T
- P2 = C + 3*S + 2*T
- P3 = C + 3*S - 2*T
- P4 = Pm - 4*T
- P5 = Pm * 5
#### 4) assign weights: [5,1,1,1,1,5]
#### 5) knot vector = [0Ã—6, 1Ã—6]
#### 6) return NurbsCurve



### 8. ì™œ weight = 5ì¸ê°€?
- Quintic Bezierì—ì„œ ì›ì„ ì •í™•í•˜ê²Œ í‘œí˜„í•˜ë ¤ë©´ Bezier basisì™€ ì›ì˜ ê³¡ë¥ ì„ ë§ì¶”ê¸° ìœ„í•´  
    íŠ¹ì • weight ë¹„ìœ¨ì´ í•„ìš”í•˜ë‹¤.
- ì½”ë“œì—ì„œ:

```
A_weight(Pm, 5.0, &Pw[0]);
A_weight(Pm, 5.0, &Pw[5]);
```

- ì¦‰, ì–‘ ë control pointì˜ weightëŠ” 5ë¡œ ê³ ì •ëœë‹¤.
- ì´ëŠ” ì›ì˜ ì¤‘ì‹¬ê° 180Â°ì—ì„œì˜ ê³¡ë¥ ì„ ì •í™•íˆ ë§ì¶”ê¸° ìœ„í•œ ê°’ì´ë‹¤.

### 9. ì´ full circleì€ ì™œ arc ìƒì„±ì˜ ê¸°ë°˜ì¸ê°€?
- í•­ìƒ ë‹¤ìŒ ìˆœì„œë¡œ ë™ì‘í•œë‹¤:
    - full circle quintic Bezier ìƒì„±
    - arcë¼ë©´ Newton inversionìœ¼ë¡œ us, ue ì°¾ê¸°
    - full circleì—ì„œ [us, ue] êµ¬ê°„ë§Œ ì˜ë¼ë‚´ê¸°
- ì¦‰, full circleì€ í•­ìƒ ê¸°ë°˜(base) ì´ë‹¤.

---

## on_bezier5_find_param_by_distance_min

- ì´ í•¨ìˆ˜ëŠ” Bezier5 ê³¡ì„ ì—ì„œ ì  Pì™€ì˜ ê±°ë¦¬ ì œê³±ì„ ìµœì†Œí™”í•˜ëŠ” íŒŒë¼ë¯¸í„° uë¥¼ ì°¾ëŠ” 1D ìµœì í™” ì•Œê³ ë¦¬ì¦˜.
- Newton ë°©ì‹ì´ ì•„ë‹ˆë¼ ë¸Œë ŒíŠ¸(Brent) ìµœì†Œí™” ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•œë‹¤ëŠ” ì ì´ í•µì‹¬


## ğŸ¯ ë¬¸ì œ ì •ì˜
- ìš°ë¦¬ê°€ í’€ê³  ì‹¶ì€ ë¬¸ì œ.
- ëª©í‘œ í•¨ìˆ˜
```math
g(u)=\| C(u)-P\| ^2
```
- ì—¬ê¸°ì„œ
    - C(u): Bezier5 ê³¡ì„ 
    - P: ì£¼ì–´ì§„ ì  
    - $u\in [0,1]$
- ëª©í‘œ
    - ì¦‰, ê³¡ì„ ì—ì„œ Pì— ê°€ì¥ ê°€ê¹Œìš´ ì ì˜ íŒŒë¼ë¯¸í„° uë¥¼ ì°¾ëŠ” ë¬¸ì œ.

## ğŸ§  ì™œ Newton ëŒ€ì‹  Brentì¸ê°€?
- Newton ë°©ì‹ì€:
    - 1ì°¨/2ì°¨ ë¯¸ë¶„ í•„ìš”
    - ì´ˆê¸°ê°’ì´ ë‚˜ì˜ë©´ ë°œì‚°
    - ê³¡ì„ ì´ ë³µì¡í•˜ë©´ ì˜ëª»ëœ local minimumìœ¼ë¡œ ë¹ ì§ˆ ìˆ˜ ìˆìŒ
- ë°˜ë©´ Brent ìµœì†Œí™” ì•Œê³ ë¦¬ì¦˜ì€:
    - ë¯¸ë¶„ ë¶ˆí•„ìš”
    - í•­ìƒ ìˆ˜ë ´
    - 1D êµ¬ê°„ì—ì„œ ë§¤ìš° ì•ˆì •ì 
    - ì „ì—­ ìµœì†Œê°’ì— ë” ê°€ê¹Œì›€
- ê·¸ë˜ì„œ ì•ˆì •ì„±ì´ í•„ìš”í•  ë•Œ Brentë¥¼ ì‚¬ìš©í•œë‹¤.

## ğŸ“Œ ì „ì²´ ì•Œê³ ë¦¬ì¦˜ êµ¬ì¡°
- í•¨ìˆ˜ëŠ” ë‘ ë‹¨ê³„ë¡œ êµ¬ì„±ëœë‹¤.

- 1ë‹¨ê³„: Coarse Sampling (ì´ˆê¸° bracket ì°¾ê¸°)
```rust
for i in 0..=n {
    let u = i / n;
    let g = ||C(u)-P||^2;
    best_u = argmin g
}
```

- ì¦‰:
    - [0,1]ì„ 200ê°œë¡œ ê· ë“± ë¶„í• 
    - ê° ì§€ì ì—ì„œ ê±°ë¦¬ ì œê³±ì„ ê³„ì‚°
    - ê°€ì¥ ì‘ì€ ì§€ì ì„ ì°¾ìŒ â†’ best_u
- ì´ê±´ ì´ˆê¸° ì¶”ì •ê°’ì„ ì°¾ê¸° ìœ„í•œ coarse search.

- 2ë‹¨ê³„: Brent Minimization
- ì´ˆê¸° bracket:
```math
[a,b]=[best\_ u-\Delta ,\; best\_ u+\Delta ]
```
- ì—¬ê¸°ì„œ $\Delta =1/n$.
- ì´ì œ Brent ì•Œê³ ë¦¬ì¦˜ì„ ì ìš©í•œë‹¤.

## ğŸ” Brent ì•Œê³ ë¦¬ì¦˜ ìˆ˜ì‹ ì •ë¦¬
- BrentëŠ” ë‹¤ìŒ ì„¸ ê°€ì§€ ê¸°ë²•ì„ í˜¼í•©í•´ì„œ ì‚¬ìš©í•œë‹¤.
- Golden Section Search
    - ë¯¸ë¶„ ì—†ì´ë„ êµ¬ê°„ì„ ì¤„ì—¬ë‚˜ê°€ëŠ” ì•ˆì •ì  ë°©ë²•
    - ë¹„ìœ¨ $c=\frac{3-\sqrt{5}}{2}\approx 0.381966$
- Parabolic Interpolation
    - ìµœê·¼ ì„¸ ì  (x,w,v)ì„ ì´ìš©í•´ 2ì°¨ ê³¡ì„ ì„ ê·¼ì‚¬í•˜ê³  ìµœì†Œì ì„ ì˜ˆì¸¡
    - ë¹ ë¥´ê²Œ ìˆ˜ë ´í•  ìˆ˜ ìˆìŒ
- Fallback
    - Parabolic stepì´ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ Golden Sectionìœ¼ë¡œ ëŒì•„ê°

## ğŸ“ Brentì˜ í•µì‹¬ ìˆ˜ì‹
### 1) Parabolic step
- ì„¸ ì  (x,w,v)ì—ì„œì˜ í•¨ìˆ˜ê°’ $(f_x,f_w,f_v)$ ì„ ì´ìš©í•´  
    ë‹¤ìŒê³¼ ê°™ì€ 2ì°¨ì‹ì˜ ìµœì†Œì ì„ ì°¾ëŠ”ë‹¤.
```math
u=x-\frac{(x-w)^2(f_x-f_v)-(x-v)^2(f_x-f_w)}{2[(x-w)(f_x-f_v)-(x-v)(f_x-f_w)]}
```
- Rust ì½”ë“œì—ì„œëŠ”:
```rust
r = (x - w) * (fx - fv);
q = (x - v) * (fx - fw);
p = (x - v) * q - (x - w) * r;
q = 2.0 * (q - r);
```

- ì´ê²Œ ë°”ë¡œ ìœ„ ìˆ˜ì‹ì„ ì •ë¦¬í•œ í˜•íƒœ.

### 2) Golden Section step
- Parabolic stepì´ ì‹¤íŒ¨í•˜ê±°ë‚˜ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ë©´:
```math
d=c\cdot (m-x)
```
- ì—¬ê¸°ì„œ
    - $m=(a+b)/2$ (êµ¬ê°„ ì¤‘ì•™)
    - $c=(3-\sqrt{5})/2$
- Rust ì½”ë“œì—ì„œëŠ”:
```math
e = if x >= m { a - x } else { b - x };
d = c * e;
```

### 3) ìƒˆë¡œìš´ í›„ë³´ì 
```math
u=x+\mathrm{step}
```
ì—¬ê¸°ì„œ stepì€:
- parabolic stepì´ ìœ íš¨í•˜ë©´ parabolic step
- ì•„ë‹ˆë©´ golden section step

### 4) êµ¬ê°„ ì—…ë°ì´íŠ¸
- ìƒˆë¡œìš´ ì  uì˜ í•¨ìˆ˜ê°’ fuì— ë”°ë¼:
    - fu < fx â†’ uê°€ ìƒˆë¡œìš´ ìµœì†Œì  í›„ë³´
    - ì•„ë‹ˆë©´ êµ¬ê°„ì„ ì¤„ì„
- Rust ì½”ë“œ:
```rust
if fu <= fx {
    if u >= x { a = x; } else { b = x; }
    ...
    x = u;
    fx = fu;
} else {
    if u < x { a = u; } else { b = u; }
    ...
}
```


### ğŸ¯ ìµœì¢… ê²°ê³¼
- ìµœì¢…ì ìœ¼ë¡œ:
- ì´ ê°’ì´ ê±°ë¦¬ ì œê³±ì„ ìµœì†Œí™”í•˜ëŠ” íŒŒë¼ë¯¸í„°.

### ğŸ“Œ ì´ í•¨ìˆ˜ì˜ ì¥ì 
- ë¯¸ë¶„ í•„ìš” ì—†ìŒ
- í•­ìƒ ìˆ˜ë ´
- local minimumì— ëœ ë¯¼ê°
- Bezier5ì²˜ëŸ¼ ë³µì¡í•œ ê³¡ì„ ì—ì„œë„ ì•ˆì •ì 
- Newton ë°©ì‹ë³´ë‹¤ robust

## ğŸ‰ ìš”ì•½
- ì´ í•¨ìˆ˜ëŠ” ë‹¤ìŒ ë¬¸ì œë¥¼ í‘¸ëŠ” ì•ˆì •ì  1D ìµœì í™” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.
- ë°©ë²•:
    - coarse samplingìœ¼ë¡œ ì´ˆê¸° bracket ì°¾ê¸°
    - Brent ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ì •ë°€ ìµœì†Œí™”
    - parabolic + golden section í˜¼í•©
    - ìµœì¢…ì ìœ¼ë¡œ ì•ˆì •ì ì´ê³  ì •í™•í•œ u ë°˜í™˜
