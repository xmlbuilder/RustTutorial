## ğŸ“˜ Robust Pointâ€“Segment Distance
- Why the Improved Version Is More Stable (Even Though the Math Looks the Same)
- ì´ ë¬¸ì„œëŠ” ë‘ ê°€ì§€ pointâ€“segment ê±°ë¦¬ ê³„ì‚° í•¨ìˆ˜ì˜ ì°¨ì´ë¥¼  
    ìˆ˜í•™ì  ê³µì‹ì´ ì•„ë‹ˆë¼ ìˆ˜ì¹˜ì  ì•ˆì •ì„±(numerical robustness) ê´€ì ì—ì„œ ì„¤ëª…í•œë‹¤.

### 1. Overview
- Pointâ€“Segment ê±°ë¦¬ ê³„ì‚°ì€ CAD/NURBS ì—”ì§„ì—ì„œ ë§¤ìš° ì¤‘ìš”í•œ ê¸°ë³¸ ì—°ì‚°ì´ë‹¤.
- í•˜ì§€ë§Œ ì´ ì—°ì‚°ì€ ë‹¨ìˆœí•œ ìˆ˜í•™ ê³µì‹ë§Œìœ¼ë¡œëŠ” ì¶©ë¶„í•˜ì§€ ì•Šë‹¤.
- CAD í™˜ê²½ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ê·¹ë‹¨ì ì¸ ìƒí™©ì´ ìì£¼ ë°œìƒí•œë‹¤:
    - ë§¤ìš° ì‘ì€ ì„ ë¶„ ê¸¸ì´ (1eâˆ’12 ì´í•˜)
    - ë§¤ìš° í° ì¢Œí‘œê°’ (1e8 ì´ìƒ)
    - Pê°€ A ë˜ëŠ” Bì— ë§¤ìš° ê°€ê¹Œìš´ ê²½ìš°
    - APÂ·ABì™€ ABÂ²ê°€ ê±°ì˜ ê°™ì€ í¬ê¸° â†’ cancellation
    - floating-point precision í•œê³„
- ì´ëŸ° ìƒí™©ì—ì„œëŠ” ìˆ˜í•™ì ìœ¼ë¡œ ë™ì¼í•œ ê³µì‹ì´ë¼ë„ ê²°ê³¼ê°€ ì™„ì „íˆ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆë‹¤.

### 2. Previous Implementation (Naive Version)
```rust
let u2 = ux*ux + uy*uy + uz*uz;
if u2 <= ON_ZERO_TOL {
    return on_squared_distance_points(p, a);
}

let t = ((vx*ux + vy*uy + vz*uz) / u2).clamp(0.0, 1.0);
```

- âœ” ìˆ˜í•™ì ìœ¼ë¡œëŠ” ì •í™•
- âŒ í•˜ì§€ë§Œ ìˆ˜ì¹˜ì ìœ¼ë¡œëŠ” ë§¤ìš° ì·¨ì•½
- ë¬¸ì œì :
    - ì ˆëŒ€ ê³µì°¨(ON_ZERO_TOL)ë§Œ ì‚¬ìš©
    - ì¢Œí‘œ ìŠ¤ì¼€ì¼ì´ í¬ë©´ ë„ˆë¬´ ì‘ì•„ì§
    - ì¢Œí‘œ ìŠ¤ì¼€ì¼ì´ ì‘ìœ¼ë©´ ë„ˆë¬´ ì»¤ì§
    - ëª¨ë¸ í¬ê¸°ì— ë”°ë¼ ì˜¤ì‘ë™
    - u2ê°€ ë§¤ìš° ì‘ìœ¼ë©´ division í­ì£¼
    - underflow â†’ 0
    - dot/u2 â†’ huge ê°’ â†’ clampë¡œ ë§‰ì•„ë„ ì´ë¯¸ ì˜¤ì°¨ ë°œìƒ
    - catastrophic cancellation
    - APÂ·ABì™€ ABÂ²ê°€ ë¹„ìŠ·í•œ í¬ê¸°ì¼ ë•Œ ë°œìƒ
    - projection tê°€ 0 ë˜ëŠ” 1 ê·¼ì²˜ì—ì„œ íŠ
    - CAD ì»¤ë„ì—ì„œ ìš”êµ¬ë˜ëŠ” robust ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ëª»í•¨

### 3. Improved Implementation (Robust Version)
```rust
const ABS_TOL_LEN: Real = 1e-9;
const REL_TOL: Real     = 1e-12;

let scale = max(|a|, |b|, |p|);
let abs2 = ABS_TOL_LEN * ABS_TOL_LEN;
let rel_len = REL_TOL * (scale + 1.0);
let tol2 = abs2 + rel_len * rel_len;

if ab_len2 <= tol2 {
    return on_squared_distance_points(p, a);
}
```

- âœ” ìˆ˜í•™ ê³µì‹ì€ ë™ì¼
- âœ” í•˜ì§€ë§Œ â€œê³„ì‚°ì´ ìˆ˜í–‰ë˜ëŠ” ì¡°ê±´â€ì´ ì™„ì „íˆ ë‹¤ë¥´ë‹¤
- âœ” ê·¸ë˜ì„œ CAD ì»¤ë„ì—ì„œ í›¨ì”¬ ì•ˆì •ì ì´ë‹¤

### 4. Why the Improved Version Is More Stable
#### 4.1 Absolute tolerance + Relative tolerance
- ì´ì „ ë°©ì‹
```rust
if |AB|Â² < ON_ZERO_TOL
```

- ê°œì„ ëœ ë°©ì‹
```rust
if |AB|Â² < abs_tolÂ² + (rel_tol * scale)Â²
```

- ì´ ì°¨ì´ê°€ ìˆ˜ì¹˜ì  ì•ˆì •ì„±ì˜ í•µì‹¬ì´ë‹¤.

#### 4.2 Why relative tolerance matters
- ì¢Œí‘œ ìŠ¤ì¼€ì¼ì´ 1e8ì¼ ë•Œ
    - ON_ZERO_TOLì€ ë„ˆë¬´ ì‘ì•„ì„œ ì˜ë¯¸ ì—†ìŒ
    - ì„ ë¶„ì´ 1eâˆ’6 ê¸¸ì´ì—¬ë„ â€œì •ìƒ segmentâ€ë¡œ ì²˜ë¦¬ë¨ â†’ í­ì£¼
- ì¢Œí‘œ ìŠ¤ì¼€ì¼ì´ 1eâˆ’8ì¼ ë•Œ
    - ON_ZERO_TOLì´ ë„ˆë¬´ ì»¤ì„œ
    - ì •ìƒ segmentë„ â€œdegenerateâ€ë¡œ ì²˜ë¦¬ë¨ â†’ ì˜¤ì°¨ ì¦ê°€
- ìƒëŒ€ ê³µì°¨ëŠ” ìŠ¤ì¼€ì¼ì— ë”°ë¼ ìë™ ì¡°ì •ë¨
```math
\mathrm{tol}=\mathrm{abs\_ tol}+\mathrm{rel\_ tol}\cdot \mathrm{scale}
```
- ê·¸ë˜ì„œ:
    - í° ëª¨ë¸ì—ì„œë„ ì•ˆì •
    - ì‘ì€ ëª¨ë¸ì—ì„œë„ ì•ˆì •
    - floating-point precision í•œê³„ì— ë§ì¶° ìë™ ë³´ì •

#### 4.3 Projection ê³„ì‚°ì˜ ì•ˆì •ì„±
- projection:
```math
t=\frac{AP\cdot AB}{\| AB\| ^2}
```
- ì´ ì‹ì€ ABê°€ ì§§ì„ ë•Œ í­ì£¼í•œë‹¤.
- ê°œì„ ëœ ë²„ì „ì€:
    - ABê°€ ë„ˆë¬´ ì§§ìœ¼ë©´ projection ìì²´ë¥¼ í•˜ì§€ ì•ŠìŒ
    - ì¦‰, ìœ„í—˜í•œ ê³„ì‚°ì„ â€œìˆ˜í•™ì ìœ¼ë¡œ ë™ì¼í•œ ê³µì‹â€ì´ ì•„ë‹ˆë¼
- ìˆ˜ì¹˜ì ìœ¼ë¡œ ì•ˆì „í•œ ì¡°ê±´ì—ì„œë§Œ ìˆ˜í–‰

#### 4.4 Catastrophic cancellation ë°©ì§€
- ì´ì „ ì½”ë“œì—ì„œëŠ” cancellationì´ ë°œìƒí•  ìˆ˜ ìˆë‹¤:
    - APÂ·AB â‰ˆ ABÂ²
    - ë‘˜ ë‹¤ ë§¤ìš° ì‘ì€ ê°’
    - division ê²°ê³¼ê°€ ë¶ˆì•ˆì •
- ê°œì„ ëœ ë²„ì „ì€:
    - degenerate segmentë¥¼ ë¨¼ì € ì œê±°
    - cancellationì´ ë°œìƒí•˜ëŠ” ì˜ì—­ ìì²´ë¥¼ íšŒí”¼

### 5. Mathematical Comparison (Numerical Perspective)
| í•­ëª© | ì´ì „ êµ¬í˜„ | ê°œì„ ëœ êµ¬í˜„ |
|------|-----------|-------------|
| Degenerate segment íŒì • | ì ˆëŒ€ ê³µì°¨ë§Œ ì‚¬ìš© | ì ˆëŒ€ + ìƒëŒ€ ê³µì°¨ë¡œ ìŠ¤ì¼€ì¼ ìë™ ë³´ì • |
| Projection ì•ˆì •ì„± | ì‘ì€ segmentì—ì„œ í­ì£¼ | ìœ„í—˜ êµ¬ê°„ì„ ì‚¬ì „ì— ì°¨ë‹¨ |
| Cancellation ìœ„í—˜ | ë†’ìŒ | í¬ê²Œ ê°ì†Œ |
| Overflow/Underflow | ë°œìƒ ê°€ëŠ¥ | scale ê¸°ë°˜ tolë¡œ ë°©ì§€ |
| ëª¨ë¸ ìŠ¤ì¼€ì¼ ë³€í™” ëŒ€ì‘ | ì·¨ì•½ | ìë™ ì ì‘ |
| CAD ì»¤ë„ ì í•©ì„± | ë‚®ìŒ | ë§¤ìš° ë†’ìŒ |



### 6. í•µì‹¬ ê²°ë¡ 
- âœ” ë‘ ì½”ë“œì˜ ìˆ˜í•™ ê³µì‹ì€ ë™ì¼í•˜ë‹¤
- âœ” í•˜ì§€ë§Œ CAD ì»¤ë„ì—ì„œëŠ” â€œê³µì‹ì„ ì–¸ì œ í‰ê°€í•˜ëŠëƒâ€ê°€ ë” ì¤‘ìš”í•˜ë‹¤
- âœ” ê°œì„ ëœ ë²„ì „ì€ ìœ„í—˜í•œ ê³„ì‚°ì„ ì‚¬ì „ì— ì°¨ë‹¨í•œë‹¤
- âœ” ê·¸ë˜ì„œ ìˆ˜ì¹˜ì  í­ì£¼ë¥¼ ë§‰ê³ , CAD ì—”ì§„ ì „ì²´ì˜ ì•ˆì •ì„±ì„ ë³´ì¥í•œë‹¤
- ì¦‰,
    - ìˆ˜í•™ì  ì°¨ì´ê°€ ì•„ë‹ˆë¼, ìˆ˜ì¹˜ì  ì•ˆì •ì„±ì˜ ì°¨ì´ê°€ ê°œì„ ëœ ì½”ë“œì˜ í•µì‹¬ ê°•ì ì´ë‹¤.


---
### ê¸°ì¡´ ì½”ë“œ
```rust
pub fn on_squared_distance_point_segment(p: &Point3D, a: &Point3D, b: &Point3D) -> Real {
    let ux = b.x - a.x;
    let uy = b.y - a.y;
    let uz = b.z - a.z;
    let vx = p.x - a.x;
    let vy = p.y - a.y;
    let vz = p.z - a.z;

    let u2 = ux * ux + uy * uy + uz * uz;
    if u2 <= ON_ZERO_TOL {
        return on_squared_distance_points(p, a); // a==b
    }

    let t = ((vx * ux + vy * uy + vz * uz) / u2).clamp(0.0, 1.0);
    let qx = a.x + t * ux;
    let qy = a.y + t * uy;
    let qz = a.z + t * uz;

    let dx = p.x - qx;
    let dy = p.y - qy;
    let dz = p.z - qz;
    dx * dx + dy * dy + dz * dz
}
```
### ê°œì„ ëœ ì½”ë“œ
```rust
pub fn on_squared_distance_point_segment(p: &Point3D, a: &Point3D, b: &Point3D) -> Real {
    // 1) ë‚´ë¶€ ê¸°ë³¸ ê³µì°¨(ê¸¸ì´ ë‹¨ìœ„) + ìƒëŒ€ ê³µì°¨(ë¬´ì°¨ì›)
    // í”„ë¡œì íŠ¸ì— ë§ê²Œ ì¡°ì • ê°€ëŠ¥
    const ABS_TOL_LEN: Real = 1e-9;   // "ê¸¸ì´" ê³µì°¨ (ëª¨ë¸ ë‹¨ìœ„)
    const REL_TOL: Real     = 1e-12;  // ìƒëŒ€ ê³µì°¨ (ìŠ¤ì¼€ì¼ ê³±í•´ ê¸¸ì´ë¡œ ë³€í™˜)

    let abx = b.x - a.x;
    let aby = b.y - a.y;
    let abz = b.z - a.z;

    let ab_len2 = abx * abx + aby * aby + abz * abz;

    // 2) ìŠ¤ì¼€ì¼: ì¢Œí‘œì˜ í¬ê¸° ê¸°ë°˜(í° ì¢Œí‘œì—ì„œ ìƒëŒ€ê³µì°¨ê°€ ì»¤ì ¸ ì•ˆì •ì„±â†‘)
    let scale = a.x.abs().max(b.x.abs()).max(p.x.abs())
        .max(a.y.abs().max(b.y.abs()).max(p.y.abs()))
        .max(a.z.abs().max(b.z.abs()).max(p.z.abs()));

    // 3) ê¸¸ì´^2 ì„ê³„ê°’(ë‹¨ìœ„ ì¼ì¹˜!)
    let abs2 = ABS_TOL_LEN * ABS_TOL_LEN;
    let rel_len = REL_TOL * (scale + 1.0); // +1ì€ scale=0 ê·¼ì²˜ ì•ˆì „ì¥ì¹˜
    let tol2 = abs2 + rel_len * rel_len;

    if ab_len2 <= tol2 {
        return on_squared_distance_points(p, a);
    }

    let apx = p.x - a.x;
    let apy = p.y - a.y;
    let apz = p.z - a.z;

    let dot = apx * abx + apy * aby + apz * abz;
    let mut t = dot / ab_len2;

    if t < 0.0 { t = 0.0; }
    else if t > 1.0 { t = 1.0; }

    let qx = a.x + t * abx;
    let qy = a.y + t * aby;
    let qz = a.z + t * abz;

    let dx = p.x - qx;
    let dy = p.y - qy;
    let dz = p.z - qz;

    dx * dx + dy * dy + dz * dz
}
```
---


