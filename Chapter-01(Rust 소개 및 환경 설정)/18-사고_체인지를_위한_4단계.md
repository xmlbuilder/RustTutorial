# 사고 체인지를 위한 4단계

- 먼저 동사를 뽑는다: Log/Filter/Handle, Render/Validate/Apply, Load/Cache/Fetch …
- 동사마다 트레이트로 표준화: trait Logger { fn log(&self, …) }
- 트레이트 구현물을 조합해서 파이프/파사드 구성.
- 상태는 컨텍스트 하나로 모아서 &mut ctx로 흘린다. (부수효과는 모두 여기로)


## 🧩 1단계: 동사 추출 – Log / Filter / Handle
우리가 처리하고 싶은 동작을 먼저 동사로 추상화합니다.  
```
// 동사: Log / Filter / Handle
```


## 🧩 2단계: 동사마다 트레잇으로 표준화
각 동사를 트레잇으로 정의해서 인터페이스를 고정합니다.  
```rust
trait Logger {
    fn log(&self, ctx: &mut Context, msg: &str);
}

trait Filter {
    fn filter(&self, ctx: &mut Context, msg: &str) -> bool;
}

trait Handler {
    fn handle(&self, ctx: &mut Context, msg: &str);
}
```


## 🧩 3단계: 트레잇 구현물을 조합해서 파이프 구성
각 트레잇을 구현한 구조체를 만들고, 파사드 또는 파이프라인으로 조합합니다.  
```rust
struct ConsoleLogger;
impl Logger for ConsoleLogger {
    fn log(&self, ctx: &mut Context, msg: &str) {
        ctx.logs.push(format!("LOG: {}", msg));
    }
}

struct SpamFilter;
impl Filter for SpamFilter {
    fn filter(&self, _ctx: &mut Context, msg: &str) -> bool {
        !msg.contains("spam")
    }
}

struct PrintHandler;
impl Handler for PrintHandler {
    fn handle(&self, ctx: &mut Context, msg: &str) {
        ctx.handled.push(msg.to_string());
    }
}
```


## 🧩 4단계: 상태는 Context 하나로 모아서 &mut ctx로 흘린다
모든 부수효과는 Context에 저장하고, 각 단계는 &mut ctx를 받아서 상태를 변경합니다.  
```rust
struct Context {
    logs: Vec<String>,
    handled: Vec<String>,
}
```


## 🧪 전체 파이프라인 실행 예시
```rust
fn main() {
    let logger = ConsoleLogger;
    let filter = SpamFilter;
    let handler = PrintHandler;

    let mut ctx = Context {
        logs: vec![],
        handled: vec![],
    };

    let messages = vec!["hello", "spam offer", "rust is great"];

    for msg in messages {
        logger.log(&mut ctx, msg);
        if filter.filter(&mut ctx, msg) {
            handler.handle(&mut ctx, msg);
        }
    }

    println!("Logs: {:?}", ctx.logs);
    println!("Handled: {:?}", ctx.handled);
}
```


## ✨ 결과 예시
```
Logs: ["LOG: hello", "LOG: spam offer", "LOG: rust is great"]
Handled: ["hello", "rust is great"]
```


## 이 구조는 Rust의 철학에 딱 맞는 방식:
- 행위 중심 사고 (동사 → 트레잇)
- 구성 기반 설계 (조합 가능한 구현체)
- 명시적 상태 흐름 (&mut ctx)


---

## 🧠 1. dyn Trait을 통한 런타임 조합
### ✅ 개념
- 서로 다른 구현체를 **Trait 객체(Box, Rc, Arc 등)** 로 감싸서  
동일한 인터페이스로 런타임에 호출 가능  
### ✅ 예시: Logger 파이프 조합
```rust
trait Logger {
    fn log(&self, msg: &str);
}

struct ConsoleLogger;
impl Logger for ConsoleLogger {
    fn log(&self, msg: &str) {
        println!("Console: {}", msg);
    }
}

struct FileLogger;
impl Logger for FileLogger {
    fn log(&self, msg: &str) {
        println!("File: {}", msg);
    }
}

fn run_pipeline(loggers: Vec<Box<dyn Logger>>) {
    for logger in loggers {
        logger.log("Hello");
    }
}

fn main() {
    let pipeline: Vec<Box<dyn Logger>> = vec![
        Box::new(ConsoleLogger),
        Box::new(FileLogger),
    ];
    run_pipeline(pipeline);
}
```

### ✅ 장점
- 다양한 타입을 동일한 Trait로 묶어 처리 가능
- 런타임에 구성 변경 가능 (플러그인, 설정 기반 등)
### ❌ 단점
- vtable 호출로 성능 손해
- 힙 할당(Box) 필요

## 🧩 2. enum을 통한 파이프 단계 표현
### ✅ 개념
- 각 단계 구현을 열거형으로 정의하고 match 문으로 분기 처리함

### ✅ 예시: LoggerStep enum
```rust
enum LoggerStep {
    Console,
    File,
}

impl LoggerStep {
    fn log(&self, msg: &str) {
        match self {
            LoggerStep::Console => println!("Console: {}", msg),
            LoggerStep::File => println!("File: {}", msg),
        }
    }
}

fn run_pipeline(steps: Vec<LoggerStep>) {
    for step in steps {
        step.log("Hello");
    }
}
```

### ✅ 장점
- 성능 뛰어남 (정적 디스패치)
- 메모리 할당 없음 (스택 기반)
- 패턴 매칭으로 제어 흐름 명확
### ❌ 단점
- 확장성 제한 (새 구현 추가 시 enum 수정 필요)
- 구성 유연성 낮음 (런타임 타입 추가 어려움)

## ✨ 비교 요약
| 방식                  | `dyn Trait` (동적 디스패치)         | `enum` (정적 디스패치)               |
|-----------------------|--------------------------------------|--------------------------------------|
| 타입 확장성           | ✅ 유연함 (새 타입 쉽게 추가)         | ❌ 제한적 (enum 수정 필요)            |
| 런타임 구성 가능 여부 | ✅ 가능 (Vec<Box<dyn Trait>> 등)      | ❌ 불가능 (타입 고정됨)               |
| 성능                  | ❌ 느림 (vtable + heap)               | ✅ 빠름 (match + 스택)                |
| 코드 명시성           | ✅ 인터페이스 기반                    | ✅ 분기 명확                          |
| 사용 예시             | 플러그인, UI 위젯, ECS 컴포넌트       | 고정된 파이프라인, FSM, DSL 처리 등  |


----


