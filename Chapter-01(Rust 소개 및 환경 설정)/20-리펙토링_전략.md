# 리펙터링 전략

## 리팩터링 체크리스트 (작게·빠르게)
- 동사 목록화  
    파일/모듈을 훑어 **기능 이름(동사)** 만 빼서 적기. (로깅, 검증, 직렬화, 픽킹, 카메라 조작…)
- 트레이트 선언 (이름=동사)
- 메서드는 협업에 필요한 최소 인자만: `fn handle(&self, ev: &Event, ctx: &mut Ctx)`  
    가능하면 불변 `self (&self)`, 부수효과는 `ctx`.

## 컨텍스트 설계
- 변경 상태, 캐시, 통계, 출력 버퍼 등 모든 사이드 이펙트를 Ctx에.
- IO/리소스 핸들(동기/비동기), 시간, 랜덤 씨드도 여기로.

## 파이프/조립 코드 만들기
- `Vec<Rc<dyn Trait>>` or 제네릭 `Pipeline<T: Trait>`.
- 순서·교체·조건 분기를 조립부로 빼기(핸들러는 순수).

## 거대 타입 분해
- 데이터 구조는 순수 데이터만 남기고, 행위는 외부 트레이트로.  
    예: `BoundingBox` 는 계산/조합 로직만, 삽입/검색은 `SpatialIndex` 트레이트로.

## 테스트 고정
- 각 동사 트레이트에 표준 시나리오 테스트(입력→ctx 변화).
- 조합(Pipeline/ECS)에선 구성 순서가 결과에 미치는 영향 테스트.

## 안티패턴 빨간불
- **Base 클래스로 다 때려넣기** : 공통 데이터 + 공통 동작을 한 곳에 몰지 말 것.
- **거대한 enum + match 500줄** : 기능이 늘수록 수정 반경 폭증.
- **여기저기서 상태 수정**: ctx 외부에서 사이드 이펙트 발생 금지.
- **트레이트에 상태를 쌓음** : 재사용/동시성에 불리. 상태는 가능한 ctx.

---


## ✅ 1. 동사 목록화 → 트레이트 선언
### 🎯 목표
- 기능을 동사 중심으로 추출하고
- 각 동사를 트레이트로 표준화
## 🧪 예시
```rust
trait Logger {
    fn log(&self, msg: &str, ctx: &mut Ctx);
}

trait Validator {
    fn validate(&self, input: &str, ctx: &mut Ctx) -> bool;
}

trait Handler {
    fn handle(&self, ev: &Event, ctx: &mut Ctx);
}
```

- ✅ 각 동사는 독립적인 트레이트로 선언
- ✅ `&self` 는 불변, 부수효과는 `ctx` 로만 처리


## ✅ 2. 컨텍스트 설계
### 🎯 목표
- 모든 사이드 이펙트는 Ctx에 집중
- IO, 캐시, 통계, 랜덤 등도 여기로
### 🧪 예시
```rust
struct Ctx {
    logs: Vec<String>,
    errors: Vec<String>,
    rng: rand::rngs::StdRng,
    output: Vec<String>,
}
```
- ✅ `상태를 명시적` 으로 전달
- ✅ 테스트와 추적이 쉬워짐


## ✅ 3. 파이프/조립 코드 만들기
### 🎯 목표
- 트레이트 구현체를 Vec<Rc<dyn Trait>> 또는 제네릭으로 조립
- 순서, 조건, 교체는 조립부에서만 처리
### 🧪 예시
```rust
fn run_pipeline(handlers: Vec<Rc<dyn Handler>>, ev: &Event, ctx: &mut Ctx) {
    for h in handlers {
        h.handle(ev, ctx);
    }
}
```
- ✅ 핸들러는 순수하게 handle만 구현
- ✅ `흐름 제어는 외부` 에서 조립


## ✅ 4. 거대 타입 분해
### 🎯 목표
- `데이터 구조는 순수 데이터` 만
- `행위는 외부 트레이트` 로 분리
### 🧪 예시
```rust
struct BoundingBox {
    min: [f32; 3],
    max: [f32; 3],
}

trait SpatialIndex {
    fn insert(&mut self, bbox: BoundingBox);
    fn query(&self, point: [f32; 3]) -> Vec<BoundingBox>;
}
```

- ✅ BoundingBox는 계산/조합만 담당
- ✅ 삽입/검색은 SpatialIndex 트레이트로 분리


## ✅ 5. 테스트 고정
### 🎯 목표
- 각 트레이트에 표준 시나리오 테스트
- 조합 순서가 결과에 미치는 영향도 테스트
### 🧪 예시
```rust
#[test]
fn test_logger_pipeline() {
    let mut ctx = Ctx::default();
    let logger = ConsoleLogger;
    logger.log("hello", &mut ctx);
    assert_eq!(ctx.logs.len(), 1);
}
```
- ✅ 입력 → ctx 변화 확인
- ✅ 조합 테스트로 순서 영향 검증 가능


## ❌ 6. 안티패턴 빨간불
| 안티패턴                         | 문제점                                           | Rust에서의 해결책         |
|----------------------------------|--------------------------------------------------|----------------------------|
| Base 클래스로 다 때려넣기        | 데이터와 행위가 뒤섞여 확장/재사용 어려움         | 트레이트 분리 + 전략 조합 |
| 거대한 enum + match 500줄       | 기능 추가 시 수정 반경 폭증, 유지보수 어려움      | 트레이트 폴리몰피즘       |
| 여기저기서 상태 수정             | 사이드 이펙트 추적 불가, 테스트 어려움            | `&mut ctx`로 명시적 전달  |
| 트레이트에 상태를 쌓음           | 재사용/동시성에 불리, 상태 분리 어려움            | 상태는 `Ctx`에 집중       |


## ✨ 전체 흐름 요약
- 1. 동사 추출 → 트레이트로 추상화
- 2. 상태는 `Ctx`에 집중
- 3. 구현체는 순수하게, 조립은 외부에서
- 4. 데이터와 행위는 분리
- 5. 테스트는 입력→ctx 변화 중심
- 6. 안티패턴은 트레이트/컨텍스트로 해결

---



