# 소유권 공유 방식

## 🧠 C++ vs Rust: 소유권과 공유 방식
| 개념 항목         | C++                            | Rust                                |
|------------------|----------------------------------|--------------------------------------|
| 단일 소유         | `unique_ptr<T>`                 | `Box<T>`                             |
| 공유 소유         | `shared_ptr<T>`                 | `Rc<T>`, `Arc<T>`                    |
| 참조 방식         | `T*`, `T&`                      | `&T`, `&mut T`                       |
| 수명 관리         | 수동 또는 스마트 포인터         | 컴파일러가 Lifetime으로 자동 추적   |
| 스레드 안전 공유  | `shared_ptr` (기본 비안전)      | `Arc<T>` + `Send` + `Sync` 조건 필요 |

## ✅ Rust에서 어떤 방식이 좋을까?
Rust에서는 **누가 소유하고, 누가 빌려 쓰는지** 를 명확하게 표현하는 방식이 가장 좋습니다.  
상황에 따라 아래처럼 선택:

## 1. 단일 소유 (Box, 직접 소유)
- 트리, 그래프, 게임 오브젝트 등에서 명확한 소유자가 있을 때
- 예: Box<Node>, Vec<T>, HashMap<K, V>
## 2. 공유 소유 (Rc / Arc)
- 여러 곳에서 동일한 객체를 참조해야 할 때
- 예: `ECS에서 컴포넌트 공유, 트리 노드의 부모-자식 관계
- Rc<T>: 단일 스레드
- Arc<T>: 멀티 스레드
## 3. 빌림 (Borrowing)
- 소유권을 넘기지 않고 일시적으로 참조할 때
- 예: 함수 인자로 &T, &mut T 넘기기

## 🧩 예시: 트리 구조에서 어떤 방식?
```rust
use std::rc::Rc;
use std::cell::RefCell;

struct Node {
    value: i32,
    children: Vec<Rc<RefCell<Node>>>,
}
```

- Rc → 여러 부모/자식이 같은 노드를 참조
- RefCell → 내부 가변성 (mutable access at runtime)
- 이건 C++의 shared_ptr + mutable 조합과 비슷하지만, 런타임 체크로 안전 보장

## ✨ 요약
Rust에서는 소유권과 공유를 명시적으로 표현하는 것이 가장 좋습니다.  
C++처럼 **포인터 넘기면 공유** 가 아니라,
Box, Rc, Arc, &, &mut 등으로 의도를 드러내는 방식이 더 안전하고 명확.

---



