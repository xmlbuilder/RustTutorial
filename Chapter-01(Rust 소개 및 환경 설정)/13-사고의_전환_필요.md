# ì‚¬ê³ ì˜ ì „í™˜
ê°ì²´ ì¤‘ì‹¬ì—ì„œ í–‰ìœ„ ì¤‘ì‹¬ì˜ í”„ë¡œê·¸ë˜ë°ì„ í•˜ë ¤ë©´ ì‚¬ê³ ì˜ ì „í™˜ì´ í•„ìš”í•˜ë‹¤.

## ì½”ë“œ ë³€í™˜ ì„¤ëª…

### 1) ì½”ë“œ ì „í™˜

#### C++ ìª½ (ì´ì „)
- ON_Object ê¸°ë°˜ ìƒì†  
    ë‹¤ì–‘í•œ ê°ì²´ê°€ ON_Object*ë¡œ ì·¨ê¸‰ë˜ê³ , ì»¨í…Œì´ë„ˆ(SpatialTree)ëŠ” â€œë¶€ëª¨ íƒ€ì… í¬ì¸í„°â€ë§Œ ë³´ë©´ ë¨.
- ë°ì´í„°-ì£¼ë„  
    ì»¨í…Œì´ë„ˆëŠ” â€œì–´ë–¤ ë°ì´í„°ê°€ ë“¤ì–´ì™”ëŠ”ì§€â€ë¥¼ í¬ì¸í„°ë¡œë§Œ ì‹ë³„. AABBë„ ì™¸ë¶€ì—ì„œ ê³„ì‚°í•´ ë„£ì–´ì¤Œ.
- ë©”ëª¨ë¦¬/ìˆ˜ëª… ê´€ë¦¬ ìˆ˜ë™  
    í’€( ON_FixedSizeMemMgr) + ë‹¨ì¼ ì—°ê²° ë¦¬ìŠ¤íŠ¸ ë…¸ë“œë¡œ ê´€ë¦¬. í•´ì œ ì±…ì„/ìˆœì„œ/ëˆ„ìˆ˜ ì£¼ì˜.
- ì‹ë³„(Identity) = í¬ì¸í„° ê°’  
    ì‚­ì œ/ì—…ë°ì´íŠ¸ëŠ” ê°™ì€ í¬ì¸í„°ì¸ì§€ê°€ ì „ë¶€.

#### Rust ìª½ (ì§€ê¸ˆ)
- ìƒì† â†’ íŠ¸ë ˆì´íŠ¸(í–‰ìœ„/ê³„ì•½)  
    SpatialObject íŠ¸ë ˆì´íŠ¸(ì˜ˆ: fn aabb(&self) -> BoundingBox)ë¥¼ ë§Œì¡±í•˜ëŠ” íƒ€ì…ì´ë©´ ë¬´ì—‡ì´ë“  íŠ¸ë¦¬ì— ë„£ì„ ìˆ˜ ìˆìŒ. â€œë¶€ëª¨ í´ë˜ìŠ¤â€ ì—†ì´ í–‰ìœ„ ê³„ì•½ìœ¼ë¡œ ì—°ê²°.
- í–‰ìœ„-ì£¼ë„/ì¡°í•©  
    â€œì´ íƒ€ì…ì´ AABBë¥¼ ì œê³µí•œë‹¤â€ëŠ” **ëŠ¥ë ¥(capability)** ê°€ í•µì‹¬. ì»¨í…Œì´ë„ˆëŠ” ê·¸ ëŠ¥ë ¥ë§Œ ì˜ì¡´í•˜ê³ , ë‚˜ë¨¸ì§€ëŠ” íƒ€ì…ì´ ììœ ë¡­ê²Œ êµ¬í˜„.
- ì†Œìœ /ìˆ˜ëª… ì•ˆì „  
    ê¸°ë³¸ì€ ì†Œìœ  ê°’, ê³µìœ ê°€ í•„ìš”í•˜ë©´ Arc<T>ë¡œ ì•ˆì „ ê³µìœ . í•´ì œ/ë¼ì´í”„íƒ€ì„ì€ ì»´íŒŒì¼ëŸ¬ê°€ ë³´ì¥.
- ì‹ë³„ = Arc::ptr_eq  
    ê°™ì€ ë°ì´í„°ë¼ë„ ìƒˆ Arc::newë©´ ë‹¤ë¥¸ ê°œì²´. ì»¨í…Œì´ë„ˆ APIëŠ” â€œë„£ì„ ë•Œ ë°›ì€ Arc ê·¸ëŒ€ë¡œâ€ë¥¼ ê³„ì† ì“°ëŠ” ì „ì œë¥¼ ëª…í™•íˆ í•¨.

- ìë£Œêµ¬ì¡° ë‹¨ìˆœí™”  
    ë¦¬ìŠ¤íŠ¸ ë…¸ë“œ í’€ â†’ Vec<Arc<T>>(ìºì‹œ ì¹œí™”/ê°„ë‹¨). ë‚˜ì¤‘ì— ì„±ëŠ¥ ì´ìŠˆ ìƒê¸°ë©´ í’€/ì»¤ìŠ¤í…€ í• ë‹¹ê¸°ë¡œ êµì²´ ê°€ëŠ¥(êµì²´ ì§€ì  ëª…í™•).

### 2) ì™œ ì´ë ‡ê²Œ ë°”ê¿¨ë‚˜? (ì„¤ê³„ ì˜ë„)
- ì˜ì¡´ì„± ì—­ì „  
    ì»¨í…Œì´ë„ˆê°€ êµ¬ì²´ íƒ€ì…(ON_Object ê³„ì¸µ)ì— ë¬¶ì´ì§€ ì•Šê³  â€œAABBë¥¼ ì¤„ ìˆ˜ ìˆëŠ” ë¬´ì–¸ê°€(íŠ¸ë ˆì´íŠ¸)â€ì—ë§Œ ì˜ì¡´ â†’ í…ŒìŠ¤íŠ¸ ìš©ì´, êµì²´ ìš©ì´.
- ì¡°í•©ì´ ìƒì†ë³´ë‹¤ ê°•ë ¥  
    í•„ìš”í•œ í–‰ìœ„(ë©”ì„œë“œ)ë§Œ ì‘ê²Œ ìš”êµ¬ â†’ í•œ íƒ€ì…ì´ ì—¬ëŸ¬ ì—­í• ì„ ì‰½ê²Œ ê²¸í•¨. (ì˜ˆ: AABB ì œê³µ + RayHit ì œê³µ íŠ¸ë ˆì´íŠ¸ë¥¼ ê°ê° êµ¬í˜„)
- ë¶ˆë³€/ì†Œìœ ë¡œ ê²½í•© ì¤„ì´ê¸°  
    Rustì˜ ê¸°ë³¸ì€ ë¶ˆë³€ ê³µìœ . ì—…ë°ì´íŠ¸/ì‚­ì œ ê·œì¹™ì´ ëª…í™•í•´ì§€ê³ , ë™ì‹œì„± í™•ì¥ë„ ì‰¬ì›Œì§(í•„ìš”í•˜ë©´ RwLock<...>ë¡œ ê°ì‹¸ë©´ ë¨).
- ì„±ëŠ¥ì€ ë‚˜ì¤‘ ìµœì í™”  
    ë¨¼ì € ëª…í™•ì„±/ì•ˆì „/í…ŒìŠ¤íŠ¸ì„±ì„ í™•ë³´. ì´í›„ ë³‘ëª©ì´ ë³´ì´ë©´

### 3) êµ¬ì²´ì  ì „ëµ (ì–´ë–»ê²Œ ë°”ê¿¨ë‚˜?)
#### ëŠ¥ë ¥ ì¤‘ì‹¬ ì¸í„°í˜ì´ìŠ¤
```rust
pub trait SpatialObject {
    fn aabb(&self) -> BoundingBox;
    // í•„ìš”í•´ì§€ë©´: fn ray_hit(&self, ray: Ray) -> Option<t>;
}
```
- íŠ¸ë¦¬ëŠ” T: SpatialObjectë§Œ ë°›ìŒ. = â€œë„£ì„ ìˆ˜ ìˆëŠ” ê²ƒâ€ì˜ ì •ì˜ê°€ íƒ€ì… ê³„ë³´ê°€ ì•„ë‹ˆë¼ ê°€ëŠ¥í•œ í–‰ìœ„ê°€ ë¨.

#### ì œë„¤ë¦­ ì»¨í…Œì´ë„ˆ
```rust
pub struct SpatialTree<T: SpatialObject> { /* ... */ }
```
- íŠ¸ë¦¬ëŠ” êµ¬ì²´ íƒ€ì…ì„ ëª°ë¼ë„ ë¨. í…ŒìŠ¤íŠ¸Â·ëª¨í‚¹ì´ ì‰¬ì›€(ë”ë¯¸ íƒ€ì…ìœ¼ë¡œ íŠ¸ë¦¬ë§Œ ê²€ì¦ ê°€ëŠ¥).
- ëª…ì‹œì  ì‹ë³„ì ìœ ì§€  
    ì‚½ì… ì‹œ ì–»ì€ Arc<T>ë¥¼ ë³´ê´€ â†’ remove/update ì‹œ Arc::ptr_eqë¡œ ë™ì¼ ê°œì²´ íŒì •.  
    (C++ì˜ â€œìš°ì—°íˆ ê°™ì€ í¬ì¸í„°â€ ì˜ì¡´ì„, Rustì— ë§ê²Œ ì˜ë„ì ì¸ ë™ì¼ì„± ê·œì•½ìœ¼ë¡œ ìŠ¹ê²©)
- ë‹¨ìˆœí•œ ë‚´ë¶€ í‘œí˜„  
    Vec<Arc<T>>ë¡œ ì‹œì‘ â†’ ë‚˜ì¤‘ì— Vec<ObjectHandle>ë¡œ ë°”ê¾¸ê³  í•¸ë“¤ì€ í’€/ìŠ¬ë©/ì„¸ê·¸ë¦¬ê²Œì´í„°ë¡œ ë°”ê¿”ë„, ì™¸ë¶€ API ì•ˆ í”ë“¤ë¦¼.
- ë„ë©”ì¸ ê·œì¹™ì„ íƒ€ì…ìœ¼ë¡œ í‘œí˜„
    â€œë£¨íŠ¸ì— ì•ˆ ë‹´ê¸°ë©´ í™•ì¥í•œë‹¤â€ëŠ” ì •ì±…ì„ expand_to_include()ë¡œ ëª…ì‹œ.
    â€œìì‹ì— ëª» ë„£ìœ¼ë©´ ë¶€ëª¨ì— ë‚¨ê¸´ë‹¤(ë¶€ëª¨ ë³´ê´€)â€ë„ í•¨ìˆ˜ë¡œ ì´ë¦„í™”.  
    â†’ ê·œì¹™ì´ â€œìˆ¨ì€ ë¶€ìˆ˜íš¨ê³¼â€ê°€ ì•„ë‹ˆë¼ â€œì½íˆëŠ” ì •ì±…â€ì´ ë¨.  

### 4) í•™ìŠµ í¬ì¸íŠ¸ (ë°ì´í„° â†’ í–‰ìœ„ ì „í™˜ì˜ í•µì‹¬)
- ìƒì†=ì¬ì‚¬ìš©ì—ì„œ í–‰ìœ„=ì¡°í•©ìœ¼ë¡œ  
    ìƒì†ì€ í™•ì¥ ì‹œ ê²°í•©ë„ê°€ ì»¤ì§€ê³  í…ŒìŠ¤íŠ¸ê°€ ì–´ë ¤ì›€. íŠ¸ë ˆì´íŠ¸ëŠ” í•„ìš”í•œ ê¸°ëŠ¥ë§Œ ìš”êµ¬ â†’ ì‘ì€ ì¸í„°í˜ì´ìŠ¤ë¡œ ëŠìŠ¨í•œ ê²°í•©.
- í¬ì¸í„°=ì •ì²´ì„±ì—ì„œ ì†Œìœ /í•¸ë“¤=ì •ì²´ì„±ìœ¼ë¡œ  
    RustëŠ” ì†Œìœ ê¶Œ ëª¨ë¸ ë•ì— â€œëˆ„ê°€ ê°€ì§„ë‹¤â€ê°€ ëª…í™•. ê³µìœ ê°€ í•„ìš”í•  ë•Œë§Œ Arcë¥¼ ì“°ê³ , ë™ì¼ì„±ì€ ì˜ë„ì ìœ¼ë¡œ ptr_eqë¡œ íŒë‹¨.
- ë©”ëª¨ë¦¬ í’€=ê¸°ëŠ¥ì˜ ì¼ë¶€ì—ì„œ ì˜µì…˜ ìµœì í™”ë¡œ  
    C++ì€ í’€ ì—†ìœ¼ë©´ ëˆ„ìˆ˜ë‚˜ ì„±ëŠ¥ ë¬¸ì œê°€ ë°”ë¡œ ë“œëŸ¬ë‚˜ê¸° ì‰¬ì›Œ â€œí•„ìˆ˜ì²˜ëŸ¼â€ ë¶™ì§€ë§Œ, RustëŠ” ê¸°ë³¸ì´ ì•ˆì „/ë¹ ë¦„.  
    â†’ í’€/ì»¤ìŠ¤í…€ í• ë‹¹ê¸°ëŠ” í”„ë¡œíŒŒì¼ë§ í›„ ì„ íƒì ìœ¼ë¡œ â€œêµì²´ ê°€ëŠ¥í•œ ë ˆì´ì–´â€ë¡œ ì¶”ê°€.
- ë°ì´í„°-íë¦„ì„ í–‰ìœ„-ê³„ì•½ìœ¼ë¡œ í™˜ì›  
    ì»¨í…Œì´ë„ˆëŠ” â€œì–´ë–¤ ë°ì´í„°ëƒâ€ì— ê´€ì‹¬ì´ ì•„ë‹ˆë¼ â€œë¬´ì—‡ì„ í•  ìˆ˜ ìˆëƒ(ì˜ˆ: AABB ì œê³µ)â€.  
    ì´ ê´€ì ì´ ìœ ì§€ë˜ë©´ â€œìƒˆ ë°ì´í„° íƒ€ì…â€ì´ ì™€ë„ ì»¨í…Œì´ë„ˆ ìˆ˜ì •ì´ ê±°ì˜ í•„ìš” ì—†ìŒ.  

### 5) ì ì§„ ì´í–‰ íŒ
- ì–´ëŒ‘í„° íƒ€ì…
    struct OnObjectAdapter<'a>(&'a ON_Object);ê°€ SpatialObjectë¥¼ êµ¬í˜„í•´ì„œ ê¸°ì¡´ ON_Objectë„ íŠ¸ë¦¬ì— ë„£ì„ ìˆ˜ ìˆê²Œ ê°€êµë¥¼ ë§Œë“¦.  
    (C FFIë¡œ ë„˜ì–´ì˜¤ëŠ” í¬ì¸í„°ë„ NonNull+ìˆ˜ëª…/ì•ˆì „ ë˜í¼ë¡œ ê°ì‹¸ë©´ ì‚¬ìš© ê°€ëŠ¥)  
- ì‹ë³„ ìœ ì§€  
    ê¸°ì¡´ ì—”ì§„ì´ â€œidâ€ ê°œë…ì´ ìˆë‹¤ë©´ Arc<T> ëŒ€ì‹  Arc<(Id, T)>ë¡œ ì‹¸ì„œ, í¬ì¸í„° ë™ì¼ì„± + ë…¼ë¦¬ id ë‘˜ ë‹¤ ì§€ì›.
- ì„±ëŠ¥ ë‹¨ê³„ì  ë°˜ì˜  
    í…ŒìŠ¤íŠ¸Â·í”„ë¡œíŒŒì¼ë§ â†’ ë³‘ëª© ì§€ì ì—ë§Œ í’€/SoA/ë§ì¶¤ ë¶„í• ê¸°ë¥¼ ì£¼ì…. (APIëŠ” ê·¸ëŒ€ë¡œ, ë‚´ë¶€ë§Œ êµì²´)

## ìš”ì•½:
ìƒì†Â·í¬ì¸í„°Â·í’€ì— ê¸°ëŒ€ë˜ êµ¬ì¡°ë¥¼ íŠ¸ë ˆì´íŠ¸Â·ì œë„¤ë¦­Â·ì†Œìœ ê¶Œìœ¼ë¡œ ì¬í¸í•´ â€œì—­í•  ê¸°ë°˜(í–‰ìœ„ ì¤‘ì‹¬)â€ ì„¤ê³„ë¡œ ì˜®ê¹€.  
ì´ë ‡ê²Œ í•˜ë©´ ìœ ì—°ì„±/í…ŒìŠ¤íŠ¸ì„±/ì•ˆì „ì„±ì´ ì˜¬ë¼ê°€ê³ , ì„±ëŠ¥ ìµœì í™”ë„ í•„ìš”í•œ ë¶€ë¶„ë§Œ ì •í™•íˆ ë„£ì„ ìˆ˜ ìˆìŒ.   
ì•ìœ¼ë¡œ ë ˆì´ í…ŒìŠ¤íŠ¸, ì¶©ëŒ ë¦¬íŒŒì¸, ë¶„í•  íœ´ë¦¬ìŠ¤í‹± ê°™ì€ â€œí–‰ìœ„â€ë“¤ì„ ì‘ì€ íŠ¸ë ˆì´íŠ¸ë¡œ ì¶”ê°€í•´ ë‚˜ê°€ë©´, íŠ¸ë¦¬ ìì²´ëŠ” ì†ëŒ€ì§€ ì•Šê³  ê¸°ëŠ¥ì„ í™•ì¥í•´ ê°ˆ ìˆ˜ ìˆìŒ.

---

## ì‚¬ê³ ì˜ ì „í™˜ ë‹¨ê³„

### 0) ë§ˆìŒê°€ì§ ë¦¬ì…‹ (ë£° 5ê°œ)
- â€œë¬´ì—‡ì´ë‹¤(is-a)â€ ëŒ€ì‹  **â€œë¬´ì—‡ì„ í•  ìˆ˜ ìˆë‹¤(can-do)â€**ë¥¼ ë¨¼ì € ìƒê°í•œë‹¤ â†’ íŠ¸ë ˆì´íŠ¸ë¡œ í‘œí˜„.
- ìƒìœ„í´ë˜ìŠ¤ í¬ì¸í„° ëŒ€ì‹  ì œë„¤ë¦­ + íŠ¸ë ˆì´íŠ¸ ë°”ìš´ë“œë¥¼ ì“´ë‹¤.
- ê³µìš© ì†Œìœ ëŠ” ê¸°ë³¸ ê¸ˆì§€. í•„ìš”í•  ë•Œë§Œ Arc. ê°€ê¸‰ì  ë¶ˆë³€ ê³µìœ ë¥¼ ê¸°ë³¸ìœ¼ë¡œ.
- ì‹ë³„ì€ í¬ì¸í„°ê°’ì´ ì•„ë‹ˆë¼ **ëª…ì‹œì  í•¸ë“¤(ê³ ìœ  id, Arc::ptr_eq)**ë¡œ.

### 1) ë°ì´í„°â†’í–‰ìœ„ ë³€í™˜
#### ê³¼ì œ A: â€œAABBë¥¼ ì œê³µí•  ìˆ˜ ìˆëŠ” ê²ƒâ€
- C++ì˜ ON_Object* ëŒ€ì‹ :
```rust
pub trait HasAabb {
    fn aabb(&self) -> BoundingBox;
}
```
ì„ì˜ì˜ ë‘ íƒ€ì…(ì˜ˆ: Mesh, Sphere)ì— HasAabb êµ¬í˜„.  
#### ì œë„¤ë¦­ í•¨ìˆ˜ í•˜ë‚˜ ì‘ì„±:
```rust
fn overlaps<T: HasAabb, U: HasAabb>(a: &T, b: &U) -> bool {
    a.aabb().intersects(&b.aabb())
}
```
##### ğŸ‘‰ ëŠë‚Œ: ìƒì† ì—†ì´ í–‰ìœ„ ê³„ì•½ë§Œìœ¼ë¡œ ì¡°í•©ì´ ëœë‹¤.

### 2) ìƒì† ì¹˜í™˜ ì¹´íƒ€ (30ë¶„)
#### ê³¼ì œ B: â€œê¸°ë°˜ í´ë˜ìŠ¤ ì œê±°â€

- C++ì˜ class Drawable : public ON_Object ê°™ì€ ê±¸ ê°€ì •.
#### Rustì—ì„œ:
```rust
pub trait Drawable {
    fn draw(&self, ctx: &mut RenderCtx);
}
```
- ì„œë¡œ ë‹¤ë¥¸ íƒ€ì… ì—¬ëŸ¬ ê°œì— Drawable êµ¬í˜„.
```rust
fn render_all<T: Drawable>(xs: &[T], ctx: &mut RenderCtx) â†’ ì»´íŒŒì¼ ë¶ˆê°€ (íŠ¸ë ˆì´íŠ¸ ê°ì²´í™” í•„ìš”)
```

#### ê³ ì³ ì“°ê¸°:
- ì •ì  ë””ìŠ¤íŒ¨ì¹˜: xs: &[impl Drawable] ë˜ëŠ” ì œë„¤ë¦­ ìŠ¬ë¼ì´ìŠ¤ ì—¬ëŸ¬ ê°œ
- ë™ì  ë””ìŠ¤íŒ¨ì¹˜: Vec<Box<dyn Drawable>> ì‚¬ìš©
- ğŸ‘‰ í¬ì¸íŠ¸: ì •ì /ë™ì  ë””ìŠ¤íŒ¨ì¹˜ë¥¼ ì„ íƒì ìœ¼ë¡œ ì“°ëŠ” ê°ê° ìµíˆê¸°.

### 3) ì†Œìœ /ê³µìœ /ì‹ë³„
#### ê³¼ì œ C: â€œì‚­ì œ/ì—…ë°ì´íŠ¸â€
- SpatialTree<T: HasAabb>ë¥¼ ë§Œë“¤ê³  ì‚½ì…/ì‚­ì œ/ì—…ë°ì´íŠ¸ êµ¬í˜„.
- ì‚½ì…ì€ Arc<T>ë¥¼ ë°›ê³  ë‚´ë¶€ Vec<Arc<T>>ì— ì €ì¥.
- ì‚­ì œëŠ” Arc::ptr_eq(a, b)ë¡œ ë™ì¼ì„± íŒë‹¨.
- ì—…ë°ì´íŠ¸ëŠ” ê¸°ì¡´ ì›ì†Œ ì œê±° í›„ ì¬ì‚½ì….
- ğŸ‘‰ ëŠë‚Œ: í¬ì¸í„°ê°’ ë§ê³  ì˜ë„ëœ ë™ì¼ì„± ê·œì•½ìœ¼ë¡œ ê´€ë¦¬.

### 4) ì˜ì¡´ì„± ì—­ì „
#### ê³¼ì œ D: â€œì¿¼ë¦¬ ì—”ì§„ì´ êµ¬ì²´íƒ€ì…ì„ ëª¨ë¥´ê²Œâ€
```rust
trait IntersectsRay { fn hit(&self, ray: &Ray) -> Option<Hit>; }
```
- `SpatialTree<T: HasAabb + IntersectsRay>` ë¡œ ì œì•½ í™•ì¥.
- íŠ¸ë¦¬ëŠ” Tì˜ êµ¬í˜„ì„ ëª°ë¼ë„ í–‰ìœ„ë§Œ í˜¸ì¶œ.
- ğŸ‘‰ í¬ì¸íŠ¸: ê¸°ëŠ¥ì´ ëŠ˜ì–´ë„ ì»¨í…Œì´ë„ˆëŠ” ë³€í•˜ì§€ ì•ŠëŠ”ë‹¤.

### 5) ì–´ëŒ‘í„° íŒ¨í„´
#### ê³¼ì œ E: â€œê¸°ì¡´ C++ ê°ì²´ ê°ì‹¸ê¸°â€
- C FFIë‚˜ í¬ì¸í„°ë¥¼ struct OnObjectAdapter(*const ON_Object);
- unsafe êµ¬ê°„ì€ ì–´ëŒ‘í„° ë‚´ë¶€ë¡œ ê°€ë‘¬ë‘ê³ , ì™¸ë¶€ì—” HasAabb/IntersectsRayë§Œ ë…¸ì¶œ.
- ğŸ‘‰ í¬ì¸íŠ¸: ë ˆê±°ì‹œë¥¼ ì–´ëŒ‘í„°ë¡œ í¡ìˆ˜ â†’ ìƒˆ ì„¤ê³„ ìœ ì§€.

### 6) ìƒíƒœ/ë¶ˆë³€ ì „ëµ
#### ê³¼ì œ F: â€œì¹´ë©”ë¼ ì»¨íŠ¸ë¡¤ëŸ¬â€
- CameraëŠ” ë‚´ë¶€ ìƒíƒœ ë³´ìœ (ì†Œìœ ).
- ì¡°ì‘ê¸°ëŠ” â€œìˆœìˆ˜ í•¨ìˆ˜ ìŠ¤íƒ€ì¼â€ë¡œ:
```rust
pub trait CameraOp { fn apply(self, cam: Camera) -> Camera; }
```
- Orbit, Pan, Zoomë¥¼ ê°ê° íƒ€ì…ìœ¼ë¡œ ì •ì˜í•˜ê³  ì²´ì¸:
```rust
let cam = Orbit{...}.apply(cam);
let cam = Pan{...}.apply(cam);
```
- ë˜ëŠ” ê°€ë³€ ë ˆí¼ëŸ°ìŠ¤ë¡œ ì¼ê´„ ì ìš©:
```rust
pub trait CameraOpMut { fn apply_mut(&self, cam: &mut Camera); }
```
- ğŸ‘‰ í¬ì¸íŠ¸: ë¶ˆë³€ ì²´ì¸ vs ê°€ë³€ ì ìš©ì„ ì˜ì‹ì ìœ¼ë¡œ ì„ íƒ.

### 7) ì˜¤ë¥˜/ê³„ì•½ ì¹´íƒ€ (20ë¶„)
#### ê³¼ì œ G: â€œê²°ê³¼ íƒ€ì…â€

- ê¸°ì¡´ bool ë¦¬í„´ì„ Result<T, E>ë¡œ ë°”ê¾¸ê¸°.
- FitFromBox ê°™ì€ ê±´ Result<(), FitError>ë¡œ ì„¸ë¶„í™”.
- ìƒìœ„ì—ì„œ ?ë¡œ ì „íŒŒí•˜ê³ , í…ŒìŠ¤íŠ¸ì—ì„œ ì—ëŸ¬ ë¶„ê¸° í™•ì¸.
- ğŸ‘‰ í¬ì¸íŠ¸: ì—ëŸ¬ë„ ê³„ì•½ì˜ ì¼ë¶€.
### 8) í…ŒìŠ¤íŠ¸ ë£¨í‹´

#### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ 3ì¢…:
- í–‰ìœ„ ê³„ì•½ í…ŒìŠ¤íŠ¸: íŠ¸ë ˆì´íŠ¸ êµ¬í˜„ íƒ€ì…ì´ ê³µí†µ ì¼€ì´ìŠ¤ë¥¼ í†µê³¼?
- ì†ì„±(property) í…ŒìŠ¤íŠ¸(quickcheck/proptest): ì˜ˆ) union(aabb, aabb) âŠ‡ aabb
- íšŒê·€ í…ŒìŠ¤íŠ¸: ë²„ê·¸ ì¬í˜„ â†’ í…ŒìŠ¤íŠ¸ ê³ ì •
- ë²¤ì¹˜(criterion) í•˜ë‚˜: SpatialTree::query ì„±ëŠ¥ ì¶”ì .
- ğŸ‘‰ í¬ì¸íŠ¸: â€œë””ìì¸ ê°ê° = í…ŒìŠ¤íŠ¸ ìŠµê´€â€

### 9) ì‘ì€ ë¦¬íŒ©í„° ì£¼ê¸°
- ì •ì  ë””ìŠ¤íŒ¨ì¹˜ â†” ë™ì  ë””ìŠ¤íŒ¨ì¹˜ ì „í™˜
- Vec<Arc<T>> â†” SmallVec/ìŠ¬ë˜ë¸Œ í’€ë¡œ êµì²´(ë‚´ë¶€ë§Œ)
- ë¶„í•  íœ´ë¦¬ìŠ¤í‹± í•¨ìˆ˜ ë¶„ë¦¬ í›„ ì£¼ì… ê°€ëŠ¥í•˜ê²Œ:
```rust
pub trait Splitter { fn split(&self, bb: &BoundingBox) -> (BoundingBox, BoundingBox); }
```
- ğŸ‘‰ í¬ì¸íŠ¸: í™•ì¥ì ì„ ì¸í„°í˜ì´ìŠ¤ë¡œ ì™¸ë¶€í™”.

### 10) ì²´í¬ë¦¬ìŠ¤íŠ¸ (ë¦¬ë·°í•  ë•Œë§ˆë‹¤ ìŠ¤ìŠ¤ë¡œ ë¬»ê¸°)
- ì´ íƒ€ì…ì´ â€œë¬´ì—‡ì„ í•  ìˆ˜ ìˆë‚˜(íŠ¸ë ˆì´íŠ¸)â€ê°€ ëª…í™•í•œê°€?
- ì»¨í…Œì´ë„ˆê°€ êµ¬ì²´ íƒ€ì…ì´ ì•„ë‹ˆë¼ í–‰ìœ„ì—ë§Œ ì˜ì¡´í•˜ë‚˜?
- ê³µìœ ê°€ ì •ë§ í•„ìš”í•œê°€? Arc ì—†ì´ ê°€ëŠ¥í•œê°€?
- ë™ì¼ì„±ì€ ëª…ì‹œì ì¸ê°€?(Arc::ptr_eq, id)
- ì‹¤íŒ¨ëŠ” ì—ëŸ¬ íƒ€ì…ìœ¼ë¡œ í‘œí˜„í–ˆë‚˜?
- í…ŒìŠ¤íŠ¸ê°€ ì„¤ê³„ë¥¼ ì„¤ëª…í•´ì£¼ë‚˜?

---

## ì‹¤ì „: ë„¤ ì½”ë“œ ë² ì´ìŠ¤ì—ì„œ ë°”ë¡œ í•´ë³¼ 3ê°€ì§€

### SpatialTree ì œë„¤ë¦­í™”
- SpatialTree<T: HasAabb> + Vec<Arc<T>> â†’ ê¸°ì¡´ ON_ObjectëŠ” OnObjectAdapterë¡œ ë„£ê¸°.
### RayQuery ë¶„ë¦¬
- IntersectsRay íŠ¸ë ˆì´íŠ¸ ì‹ ì„¤. íŠ¸ë¦¬ëŠ” HasAabbë§Œ ì•Œê²Œ í•˜ê³ , ë ˆì´ ì •í™•ë„/ì¶©ëŒ ì„¸ë¶€ëŠ” ì™¸ë¶€ ì‹œìŠ¤í…œì´ ë§¡ê²Œ.

### Camera ì¡°ì‘ì ë¶„ë¦¬
- CameraOp(â€¦)/CameraOpMut ë‘ ë°©ì‹ ì‹¤í—˜. UI ì´ë²¤íŠ¸ â†’ ì¼ê¸‰ ì—°ì‚°ì(íƒ€ì…)ë¡œ íì‰í–ˆë‹¤ê°€ ì ìš©.

## ë§ˆì§€ë§‰ íŒ
- ì²˜ìŒì—” ë„ˆë¬´ ì¼ë°˜í™”í•˜ì§€ ë§ê¸°. íŠ¸ë ˆì´íŠ¸ëŠ” â€œì§€ê¸ˆ í•„ìš”í•œ ìµœì†Œ í–‰ìœ„â€ë§Œ êµ¬í˜„.
- ì‘ì€ ê³¼ì œë¡œ ê°ê°ì„ ìŒ“ì. ìœ„ ì¹´íƒ€ë¥¼ ì§„ì§œ íŒŒì¼ë¡œ ë§Œë“¤ê³  í…ŒìŠ¤íŠ¸ë¥¼ ëŒë ¤ë³´ê¸°.
- ë§‰í ë•ŒëŠ” â€œìƒì†ìœ¼ë¡œ í’€ë©´ ì–´ë–»ê²Œ í–ˆì„ê¹Œ?â€ë¥¼ ë¨¼ì € ë– ì˜¬ë¦° ë’¤, ê·¸ê±¸ **í–‰ìœ„(íŠ¸ë ˆì´íŠ¸)**ë¡œ ë°”ê¿”ë³´ë©´ ê¸ˆë°© ê°ì´ ì˜´.

---


## 1) AABB êµì°¨ íŒì •
### ë°ì´í„° ì¤‘ì‹¬ (ìƒíƒœë§Œ ê°€ì§„ íƒ€ì… + ìœ í‹¸ í•¨ìˆ˜)
```rust
// ë°ì´í„°ë§Œ ìˆëŠ” íƒ€ì…
struct Object {
    bbox: BoundingBox,
}

// ìœ í‹¸ë¦¬í‹° (ë°ì´í„°ë¥¼ ë°›ì•„ì„œ ì‘ì—…)
fn overlaps(a: &Object, b: &Object) -> bool {
    a.bbox.intersects(&b.bbox)
}

// ì‚¬ìš©
let a = Object { bbox: bb1 };
let b = Object { bbox: bb2 };
let hit = overlaps(&a, &b);
```

### í–‰ìœ„ ì¤‘ì‹¬ (ëŠ¥ë ¥ì„ ê³„ì•½ìœ¼ë¡œ: HasAabb)
```rust
trait HasAabb {
    fn aabb(&self) -> &BoundingBox;
}

struct Mesh { bbox: BoundingBox }
struct Sphere { bbox: BoundingBox }

impl HasAabb for Mesh   { fn aabb(&self) -> &BoundingBox { &self.bbox } }
impl HasAabb for Sphere { fn aabb(&self) -> &BoundingBox { &self.bbox } }

// ì œë„¤ë¦­ í•¨ìˆ˜: ìƒì† ì—†ì´ ì¡°í•©
fn overlaps<T: HasAabb, U: HasAabb>(a: &T, b: &U) -> bool {
    a.aabb().intersects(b.aabb())
}

// ì‚¬ìš©
let hit = overlaps(&mesh, &sphere);
```

- í¬ì¸íŠ¸: â€œë¬´ì—‡ì´ë‹¤(ìƒì†)â€ ëŒ€ì‹  â€œë¬´ì—‡ì„ í•  ìˆ˜ ìˆë‹¤(íŠ¸ë ˆì´íŠ¸)â€ë¡œ ë°”ê¾¸ë©´ íƒ€ì… ì¡°í•©ì´ ììœ ë¡œì›Œì§.

## 2) ë Œë”(ê·¸ë¦¬ê¸°)
### ë°ì´í„° ì¤‘ì‹¬ (íƒœê·¸ enum + í° match)
```rust
enum ShapeKind { Mesh, Sphere }
struct Shape {
    kind: ShapeKind,
    // ì‹¤ì œ ë°ì´í„°ëŠ” ì˜µì…˜/ê³µìœ  í¬ì¸í„° ë“±ìœ¼ë¡œâ€¦
}

fn draw(shape: &Shape, ctx: &mut RenderCtx) {
    match shape.kind {
        ShapeKind::Mesh   => draw_mesh(shape, ctx),
        ShapeKind::Sphere => draw_sphere(shape, ctx),
    }
}
```

### í–‰ìœ„ ì¤‘ì‹¬ (ë™ì  ë””ìŠ¤íŒ¨ì¹˜: dyn Drawable)
```rust
trait Drawable {
    fn draw(&self, ctx: &mut RenderCtx);
}

struct Mesh { /* â€¦ */ }
struct Sphere { /* â€¦ */ }

impl Drawable for Mesh   { fn draw(&self, ctx: &mut RenderCtx) { /*â€¦*/ } }
impl Drawable for Sphere { fn draw(&self, ctx: &mut RenderCtx) { /*â€¦*/ } }

// ì„œë¡œ ë‹¤ë¥¸ íƒ€ì…ì„ í•œ ì»¨í…Œì´ë„ˆì—
let mut list: Vec<Box<dyn Drawable>> = vec![
    Box::new(Mesh{/*â€¦*/}),
    Box::new(Sphere{/*â€¦*/})
];

for d in &list { d.draw(&mut ctx); }
```

- í¬ì¸íŠ¸: ì‹ ê·œ ë„í˜• ì¶”ê°€ ì‹œ match ìˆ˜ì • ì—†ì´ íƒ€ì…ë§Œ ì¶”ê°€ êµ¬í˜„.

## 3) ê³µê°„ íŠ¸ë¦¬(ê°„ì´)
### ë°ì´í„° ì¤‘ì‹¬ (ì˜¤ë¸Œì íŠ¸ ì „ìš© ì»¨í…Œì´ë„ˆ)
```rust
struct Object { bbox: BoundingBox /*â€¦*/ }

struct SpatialTree {
    nodes: Vec<Node>,
    objs:  Vec<Object>,
}

impl SpatialTree {
    fn insert(&mut self, o: Object) { /* bboxë¡œë§Œ ì²˜ë¦¬ */ }
    fn query(&self, q: &BoundingBox) -> Vec<&Object> { /* â€¦ */ vec![] }
}
```

### í–‰ìœ„ ì¤‘ì‹¬ (ì œë„¤ë¦­ ì»¨í…Œì´ë„ˆ + íŠ¸ë ˆì´íŠ¸ë¡œ ì œì•½)
```rust
trait HasAabb { fn aabb(&self) -> &BoundingBox; }

struct SpatialTree<T: HasAabb> {
    nodes: Vec<Node>,
    objs:  Vec<std::sync::Arc<T>>,
}

impl<T: HasAabb> SpatialTree<T> {
    fn insert(&mut self, o: std::sync::Arc<T>) { /* o.aabb() ì‚¬ìš© */ }
    fn query<'a>(&'a self, q: &BoundingBox) -> Vec<&'a T> {
        self.objs.iter().filter_map(|a| {
            if a.aabb().intersects(q) { Some(a.as_ref()) } else { None }
        }).collect()
    }
}
```
- í¬ì¸íŠ¸: íŠ¸ë¦¬ëŠ” â€œë°•ìŠ¤ë¥¼ ì œê³µí•  ìˆ˜ ìˆëŠ” ê²ƒâ€ë§Œ ì•Œë©´ ë¨. ë©”ì‹œ/ì»¤ë¸Œ/ë¼ë²¨â€¦ ë‹¤ ìˆ˜ìš©.

## 4) ì¹´ë©”ë¼ ì¡°ì‘
### ë°ì´í„° ì¤‘ì‹¬ (ìœ í‹¸ í•¨ìˆ˜ ëª¨ìŒ)
```rust
struct Camera { eye: Point3, target: Point3, up: Vector3, /*â€¦*/ }

fn pan(cam: &mut Camera, dx: f64, dy: f64)   { /* â€¦ */ }
fn orbit(cam: &mut Camera, yaw: f64, pitch: f64) { /* â€¦ */ }
fn zoom(cam: &mut Camera, factor: f64)       { /* â€¦ */ }
```

### í–‰ìœ„ ì¤‘ì‹¬ (ì—°ì‚°ì„ 1ê¸‰ ê°ì²´ë¡œ, í•©ì„± ê°€ëŠ¥)
```rust
struct Camera { /* â€¦ */ }

trait CameraOpMut {
    fn apply(&self, cam: &mut Camera);
}

struct Pan { dx: f64, dy: f64 }
struct Orbit { yaw: f64, pitch: f64 }
struct Zoom { factor: f64 }

impl CameraOpMut for Pan   { fn apply(&self, cam: &mut Camera) { /*â€¦*/ } }
impl CameraOpMut for Orbit { fn apply(&self, cam: &mut Camera) { /*â€¦*/ } }
impl CameraOpMut for Zoom  { fn apply(&self, cam: &mut Camera) { /*â€¦*/ } }

fn apply_all(cam: &mut Camera, ops: &[&dyn CameraOpMut]) {
    for op in ops { op.apply(cam); }
}

// ì‚¬ìš©
apply_all(&mut cam, &[&Pan{dx:3.0, dy:1.0}, &Orbit{yaw:10.0, pitch:-5.0}, &Zoom{factor:0.9}]);
```
- í¬ì¸íŠ¸: ì´ë²¤íŠ¸ë¥¼ â€œí–‰ìœ„ ê°ì²´â€ë¡œ íì‰/ë¦¬í”Œë ˆì´/ì• ë‹ˆë©”ì´ì…˜ì— ë°”ë¡œ ì¬ì‚¬ìš© ê°€ëŠ¥.

## 5) ë ˆì´ êµì°¨
### ë°ì´í„° ì¤‘ì‹¬ (ì¢…ë¥˜ë³„ í° ë¶„ê¸°)
```rust
enum Prim { Triangle(Tri), Sphere(Sph) }

fn ray_hit(p: &Prim, ray: &Ray) -> Option<Hit> {
    match p {
        Prim::Triangle(t) => hit_tri(t, ray),
        Prim::Sphere(s)   => hit_sph(s, ray),
    }
}
```
### í–‰ìœ„ ì¤‘ì‹¬ (ì¶©ëŒ ê³„ì•½ ë¶„ë¦¬)
```rust
trait IntersectsRay {
    fn hit(&self, ray: &Ray) -> Option<Hit>;
}

struct Triangle { /*â€¦*/ }
struct Sphere   { /*â€¦*/ }

impl IntersectsRay for Triangle { fn hit(&self, ray: &Ray) -> Option<Hit> { /*â€¦*/ } }
impl IntersectsRay for Sphere   { fn hit(&self, ray: &Ray) -> Option<Hit> { /*â€¦*/ } }

// ì»¨í…Œì´ë„ˆëŠ” í–‰ìœ„ë§Œ ì˜ì¡´
fn first_hit(xs: &[&dyn IntersectsRay], ray: &Ray) -> Option<Hit> {
    xs.iter().filter_map(|x| x.hit(ray)).min_by(|a,b| a.t.total_cmp(&b.t))
}
```

- í¬ì¸íŠ¸: ìƒˆë¡œìš´ í”„ë¦¬ë¯¸í‹°ë¸Œ ì¶”ê°€ ì‹œ ì»¨í…Œì´ë„ˆ/ì—”ì§„ ìˆ˜ì • ì—†ì´ í™•ì¥.

--- 

# ì¶”ê°€ íŒ

## 1) ì´ë²¤íŠ¸ íŒŒì´í”„ë¼ì¸
### (A) ë°ì´í„° ì¤‘ì‹¬: ê±°ëŒ€í•œ match + ìˆ˜ë™ íŒŒì´í”„
```rust
// ì´ë²¤íŠ¸ì™€ ì»¨í…ìŠ¤íŠ¸(íŒŒì´í”„ ìƒíƒœ)
#[derive(Debug, Clone)]
enum Event { Key(char), Click { x: i32, y: i32 }, Quit }

#[derive(Default)]
struct PipelineCtx {
    log: Vec<String>,
    quit: bool,
}

// ë‹¨ê³„ë³„ë¡œ "ë°ì´í„°ë¥¼ ë°›ì•„ ì‘ì—…"
fn log_stage(ev: &Event, ctx: &mut PipelineCtx) {
    ctx.log.push(format!("seen: {:?}", ev));
}

fn filter_stage(ev: &Event, ctx: &mut PipelineCtx) {
    if matches!(ev, Event::Key(' ')) {
        ctx.log.push("filtered space".into());
    }
}

fn handle_stage(ev: &Event, ctx: &mut PipelineCtx) {
    match ev {
        Event::Quit => ctx.quit = true,
        Event::Key(c) => ctx.log.push(format!("key={}", c)),
        Event::Click { x, y } => ctx.log.push(format!("click=({},{})", x, y)),
    }
}

fn run_pipeline(events: &[Event], ctx: &mut PipelineCtx) {
    for ev in events {
        // ìˆ˜ë™ìœ¼ë¡œ íŒŒì´í”„ ìˆœì„œë¥¼ ìœ ì§€/í˜¸ì¶œ
        log_stage(ev, ctx);
        filter_stage(ev, ctx);
        handle_stage(ev, ctx);
        if ctx.quit { break; }
    }
}

fn main() {
    let events = vec![Event::Key('a'), Event::Click { x: 3, y: 5 }, Event::Quit];
    let mut ctx = PipelineCtx::default();
    run_pipeline(&events, &mut ctx);
    println!("ctx={:?}", ctx.log);
}
```
### (B) í–‰ìœ„ ì¤‘ì‹¬: EventHandler íŠ¸ë ˆì´íŠ¸ + ì²´ì¸(ë¯¸ë“¤ì›¨ì–´)
```rust
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug, Clone)]
enum Event { Key(char), Click { x: i32, y: i32 }, Quit }

#[derive(Default, Debug)]
struct PipelineCtx { log: Vec<String>, quit: bool }

trait EventHandler {
    fn handle(&self, ev: &Event, ctx: &mut PipelineCtx);
}

struct Logger;
impl EventHandler for Logger {
    fn handle(&self, ev: &Event, ctx: &mut PipelineCtx) {
        ctx.log.push(format!("seen: {:?}", ev));
    }
}

struct SpaceFilter;
impl EventHandler for SpaceFilter {
    fn handle(&self, ev: &Event, ctx: &mut PipelineCtx) {
        if matches!(ev, Event::Key(' ')) {
            ctx.log.push("filtered space".into());
        }
    }
}

struct Core;
impl EventHandler for Core {
    fn handle(&self, ev: &Event, ctx: &mut PipelineCtx) {
        match ev {
            Event::Quit => ctx.quit = true,
            Event::Key(c) => ctx.log.push(format!("key={}", c)),
            Event::Click { x, y } => ctx.log.push(format!("click=({},{})", x, y)),
        }
    }
}

// íŒŒì´í”„ë¼ì¸: í•¸ë“¤ëŸ¬ë“¤ì„ ì¡°í•©(ìˆœì„œë§Œ ë°”ê¾¸ë©´ ì •ì±… êµì²´)
struct Pipeline {
    stages: Vec<Rc<dyn EventHandler>>,
}
impl Pipeline {
    fn new(stages: Vec<Rc<dyn EventHandler>>) -> Self { Self { stages } }
    fn run(&self, events: &[Event], ctx: &mut PipelineCtx) {
        'outer: for ev in events {
            for st in &self.stages {
                st.handle(ev, ctx);
                if ctx.quit { break 'outer; }
            }
        }
    }
}

fn main() {
    let pipe = Pipeline::new(vec![
        Rc::new(Logger),
        Rc::new(SpaceFilter),
        Rc::new(Core),
    ]);
    let events = vec![Event::Key('a'), Event::Click { x: 3, y: 5 }, Event::Quit];
    let mut ctx = PipelineCtx::default();
    pipe.run(&events, &mut ctx);
    println!("ctx={:?}", ctx);
}
```
### í•µì‹¬ ì°¨ì´
- ë°ì´í„° ì¤‘ì‹¬: â€œí•¨ìˆ˜ + í° matchâ€ ì— ì´ë²¤íŠ¸ë¥¼ ê³„ì† ê°€ì ¸ë‹¤ ë„£ìŒ(ê²°í•©â†‘).
- í–‰ìœ„ ì¤‘ì‹¬: â€œí•¸ë“¤ëŸ¬ì˜ ëŠ¥ë ¥â€ ì„ ì¡°í•©í•´ì„œ íŒŒì´í”„ë¥¼ êµ¬ì„±(í™•ì¥/ì¬ë°°ì¹˜ê°€ ì‰¬ì›€).

## 2) ë·°â€“ëª¨ë¸ ë°”ì¸ë”©
### (A) ë°ì´í„° ì¤‘ì‹¬: ëª¨ë¸ ë³€ê²½ í›„ ìˆ˜ë™ìœ¼ë¡œ ë·° ê°±ì‹  í˜¸ì¶œ
```rust
#[derive(Default, Debug, Clone)]
struct Model { count: i32 }

#[derive(Default)]
struct View { last_text: String }
impl View {
    fn render(&mut self, m: &Model) {
        self.last_text = format!("count = {}", m.count);
        println!("render: {}", self.last_text);
    }
}

// ì»¨íŠ¸ë¡¤ëŸ¬ê°€ "ëª¨ë¸ ìˆ˜ì • â†’ ë·° ë Œë”"ë¥¼ ë§¤ë²ˆ ìˆ˜ë™ í˜¸ì¶œ
fn main() {
    let mut model = Model::default();
    let mut view  = View::default();

    model.count += 1;
    view.render(&model);

    model.count += 10;
    view.render(&model);
}
```
### (B) í–‰ìœ„ ì¤‘ì‹¬: Observable ì‹œê·¸ë„ + Observerë¡œ ìë™ ë°”ì¸ë”©
```rust
use std::rc::Rc;
use std::cell::RefCell;

// ì•„ì£¼ ì–‡ì€ Observable (ê°’ ë³€ê²½ì‹œ êµ¬ë…ìì—ê²Œ í†µì§€)
struct Signal<T> {
    value: RefCell<T>,
    subs: RefCell<Vec<Box<dyn Fn(&T)>>>,
}
impl<T: Clone> Signal<T> {
    fn new(v: T) -> Self { Self { value: RefCell::new(v), subs: RefCell::new(vec![]) } }
    fn get(&self) -> T { self.value.borrow().clone() }
    fn set(&self, v: T) {
        *self.value.borrow_mut() = v;
        for f in self.subs.borrow().iter() { f(&self.value.borrow()); }
    }
    fn subscribe<F: Fn(&T) + 'static>(&self, f: F) {
        self.subs.borrow_mut().push(Box::new(f));
    }
}

// ëª¨ë¸ì€ "ì‹œê·¸ë„"ë¡œ ë…¸ì¶œ
#[derive(Clone)]
struct Model {
    count: Rc<Signal<i32>>,
}
impl Model {
    fn new() -> Self { Self { count: Rc::new(Signal::new(0)) } }
}

// ë·°ëŠ” ëª¨ë¸ì˜ ì‹œê·¸ë„ì„ êµ¬ë…í•˜ê³ , ë³€ê²½ë˜ë©´ ìë™ ë Œë”
struct View {
    last_text: String,
}
impl View {
    fn new(m: &Model) -> Self {
        let mut me = Self { last_text: String::new() };
        let text_ref = Rc::new(RefCell::new(String::new()));
        // êµ¬ë…: ëª¨ë¸ countê°€ ë°”ë€Œë©´ ë Œë” í˜¸ì¶œ
        {
            let text_ref = text_ref.clone();
            m.count.subscribe(move |v| {
                *text_ref.borrow_mut() = format!("count = {}", v);
                println!("render: {}", text_ref.borrow());
            });
        }
        me
    }
}

fn main() {
    let model = Model::new();
    let _view  = View::new(&model); // êµ¬ë… ì‹œì‘

    model.count.set(1);    // ìë™ ë Œë”
    model.count.set(11);   // ìë™ ë Œë”
}
```

### í•µì‹¬ ì°¨ì´
- ë°ì´í„° ì¤‘ì‹¬: ëª¨ë¸ì„ ë°”ê¾¼ ë’¤ í•­ìƒ ìˆ˜ë™ìœ¼ë¡œ view.render()ë¥¼ í˜¸ì¶œí•´ì•¼ í•¨(ëˆ„ë½ ìœ„í—˜).
- í–‰ìœ„ ì¤‘ì‹¬: â€œëª¨ë¸ì´ ê°’ ë³€ê²½ í–‰ìœ„ë¥¼ ë°œí–‰ â†’ êµ¬ë…í•œ ë·°ê°€ ë°˜ì‘â€ìœ¼ë¡œ ìë™í™”(ê²°í•©â†“, ì¬ì‚¬ìš©â†‘).

## ì™œ â€œí–‰ìœ„ ì¤‘ì‹¬â€ì¸ê°€
- ë°ì´í„° ëª¨ë¸(ëª…ì‚¬)ë³´ë‹¤ ëŠ¥ë ¥/ì—­í• (ë™ì‚¬) ì„ 1ê¸‰ ì‹œë¯¼ìœ¼ë¡œ ë‹¤ë£¸.
- â€œì–´ë–¤ íƒ€ì…ì¸ê°€?â€ë³´ë‹¤ **â€œë¬´ì—‡ì„ í•  ìˆ˜ ìˆëŠ”ê°€?â€**ê°€ API í‘œë©´ì´ ë¨.
- êµ¬ì„±(Composition) + íŠ¸ë ˆì´íŠ¸(Interface) ë¡œ ì‹œìŠ¤í…œì„ ì¬ë°°ì—´í•˜ê¸° ì‰¬ì›€.
- ëŸ°íƒ€ì„ì— ì •ì±…/ì „ëµ êµì²´(íŒŒì´í”„ë¼ì¸, ë¯¸ë“¤ì›¨ì–´, í”ŒëŸ¬ê·¸ì¸)ê°€ ì‰¬ì›€.


----

## ì‚¬ê³  ì²´ì¸ì§€ë¥¼ ìœ„í•œ 4ë¬¸ì¥

- ë¨¼ì € ë™ì‚¬ë¥¼ ë½‘ëŠ”ë‹¤: Log/Filter/Handle, Render/Validate/Apply, Load/Cache/Fetch â€¦
- ë™ì‚¬ë§ˆë‹¤ íŠ¸ë ˆì´íŠ¸ë¡œ í‘œì¤€í™”: trait Logger { fn log(&self, â€¦) }
- íŠ¸ë ˆì´íŠ¸ êµ¬í˜„ë¬¼ì„ ì¡°í•©í•´ì„œ íŒŒì´í”„/íŒŒì‚¬ë“œ êµ¬ì„±.
- ìƒíƒœëŠ” ì»¨í…ìŠ¤íŠ¸ í•˜ë‚˜ë¡œ ëª¨ì•„ì„œ &mut ctxë¡œ í˜ë¦°ë‹¤. (ë¶€ìˆ˜íš¨ê³¼ëŠ” ëª¨ë‘ ì—¬ê¸°ë¡œ)

## OOP â†’ í–‰ìœ„ ì¤‘ì‹¬ â€œë§¤í•‘í‘œâ€ (Rust ê´€ì )
- ìƒì† íŠ¸ë¦¬ â†’ trait ì§‘í•© + êµ¬ì„±ì²´(í•„ë“œë¡œ ì „ëµ ë³´ê´€)
- ê°€ìƒ í•¨ìˆ˜ ì˜¤ë²„ë¼ì´ë“œ â†’ dyn Trait(ëŸ°íƒ€ì„) / ì œë„¤ë¦­ T: Trait(ì»´íŒŒì¼íƒ€ì„)
- ê³µí†µ ìƒìœ„ í´ë˜ìŠ¤(ON_Object) â†’ â€œë¹ˆ ë² ì´ìŠ¤â€ ì œê±°, ëŠ¥ë ¥ íŠ¸ë ˆì´íŠ¸ë¡œ ë¶„í•´  
    ì˜ˆ: trait Bounded { fn bbox(&self) -> BoundingBox; }
- ê±°ëŒ€ ë§¤ì¹˜/ìŠ¤ìœ„ì¹˜ â†’ íŠ¸ë ˆì´íŠ¸ í´ë¦¬ëª°í”¼ì¦˜ìœ¼ë¡œ ë¶„ì‚°
- ì˜µì €ë²„/ì‹ í˜¸ â†’ ê²½ëŸ‰ ì´ë²¤íŠ¸ ë²„ìŠ¤ or Signal/subscribe(ì´ì „ ì˜ˆì œ)
- ì‹±ê¸€í†¤ â†’ ì»¨í…ìŠ¤íŠ¸ ì£¼ì…(ëª…ì‹œì ìœ¼ë¡œ &mut Ctx ì „ë‹¬)

## ë¦¬íŒ©í„°ë§ ì²´í¬ë¦¬ìŠ¤íŠ¸ (ì‘ê²ŒÂ·ë¹ ë¥´ê²Œ)
- ë™ì‚¬ ëª©ë¡í™”  
    íŒŒì¼/ëª¨ë“ˆì„ í›‘ì–´ â€œê¸°ëŠ¥ ì´ë¦„(ë™ì‚¬)â€ë§Œ ë¹¼ì„œ ì ê¸°. (ë¡œê¹…, ê²€ì¦, ì§ë ¬í™”, í”½í‚¹, ì¹´ë©”ë¼ ì¡°ì‘â€¦)
- íŠ¸ë ˆì´íŠ¸ ì„ ì–¸ (ì´ë¦„=ë™ì‚¬)
- ë©”ì„œë“œëŠ” í˜‘ì—…ì— í•„ìš”í•œ ìµœì†Œ ì¸ìë§Œ: fn handle(&self, ev: &Event, ctx: &mut Ctx)  
    ê°€ëŠ¥í•˜ë©´ ë¶ˆë³€ self (&self), ë¶€ìˆ˜íš¨ê³¼ëŠ” ctx.

## ì»¨í…ìŠ¤íŠ¸ ì„¤ê³„
- ë³€ê²½ ìƒíƒœ, ìºì‹œ, í†µê³„, ì¶œë ¥ ë²„í¼ ë“± ëª¨ë“  ì‚¬ì´ë“œ ì´í™íŠ¸ë¥¼ Ctxì—.
- IO/ë¦¬ì†ŒìŠ¤ í•¸ë“¤(ë™ê¸°/ë¹„ë™ê¸°), ì‹œê°„, ëœë¤ ì”¨ë“œë„ ì—¬ê¸°ë¡œ.

## íŒŒì´í”„/ì¡°ë¦½ ì½”ë“œ ë§Œë“¤ê¸°
- Vec<Rc<dyn Trait>> or ì œë„¤ë¦­ Pipeline<T: Trait>.
- ìˆœì„œÂ·êµì²´Â·ì¡°ê±´ ë¶„ê¸°ë¥¼ ì¡°ë¦½ë¶€ë¡œ ë¹¼ê¸°(í•¸ë“¤ëŸ¬ëŠ” ìˆœìˆ˜).

## ê±°ëŒ€ íƒ€ì… ë¶„í•´
- ë°ì´í„° êµ¬ì¡°ëŠ” ìˆœìˆ˜ ë°ì´í„°ë§Œ ë‚¨ê¸°ê³ , í–‰ìœ„ëŠ” ì™¸ë¶€ íŠ¸ë ˆì´íŠ¸ë¡œ.  
    ì˜ˆ: BoundingBoxëŠ” ê³„ì‚°/ì¡°í•© ë¡œì§ë§Œ, ì‚½ì…/ê²€ìƒ‰ì€ SpatialIndex íŠ¸ë ˆì´íŠ¸ë¡œ.

## í…ŒìŠ¤íŠ¸ ê³ ì •
- ê° ë™ì‚¬ íŠ¸ë ˆì´íŠ¸ì— í‘œì¤€ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸(ì…ë ¥â†’ctx ë³€í™”).
- ì¡°í•©(Pipeline/ECS)ì—ì„  êµ¬ì„± ìˆœì„œê°€ ê²°ê³¼ì— ë¯¸ì¹˜ëŠ” ì˜í–¥ í…ŒìŠ¤íŠ¸.

## ì•ˆí‹°íŒ¨í„´ ë¹¨ê°„ë¶ˆ
- â€œBase í´ë˜ìŠ¤ë¡œ ë‹¤ ë•Œë ¤ë„£ê¸°â€: ê³µí†µ ë°ì´í„° + ê³µí†µ ë™ì‘ì„ í•œ ê³³ì— ëª°ì§€ ë§ ê²ƒ.
- â€œê±°ëŒ€í•œ enum + match 500ì¤„â€: ê¸°ëŠ¥ì´ ëŠ˜ìˆ˜ë¡ ìˆ˜ì • ë°˜ê²½ í­ì¦.
- â€œì—¬ê¸°ì €ê¸°ì„œ ìƒíƒœ ìˆ˜ì •â€: ctx ì™¸ë¶€ì—ì„œ ì‚¬ì´ë“œ ì´í™íŠ¸ ë°œìƒ ê¸ˆì§€.
- â€œíŠ¸ë ˆì´íŠ¸ì— ìƒíƒœë¥¼ ìŒ“ìŒâ€: ì¬ì‚¬ìš©/ë™ì‹œì„±ì— ë¶ˆë¦¬. ìƒíƒœëŠ” ê°€ëŠ¥í•œ ctx.

## ì‘ì€ ë¦¬íŒ©í„°ë§ ì˜ˆ(ê³µê°„ íŠ¸ë¦¬)
### (Before) ë°ì´í„° ì¤‘ì‹¬
```rust
struct ObjectNode { bbox: BoundingBox, ty: ObjectKind, /* â€¦ */ }
// ê±°ëŒ€í•œ match ë¡œ íƒ€ì…ë³„ êµì°¨/ì‚½ì…/ì‚­ì œ ì²˜ë¦¬
fn insert(tree: &mut Tree, obj: &ObjectNode) { /* match obj.ty { â€¦ } */ }
```
### (After) í–‰ìœ„ ì¤‘ì‹¬
```rust
trait Bounded { fn bbox(&self) -> BoundingBox; }
trait HitTest { fn hits(&self, ray: &Ray) -> bool; }

struct SpatialTree {
    items: Vec<Box<dyn Bounded>>,    // or dyn (Bounded + HitTest) if needed
}

impl SpatialTree {
    fn insert(&mut self, b: Box<dyn Bounded>) { self.items.push(b); }
    fn query_box(&self, q: &BoundingBox) -> Vec<&dyn Bounded> {
        self.items.iter().map(|b| &**b)
            .filter(|b| b.bbox().intersects(q)).collect()
    }
}
```

---

# â€œë¬´ì—‡(ë°ì´í„°)ì¸ê°€?â€ì—ì„œ â€œë¬´ì—‡ì„ í•  ì¤„ ì•„ëŠ”ê°€(íŠ¸ë ˆì´íŠ¸)?â€ë¡œ ì´ë™.

## ì‹¤ì „ ì—°ìŠµ ë£¨íŠ¸ (2ì£¼ ë¶„ëŸ‰ ìŠ¤ìŠ¤ë¡œ í•™ìŠµ í”Œëœ)
### Day 1â€“2
- ê¸°ì¡´ ëª¨ë“ˆ 1ê°œ ê³¨ë¼ ë™ì‚¬ ë½‘ê¸° â†’ íŠ¸ë ˆì´íŠ¸ ì„ ì–¸ â†’ ctx ì„¤ê³„ë§Œ í•´ë³´ê¸°(ì½”ë“œ ë¯¸ì´ë™).
- ì»´íŒŒì¼ ì•ˆ í•´ë„ ì¢‹ìœ¼ë‹ˆ ì¸í„°í˜ì´ìŠ¤ ìŠ¤ì¼€ì¹˜ ìš°ì„ .
### Day 3â€“4
- 200~400ì¤„ì§œë¦¬ ê¸°ëŠ¥ì„ íŒŒì´í”„ë¼ì¸í™”(ë¡œê¹…Â·ê²€ì¦Â·í•¸ë“¤ ìˆœìœ¼ë¡œ 3ë‹¨).
### Day 5â€“7
- ë·°â€“ëª¨ë¸ í•œ êµ°ë°ì— ì‹œê·¸ë„/êµ¬ë… ì‚½ì…(ìˆ˜ë™ í˜¸ì¶œ ì œê±°).
- íšŒê·€ í…ŒìŠ¤íŠ¸ë¡œ ë Œë” í˜¸ì¶œ ëˆ„ë½ì´ ì‚¬ë¼ì¡ŒëŠ”ì§€ í™•ì¸.

### Week 2
- ê³µê°„ íŠ¸ë¦¬/í”½í‚¹/ì¹´ë©”ë¼ ì¤‘ í•˜ë‚˜ë¥¼ íŠ¸ë ˆì´íŠ¸ ë‹¨ìœ„ë¡œ ë¶„í• í•˜ê³  ë²¤ì¹˜.
- â€œêµ¬ì„± êµì²´â€ ì‹œë‚˜ë¦¬ì˜¤(ì˜ˆ: ì—¬ëŸ¬ í•„í„°/ë¡œê±° ì¡°í•©)ë¡œ ìœ ì—°ì„± ì²´ê°.

## ë¬¸ì„œí™” í…œí”Œë¦¿(íŒ€ ê³µìœ ìš©)
- ëª©í‘œ: â€œX ëª¨ë“ˆì„ í–‰ìœ„ ì¤‘ì‹¬ìœ¼ë¡œ ì „í™˜í•˜ì—¬ ___ì„ ê°€ëŠ¥í•˜ê²Œ í•œë‹¤.â€
- ë™ì‚¬ ëª©ë¡: Log, Filter, Handle, Render, Validateâ€¦
- íŠ¸ë ˆì´íŠ¸ ì‚¬ì–‘
```rust
trait Xxx { fn op(&self, input: &A, ctx: &mut Ctx) -> Result<B>; }
```
- ì…ë ¥/ì¶œë ¥/ë¶€ìˆ˜íš¨ê³¼(ì–´ë–¤ í•„ë“œë¥¼ ë°”ê¾¸ëŠ”ê°€)ë¥¼ ê¸€ë¨¸ë¦¬í‘œë¡œ.
- ì»¨í…ìŠ¤íŠ¸ ì •ì˜: í•„ë“œ, ìŠ¤ë ˆë”©, ì˜¤ë¥˜ ì •ì±….
- ì¡°ë¦½ ì˜ˆ: ê¸°ë³¸/ë””ë²„ê·¸/í…ŒìŠ¤íŠ¸ íŒŒì´í”„ë¼ì¸ 3ì¢….
- ë§ˆì´ê·¸ë ˆì´ì…˜: ë°”ë€ public API, ì‚­ì œëœ ì½”ë“œ, ëŒ€ì²´ ì§€ì¹¨.

## í…ŒìŠ¤íŠ¸: ë‹¨ìœ„/í†µí•©/ì„±ëŠ¥ ê¸°ì¤€.

## ë§ˆì§€ë§‰ íŒ

- ì²˜ìŒë¶€í„° â€œì „ë¶€ ë°”ê¾¸ê¸°â€ë³´ë‹¤ ê²½ê³„(Adaptor) ë¥¼ ë§Œë“¤ì–´ ì„¬â†’ëŒ€ë¥™ ìˆœìœ¼ë¡œ ë„“íˆì„¸ìš”.
- â€œì„±ëŠ¥ ê±±ì •â€ì€ ì¸í„°í˜ì´ìŠ¤ê°€ ì•ˆì •ëœ í›„ì—. ì œë„¤ë¦­ë¡œ ë°”ê¿” ì¸ë¼ì´ë‹í•˜ë©´ ëŒ€ë¶€ë¶„ í•´ê²°.
- íŠ¸ë ˆì´íŠ¸ëŠ” â€œì¶”ìƒí™”â€ê°€ ì•„ë‹ˆë¼ ì¡°ë¦½ì ì…ë‹ˆë‹¤. ì‘ê³  í•œì •ëœ ë™ì‚¬ë¡œ ìª¼ê°œëŠ” ê²Œ í•µì‹¬.

---


## 1) ìˆ˜ë ì„ í”¼í•˜ëŠ” ëŒ€ì›ì¹™ 7

- ë™ì‚¬ë§Œ ë¨¼ì €, íƒ€ì…/ë¼ì´í”„íƒ€ì„ì€ ë‚˜ì¤‘
- ì‹œê·¸ë‹ˆì²˜ë¥¼ ì¼ë‹¨ â€œê°’ ì¤‘ì‹¬â€ìœ¼ë¡œ ì“°ì„¸ìš”. ì°¸ì¡°ëŠ” ìµœëŒ€í•œ ë¯¸ë£¨ê³ , ê°€ëŠ¥í•˜ë©´ Clone + Cow/Arcë¡œ ì‹œì‘í•©ë‹ˆë‹¤.
- ëª¨ë“  ë¶€ìˆ˜íš¨ê³¼ëŠ” Ctx í•˜ë‚˜ë¡œ íŠ¸ë ˆì´íŠ¸ëŠ” &self(ë¶ˆë³€) + &mut Ctxë§Œ ë°›ê²Œ í•˜ë©´ lifetime ì „íŒŒê°€ ê±°ì˜ ì—†ìŠµë‹ˆë‹¤.
```rust
trait Step { fn run(&self, input: &Input, ctx: &mut Ctx) -> Result<Output>; }
```

### Trait Object(ëŸ°íƒ€ì„ ë‹¤í˜•)ë¶€í„° ì‹œì‘
- ì œë„¤ë¦­ë¡œ ì‹œì‘í•˜ë©´ lifetime/íƒ€ì… ì „íŒŒê°€ í­ë°œí•´ìš”. ì´ˆíŒì€:
```rust
type BoxStep = Box<dyn Step>; // or Rc<dyn Step>
struct Pipeline { steps: Vec<BoxStep> }
```
- ì„±ëŠ¥ ë³‘ëª©ì´ ë³´ì¼ ë•Œë§Œ ì œë„¤ë¦­ë¡œ ì˜¬ë¦½ë‹ˆë‹¤.

### ID/í•¸ë“¤ íŒ¨í„´ (Arena/ECSì‹)
- êµ¬ì¡°ì²´ ì°¸ì¡°ë¥¼ íŠ¸ë ˆì´íŠ¸ì— ë„£ì§€ ë§ê³ , IDë¡œ ì°¸ì¡°í•˜ê³  ì‹¤ì œ ë°ì´í„°ëŠ” Ctx/ì•„ë ˆë‚˜ê°€ ì†Œìœ :
```rust
struct MeshId(u32);
struct Ctx { meshes: Arena<Mesh>, /* ... */ }
trait Op { fn apply(&self, id: MeshId, ctx: &mut Ctx); } // â† ìˆ˜ëª… í”„ë¦¬
```

### ê°ì²´ ì•ˆì „(Object-safe) ê·œì¹™ì„ ì§€ì¼œë¼
- íŠ¸ë ˆì´íŠ¸ ì˜¤ë¸Œì íŠ¸ë¡œ ì“¸ ê±°ë©´: ì œë„¤ë¦­ ë©”ì„œë“œ/Self: Sized/ì—°ê´€ ìƒìˆ˜ ë‚¨ë°œ ê¸ˆì§€.
- í•„ìš”í•˜ë©´ â€œë‘ ê°œì˜ íŠ¸ë ˆì´íŠ¸â€ë¡œ ë‚˜ëˆ ì„œ, ë°”ê¹¥ì€ ì˜¤ë¸Œì íŠ¸-ì„¸ì´í”„, ì•ˆìª½ì€ ì œë„¤ë¦­ë¡œ.
- ì½œë°±ì€ HRTBë¡œ ë°›ê¸° (ìˆ˜ëª… ì˜¤ì—¼ ë°©ì§€)
```rust
fn visit<F>(&self, f: F) where for<'a> F: FnMut(&'a Node) { /* ... */ }
```
- ì´ë ‡ê²Œ í•˜ë©´ í˜¸ì¶œì ìˆ˜ëª…ì´ êµ¬í˜„ìœ¼ë¡œ ìƒˆì–´ë“¤ì§€ ì•Šì•„ìš”.
- ì´ˆê¸°ì—ëŠ” â€˜ì†Œìœ â€™ë¥¼ ë‘ê»ê²Œ &[T]ë³´ë‹¤ Arc<[T]> / Cow<'_, T> / SmallVec ë“±ì„ ì¨ì„œ ì„¤ê³„ í™•ì • ì „ê¹Œì§€ ìˆ˜ëª… ì˜ì¡´ì„ ì¤„ì…ë‹ˆë‹¤.

## 2) ë‚˜ìœ/ì¢‹ì€ íŠ¸ë ˆì´íŠ¸ ì‹œê·¸ë‹ˆì²˜ ë¹„êµ (ìˆ˜ëª… í­íƒ„ ë°©ì§€)
### âŒ ë‚˜ì¨: ìˆ˜ëª…ì„ ì™¸ë¶€ë¡œ ìƒˆê²Œ ë§Œë“¦
```rust
trait Intersect<'a> {
    fn hit(&'a self, a: &'a Mesh, b: &'a Mesh) -> bool; // 'aê°€ ì „ì²´ë¥¼ ì§€ë°°
}
```

### âœ… ì¢‹ìŒ: ì»¨í…ìŠ¤íŠ¸ì— ì†Œìœ /ìºì‹œ ëª¨ìŒ, íŠ¸ë ˆì´íŠ¸ëŠ” ì–‡ê²Œ
```rust
struct Ctx<'s> { meshes: &'s Arena<Mesh>, scratch: Scratch, /* ... */ }
trait Intersect {
    fn hit(&self, a: MeshId, b: MeshId, ctx: &mut Ctx) -> bool;
}
```
- ì™¸ë¶€ ìˆ˜ëª…ì´ íŠ¸ë ˆì´íŠ¸ ì‹œê·¸ë‹ˆì²˜ì— ë“±ì¥í•˜ì§€ ì•Šìœ¼ë‹ˆ íŠ¸ë ˆì´íŠ¸ëŠ” â€˜ìˆ˜ëª… ì¤‘ë¦½â€™.
- ì‹¤ì œ ì°¸ì¡°ëŠ” ctx.meshes.get(a) ì•ˆì—ì„œë§Œ ì ê¹ ë¹Œë ¤ ì”€.

## 3) â€œì´ˆíŒì€ ëŸ°íƒ€ì„, ë³‘ëª©ë§Œ ì œë„¤ë¦­â€ ë‹¨ê³„ì  ì—…ê·¸ë ˆì´ë“œ
### 1ë‹¨ê³„: ë¹ ë¥¸ ì¡°ë¦½ (ëŸ°íƒ€ì„ ë‹¤í˜•)
```rust
trait Step { fn run(&self, input: &Input, ctx: &mut Ctx) -> Output; }
struct Pipeline { steps: Vec<Box<dyn Step>>; }
```
### 2ë‹¨ê³„: ì„±ëŠ¥ ë¯¼ê° êµ¬ê°„ë§Œ ì œë„¤ë¦­ë¡œ
```rust
trait StepImpl { fn run_impl(&self, input: &Input, ctx: &mut Ctx) -> Output; }
struct Pipeline<T: StepImpl> { steps: Vec<T> } // í•µì‹¬ ë£¨í”„ë§Œ monomorphization
```
### 3ë‹¨ê³„: í•˜ì´ë¸Œë¦¬ë“œ
- ìƒìœ„ ì¡°ë¦½ì€ dyn Step, ë‚´ë¶€ ëœ¨ê±°ìš´ ë£¨í”„ëŠ” T: Kernelë¡œ ë¶„ë¦¬.

## 4) ìˆ˜ëª… ì¤„ì´ëŠ” 6ê°€ì§€ íŒ¨í„´ (ì½”ë“œ ì¡°ê°)

### (a) ì…ë ¥ì€ ê°’/ê²½ëŸ‰ë³µì‚¬
```rust
#[derive(Clone)]
struct Command { name: Arc<str>, args: Arc<[u8]> }
trait Handle { fn handle(&self, cmd: Command, ctx: &mut Ctx); }
```

### (b) GATë¡œ ì´í„°ë ˆì´í„°/ë·° ë…¸ì¶œ (í•„ìš”í•  ë•Œë§Œ)
```rust
trait Scene {
    type Iter<'a>: Iterator<Item = &'a Node> where Self: 'a;
    fn nodes(&self) -> Self::Iter<'_>;
}
```

### (c) ë¹Œë”ë¡œ â€˜êµ¬ì„±â€™ê³¼ â€˜ìˆ˜í–‰â€™ ë¶„ë¦¬
```rust
struct PipelineBuilder { steps: Vec<Box<dyn Step>> }
impl PipelineBuilder {
    fn add(mut self, s: impl Step + 'static) -> Self { self.steps.push(Box::new(s)); self }
    fn build(self) -> Pipeline { Pipeline { steps: self.steps } }
}
```

### (d) ì—ëŸ¬ ì •ì±…ì€ enumìœ¼ë¡œ ì¤‘ì•™ì§‘ì¤‘
```rust
enum Policy { Strict, BestEffort }
struct Ctx { policy: Policy, errors: Vec<anyhow::Error> }
```

### (e) ìŠ¤ì¼€ì¤„/ì´ë²¤íŠ¸ íŒŒì´í”„ëŠ” â€˜ë°ì´í„°â†’í–‰ìœ„â€™ ë¶„ë¦¬
```rust
enum Event { Mouse{..}, Key{..} }
trait Listener { fn on(&self, ev: &Event, ctx: &mut Ctx); }
```

### (f) ì–´ëŒ‘í„°/ìƒˆì¥(Sealed)ë¡œ ì™¸ë¶€ í™•ì¥ ì œì–´
```rust
mod sealed { pub trait Sealed {} }
pub trait Bounded: sealed::Sealed { fn bbox(&self) -> Aabb; }
```

## 5) â€œë˜ëŒë¦¬ê¸° ì‰¬ìš´â€ ì•ˆì „ì¥ì¹˜
- Facade ìœ ì§€: ê¸°ì¡´ APIëŠ” ì–‡ì€ ë˜í¼ë¡œ ë‚¨ê²¨ë‘ê³  ë‚´ë¶€ë§Œ ë°”ê¿”ì¹˜ê¸°. ì‹¤íŒ¨í•´ë„ ì™¸ë¶€ ì˜í–¥ ìµœì†Œí™”.
- Feature flag: cargo feature="behavior_pipeline"ë¡œ ìƒˆ/êµ¬ ë™ì‘ ì „í™˜.
- Contract Test ì„¸íŠ¸: ì˜ˆì „/ìƒˆ êµ¬í˜„ì— ê°™ì€ í…ŒìŠ¤íŠ¸ ë²¡í„°ë¥¼ ëŒë ¤ ë¹„êµ(ìŠ¤ëƒ…ìƒ· í…ŒìŠ¤íŠ¸ ì¶”ì²œ).
- Migration ë‹¨ê³„ ë¬¸ì„œ: public ë³€ê²½ì /ëŒ€ì²´ë²•/íê¸°ê¸°í•œì„ READMEì— ëª…ì‹œ.

## 6) ì»¤ë°‹ ì „ 10ë¬¸ ì²´í¬ë¦¬ìŠ¤íŠ¸

- íŠ¸ë ˆì´íŠ¸ ë©”ì„œë“œì— ìˆ˜ëª… íŒŒë¼ë¯¸í„°ê°€ ê¼­ í•„ìš”í•œê°€? (ëŒ€ë¶€ë¶„ ì•„ë‹ˆì–´ì•¼ í•¨)
- íŠ¸ë ˆì´íŠ¸ê°€ ê°ì²´ ì•ˆì „ì¸ê°€? (dynë¡œ ì“¸ ìˆ˜ ìˆëŠ”ê°€)
- ë¶€ìˆ˜íš¨ê³¼ëŠ” ì „ë¶€ Ctxë¡œë§Œ íë¥´ëŠ”ê°€?
- ì…ë ¥/ì¶œë ¥ì€ ê°’/ê²½ëŸ‰ ì†Œìœ ë¡œ ê°€ëŠ¥í•œê°€?
- ì œë„¤ë¦­ ì±„íƒ ì´ìœ ê°€ ì„±ëŠ¥ ê·¼ê±°ê°€ ìˆëŠ”ê°€?
- ì–´ëŒ‘í„°/íŒŒì´í”„ë¼ì¸ìœ¼ë¡œ êµ¬ì„±ì´ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•œê°€?
- ì‹¤íŒ¨/ë¡œê·¸/ë©”íŠ¸ë¦­ì´ Ctxì— ì¼ì›í™”ë˜ì–´ ìˆëŠ”ê°€?
- êµì²´ ê°€ëŠ¥ì„±(ì „ëµ ë³€ê²½) ì„ ê³ ë ¤í•´ íŠ¸ë ˆì´íŠ¸ê°€ ì¶©ë¶„íˆ ì‘ê³  ë‹¨ì¼ ì±…ì„ì¸ê°€?
- ì‘ì€ í•©ì„±ìœ¼ë¡œ í° í–‰ë™ì„ ë§Œë“¤ ìˆ˜ ìˆëŠ”ê°€?
- ê³„ì¸¡ í¬ì¸íŠ¸(ì‹œê°„/í• ë‹¹/ì¹´ìš´í„°)ê°€ ìˆëŠ”ê°€?

## 7) ë¯¸ë‹ˆ ì˜ˆì‹œ: ê³µê°„ ì¸ë±ìŠ¤(ë°ì´í„° ì¤‘ì‹¬ â†’ í–‰ìœ„ ì¤‘ì‹¬)

### ë°ì´í„° ì¤‘ì‹¬(OOPì‹)
```rust
struct Object { bbox: Aabb, kind: Kind /* ... */ }
fn insert(tree: &mut Tree, o: &Object) { /* kindë³„ ë¶„ê¸° */ }
```

### í–‰ìœ„ ì¤‘ì‹¬
```rust
trait Bounded { fn bbox(&self) -> Aabb; }
struct Spatial { items: Vec<Box<dyn Bounded>>; }
impl Spatial {
    fn insert(&mut self, b: impl Bounded + 'static) { self.items.push(Box::new(b)); }
    fn query(&self, q: Aabb) -> impl Iterator<Item=&dyn Bounded> {
        self.items.iter().map(|b| &**b).filter(move |b| b.bbox().intersects(q))
    }
}
```
- ìˆ˜ëª… ì—†ìŒ, íŠ¸ë ˆì´íŠ¸ ì–‡ìŒ, ì¡°ë¦½ ì‰¬ì›€.
- ë‚˜ì¤‘ì— ì„±ëŠ¥ í•„ìš” ì‹œ Spatial<T: Bounded>ë¡œ í™•ì¥.

## 8) ì—°ìŠµ ë£¨í‹´ (ì§§ê³  ì•ˆì „í•˜ê²Œ)
- ê¸°ì¡´ í•¨ìˆ˜ í•˜ë‚˜ë¥¼ trait + ctxë¡œ ì¶”ìƒí™”.
- â€œëŸ°íƒ€ì„â†’ì œë„¤ë¦­â€ ì „í™˜ ìŠ¤íŒŒì´í¬ë¥¼ ì†Œê·œëª¨(100ì¤„ ë¯¸ë§Œ)ë¡œ ì‹œë„.
- Contract í…ŒìŠ¤íŠ¸ë¡œ ì˜›/ìƒˆ êµ¬í˜„ì„ ë¹„êµ(ìŠ¤ëƒ…ìƒ·+ë²¤ì¹˜).
- â€œìƒíƒœ(ë°ì´í„°)ëŠ” Context í•œ êµ°ë°ì— ëª¨ìœ¼ê³ , ëª¨ë“  í–‰ìœ„ëŠ” &mut Contextë¥¼ í†µí•´ì„œë§Œ ì½ê³ /ì“´ë‹¤.â€

---


## 1) ê¸°ë³¸ í˜•íƒœ
```rust
// 1) ì¤‘ì‹¬ ì €ì¥ì†Œ
struct Ctx {
    meshes: Arena<Mesh>,    // ì†Œìœ  ë°ì´í„° ëª¨ìŒ
    log: Vec<String>,       // ë¶€ìˆ˜íš¨ê³¼/ë¡œê·¸
    // cache, rng, metrics, â€¦ í•„ìš” ê²ƒë“¤ ì—¬ê¸°ë¡œ
}

// 2) ìˆœìˆ˜ ì½ê¸° í–‰ìœ„
trait Query {
    type Output;
    fn eval(&self, ctx: &Ctx) -> Self::Output;
}

// 3) ìƒíƒœ ë³€ê²½ í–‰ìœ„
trait Op {
    type Error;
    fn run(&self, ctx: &mut Ctx) -> Result<(), Self::Error>;
}
```

- í•µì‹¬ì€ í–‰ìœ„ê°€ ì§ì ‘ ë‹¤ë¥¸ ê°ì²´ë¥¼ ë“¤ê³  ìˆì§€ ì•Šê³ , í•­ìƒ Ctxë¥¼ í†µí•´ ê°„ì ‘ ì ‘ê·¼í•œë‹¤ëŠ” ì ì…ë‹ˆë‹¤.

## 2) í•¸ë“¤(ID)ë¡œ ì°¸ì¡°í•˜ê³ , ì‹¤ì œ ë°ì´í„°ëŠ” Ctxê°€ ì†Œìœ 
```rust
#[derive(Copy, Clone)]
struct MeshId(u32);

struct TranslateMesh { id: MeshId, dx: f64, dy: f64, dz: f64 }

impl Op for TranslateMesh {
    type Error = &'static str;
    fn run(&self, ctx: &mut Ctx) -> Result<(), Self::Error> {
        let mesh = ctx.meshes.get_mut(self.id).ok_or("invalid id")?;
        mesh.translate(self.dx, self.dy, self.dz);
        ctx.log.push(format!("moved {:?}", self.id));
        Ok(())
    }
}
```
- íŠ¸ë ˆì´íŠ¸ì— ìˆ˜ëª…ì´ ì „í˜€ ì•ˆ ë³´ì´ì£ .

- ì°¸ì¡°ëŠ” ctx.meshes.get_mut(..)ì—ì„œ ì ê¹ë§Œ ë¹Œë ¤ ì“°ê³  ë.

## 3) íŒŒì´í”„ë¼ì¸(í–‰ìœ„ ì¡°ë¦½)ì€ ì´ëŸ° ì‹
```rust
type BoxOp = Box<dyn Op<Error = anyhow::Error>>;
struct Pipeline { steps: Vec<BoxOp> }
impl Pipeline {
    fn push(&mut self, op: impl Op<Error = anyhow::Error> + 'static) {
        self.steps.push(Box::new(op));
    }
    fn run(&self, ctx: &mut Ctx) -> anyhow::Result<()> {
        for step in &self.steps { step.run(ctx)?; }
        Ok(())
    }
}

```
- ì²˜ìŒì—” dynìœ¼ë¡œ ê°„ë‹¨íˆ(ì„¤ê³„ ìœ ì—°).
- ë‚˜ì¤‘ì— ë³‘ëª©ì´ ë³´ì´ë©´ ì¼ë¶€ë§Œ ì œë„¤ë¦­ë¡œ ë°”ê¿” monomorphization í•˜ë©´ ë©ë‹ˆë‹¤.

## 4) ì½ê¸° ì „ìš© ì§ˆì˜ëŠ” &Ctxë¡œ
```rust
struct MeshCount;
impl Query for MeshCount {
    type Output = usize;
    fn eval(&self, ctx: &Ctx) -> Self::Output {
        ctx.meshes.len()
    }
}
```
- ì½ê¸°ëŠ” &Ctx, ì“°ê¸°ëŠ” &mut Ctx â€” ë¶€ìˆ˜íš¨ê³¼ì˜ í†µë¡œë¥¼ 1ê°œ(Ctx)ë¡œ ê³ ì •í•˜ë©´ ì„¤ê³„ê°€ ê¹”ë”í•´ì§‘ë‹ˆë‹¤.

## 5) ì™œ ì´ íŒ¨í„´ì´ ì¢‹ì€ê°€ (ìš”ì•½)
- lifetime ê²©ë¦¬: íŠ¸ë ˆì´íŠ¸/êµ¬ì¡°ì²´ì— ìˆ˜ëª… íŒŒë¼ë¯¸í„°ê°€ ì•ˆ ë¶™ìŒ â†’ ì¡°ë¦½Â·êµì²´ê°€ ì‰¬ì›€.
- ì „ëµ êµì²´ ìš©ì´: dyn Op ëª©ë¡ë§Œ ë°”ê¿”ë„ ë™ì‘ ë³€ê²½ ê°€ëŠ¥.
- í…ŒìŠ¤íŠ¸Â·ë¦¬í”Œë ˆì´: Ctxì—ë§Œ ë”ë¯¸ ë°ì´í„° ë„£ê³ , ê°™ì€ Op/Query ë°˜ë³µ ì ìš© ê°€ëŠ¥.
- ì—ëŸ¬/ë¡œê·¸ ì¤‘ì•™í™”: ëª¨ë“  ë¶€ìˆ˜íš¨ê³¼ê°€ Ctxë¥¼ ê±°ì¹˜ë‹ˆ í•œ ê³³ì—ì„œ ì •ì±… ê´€ë¦¬.


