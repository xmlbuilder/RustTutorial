# 사고의 전환
객체 중심에서 행위 중심의 프로그래밍을 하려면 사고의 전환이 필요하다.

## 코드 변환 설명

### 1) 코드 전환

#### C++ 쪽 (이전)
- ON_Object 기반 상속  
    다양한 객체가 ON_Object*로 취급되고, 컨테이너(SpatialTree)는 “부모 타입 포인터”만 보면 됨.
- 데이터-주도  
    컨테이너는 “어떤 데이터가 들어왔는지”를 포인터로만 식별. AABB도 외부에서 계산해 넣어줌.
- 메모리/수명 관리 수동  
    풀( ON_FixedSizeMemMgr) + 단일 연결 리스트 노드로 관리. 해제 책임/순서/누수 주의.
- 식별(Identity) = 포인터 값  
    삭제/업데이트는 같은 포인터인지가 전부.

#### Rust 쪽 (지금)
- 상속 → 트레이트(행위/계약)  
    SpatialObject 트레이트(예: fn aabb(&self) -> BoundingBox)를 만족하는 타입이면 무엇이든 트리에 넣을 수 있음. “부모 클래스” 없이 행위 계약으로 연결.
- 행위-주도/조합  
    “이 타입이 AABB를 제공한다”는 **능력(capability)** 가 핵심. 컨테이너는 그 능력만 의존하고, 나머지는 타입이 자유롭게 구현.
- 소유/수명 안전  
    기본은 소유 값, 공유가 필요하면 Arc<T>로 안전 공유. 해제/라이프타임은 컴파일러가 보장.
- 식별 = Arc::ptr_eq  
    같은 데이터라도 새 Arc::new면 다른 개체. 컨테이너 API는 “넣을 때 받은 Arc 그대로”를 계속 쓰는 전제를 명확히 함.

- 자료구조 단순화  
    리스트 노드 풀 → Vec<Arc<T>>(캐시 친화/간단). 나중에 성능 이슈 생기면 풀/커스텀 할당기로 교체 가능(교체 지점 명확).

### 2) 왜 이렇게 바꿨나? (설계 의도)
- 의존성 역전  
    컨테이너가 구체 타입(ON_Object 계층)에 묶이지 않고 “AABB를 줄 수 있는 무언가(트레이트)”에만 의존 → 테스트 용이, 교체 용이.
- 조합이 상속보다 강력  
    필요한 행위(메서드)만 작게 요구 → 한 타입이 여러 역할을 쉽게 겸함. (예: AABB 제공 + RayHit 제공 트레이트를 각각 구현)
- 불변/소유로 경합 줄이기  
    Rust의 기본은 불변 공유. 업데이트/삭제 규칙이 명확해지고, 동시성 확장도 쉬워짐(필요하면 RwLock<...>로 감싸면 됨).
- 성능은 나중 최적화  
    먼저 명확성/안전/테스트성을 확보. 이후 병목이 보이면

### 3) 구체적 전략 (어떻게 바꿨나?)
#### 능력 중심 인터페이스
```rust
pub trait SpatialObject {
    fn aabb(&self) -> BoundingBox;
    // 필요해지면: fn ray_hit(&self, ray: Ray) -> Option<t>;
}
```
- 트리는 T: SpatialObject만 받음. = “넣을 수 있는 것”의 정의가 타입 계보가 아니라 가능한 행위가 됨.

#### 제네릭 컨테이너
```rust
pub struct SpatialTree<T: SpatialObject> { /* ... */ }
```
- 트리는 구체 타입을 몰라도 됨. 테스트·모킹이 쉬움(더미 타입으로 트리만 검증 가능).
- 명시적 식별자 유지  
    삽입 시 얻은 Arc<T>를 보관 → remove/update 시 Arc::ptr_eq로 동일 개체 판정.  
    (C++의 “우연히 같은 포인터” 의존을, Rust에 맞게 의도적인 동일성 규약으로 승격)
- 단순한 내부 표현  
    Vec<Arc<T>>로 시작 → 나중에 Vec<ObjectHandle>로 바꾸고 핸들은 풀/슬랩/세그리게이터로 바꿔도, 외부 API 안 흔들림.
- 도메인 규칙을 타입으로 표현
    “루트에 안 담기면 확장한다”는 정책을 expand_to_include()로 명시.
    “자식에 못 넣으면 부모에 남긴다(부모 보관)”도 함수로 이름화.  
    → 규칙이 “숨은 부수효과”가 아니라 “읽히는 정책”이 됨.  

### 4) 학습 포인트 (데이터 → 행위 전환의 핵심)
- 상속=재사용에서 행위=조합으로  
    상속은 확장 시 결합도가 커지고 테스트가 어려움. 트레이트는 필요한 기능만 요구 → 작은 인터페이스로 느슨한 결합.
- 포인터=정체성에서 소유/핸들=정체성으로  
    Rust는 소유권 모델 덕에 “누가 가진다”가 명확. 공유가 필요할 때만 Arc를 쓰고, 동일성은 의도적으로 ptr_eq로 판단.
- 메모리 풀=기능의 일부에서 옵션 최적화로  
    C++은 풀 없으면 누수나 성능 문제가 바로 드러나기 쉬워 “필수처럼” 붙지만, Rust는 기본이 안전/빠름.  
    → 풀/커스텀 할당기는 프로파일링 후 선택적으로 “교체 가능한 레이어”로 추가.
- 데이터-흐름을 행위-계약으로 환원  
    컨테이너는 “어떤 데이터냐”에 관심이 아니라 “무엇을 할 수 있냐(예: AABB 제공)”.  
    이 관점이 유지되면 “새 데이터 타입”이 와도 컨테이너 수정이 거의 필요 없음.  

### 5) 점진 이행 팁
- 어댑터 타입
    struct OnObjectAdapter<'a>(&'a ON_Object);가 SpatialObject를 구현해서 기존 ON_Object도 트리에 넣을 수 있게 가교를 만듦.  
    (C FFI로 넘어오는 포인터도 NonNull+수명/안전 래퍼로 감싸면 사용 가능)  
- 식별 유지  
    기존 엔진이 “id” 개념이 있다면 Arc<T> 대신 Arc<(Id, T)>로 싸서, 포인터 동일성 + 논리 id 둘 다 지원.
- 성능 단계적 반영  
    테스트·프로파일링 → 병목 지점에만 풀/SoA/맞춤 분할기를 주입. (API는 그대로, 내부만 교체)

## 요약:
상속·포인터·풀에 기대던 구조를 트레이트·제네릭·소유권으로 재편해 “역할 기반(행위 중심)” 설계로 옮김.  
이렇게 하면 유연성/테스트성/안전성이 올라가고, 성능 최적화도 필요한 부분만 정확히 넣을 수 있음.   
앞으로 레이 테스트, 충돌 리파인, 분할 휴리스틱 같은 “행위”들을 작은 트레이트로 추가해 나가면, 트리 자체는 손대지 않고 기능을 확장해 갈 수 있음.

---

## 사고의 전환 단계

### 0) 마음가짐 리셋 (룰 5개)
- “무엇이다(is-a)” 대신 **“무엇을 할 수 있다(can-do)”**를 먼저 생각한다 → 트레이트로 표현.
- 상위클래스 포인터 대신 제네릭 + 트레이트 바운드를 쓴다.
- 공용 소유는 기본 금지. 필요할 때만 Arc. 가급적 불변 공유를 기본으로.
- 식별은 포인터값이 아니라 **명시적 핸들(고유 id, Arc::ptr_eq)**로.

### 1) 데이터→행위 변환
#### 과제 A: “AABB를 제공할 수 있는 것”
- C++의 ON_Object* 대신:
```rust
pub trait HasAabb {
    fn aabb(&self) -> BoundingBox;
}
```
임의의 두 타입(예: Mesh, Sphere)에 HasAabb 구현.  
#### 제네릭 함수 하나 작성:
```rust
fn overlaps<T: HasAabb, U: HasAabb>(a: &T, b: &U) -> bool {
    a.aabb().intersects(&b.aabb())
}
```
##### 👉 느낌: 상속 없이 행위 계약만으로 조합이 된다.

### 2) 상속 치환 카타 (30분)
#### 과제 B: “기반 클래스 제거”

- C++의 class Drawable : public ON_Object 같은 걸 가정.
#### Rust에서:
```rust
pub trait Drawable {
    fn draw(&self, ctx: &mut RenderCtx);
}
```
- 서로 다른 타입 여러 개에 Drawable 구현.
```rust
fn render_all<T: Drawable>(xs: &[T], ctx: &mut RenderCtx) → 컴파일 불가 (트레이트 객체화 필요)
```

#### 고쳐 쓰기:
- 정적 디스패치: xs: &[impl Drawable] 또는 제네릭 슬라이스 여러 개
- 동적 디스패치: Vec<Box<dyn Drawable>> 사용
- 👉 포인트: 정적/동적 디스패치를 선택적으로 쓰는 감각 익히기.

### 3) 소유/공유/식별
#### 과제 C: “삭제/업데이트”
- SpatialTree<T: HasAabb>를 만들고 삽입/삭제/업데이트 구현.
- 삽입은 Arc<T>를 받고 내부 Vec<Arc<T>>에 저장.
- 삭제는 Arc::ptr_eq(a, b)로 동일성 판단.
- 업데이트는 기존 원소 제거 후 재삽입.
- 👉 느낌: 포인터값 말고 의도된 동일성 규약으로 관리.

### 4) 의존성 역전
#### 과제 D: “쿼리 엔진이 구체타입을 모르게”
```rust
trait IntersectsRay { fn hit(&self, ray: &Ray) -> Option<Hit>; }
```
- `SpatialTree<T: HasAabb + IntersectsRay>` 로 제약 확장.
- 트리는 T의 구현을 몰라도 행위만 호출.
- 👉 포인트: 기능이 늘어도 컨테이너는 변하지 않는다.

### 5) 어댑터 패턴
#### 과제 E: “기존 C++ 객체 감싸기”
- C FFI나 포인터를 struct OnObjectAdapter(*const ON_Object);
- unsafe 구간은 어댑터 내부로 가둬두고, 외부엔 HasAabb/IntersectsRay만 노출.
- 👉 포인트: 레거시를 어댑터로 흡수 → 새 설계 유지.

### 6) 상태/불변 전략
#### 과제 F: “카메라 컨트롤러”
- Camera는 내부 상태 보유(소유).
- 조작기는 “순수 함수 스타일”로:
```rust
pub trait CameraOp { fn apply(self, cam: Camera) -> Camera; }
```
- Orbit, Pan, Zoom를 각각 타입으로 정의하고 체인:
```rust
let cam = Orbit{...}.apply(cam);
let cam = Pan{...}.apply(cam);
```
- 또는 가변 레퍼런스로 일괄 적용:
```rust
pub trait CameraOpMut { fn apply_mut(&self, cam: &mut Camera); }
```
- 👉 포인트: 불변 체인 vs 가변 적용을 의식적으로 선택.

### 7) 오류/계약 카타 (20분)
#### 과제 G: “결과 타입”

- 기존 bool 리턴을 Result<T, E>로 바꾸기.
- FitFromBox 같은 건 Result<(), FitError>로 세분화.
- 상위에서 ?로 전파하고, 테스트에서 에러 분기 확인.
- 👉 포인트: 에러도 계약의 일부.
### 8) 테스트 루틴

#### 단위 테스트 3종:
- 행위 계약 테스트: 트레이트 구현 타입이 공통 케이스를 통과?
- 속성(property) 테스트(quickcheck/proptest): 예) union(aabb, aabb) ⊇ aabb
- 회귀 테스트: 버그 재현 → 테스트 고정
- 벤치(criterion) 하나: SpatialTree::query 성능 추적.
- 👉 포인트: “디자인 감각 = 테스트 습관”

### 9) 작은 리팩터 주기
- 정적 디스패치 ↔ 동적 디스패치 전환
- Vec<Arc<T>> ↔ SmallVec/슬래브 풀로 교체(내부만)
- 분할 휴리스틱 함수 분리 후 주입 가능하게:
```rust
pub trait Splitter { fn split(&self, bb: &BoundingBox) -> (BoundingBox, BoundingBox); }
```
- 👉 포인트: 확장점을 인터페이스로 외부화.

### 10) 체크리스트 (리뷰할 때마다 스스로 묻기)
- 이 타입이 “무엇을 할 수 있나(트레이트)”가 명확한가?
- 컨테이너가 구체 타입이 아니라 행위에만 의존하나?
- 공유가 정말 필요한가? Arc 없이 가능한가?
- 동일성은 명시적인가?(Arc::ptr_eq, id)
- 실패는 에러 타입으로 표현했나?
- 테스트가 설계를 설명해주나?

---

## 실전: 네 코드 베이스에서 바로 해볼 3가지

### SpatialTree 제네릭화
- SpatialTree<T: HasAabb> + Vec<Arc<T>> → 기존 ON_Object는 OnObjectAdapter로 넣기.
### RayQuery 분리
- IntersectsRay 트레이트 신설. 트리는 HasAabb만 알게 하고, 레이 정확도/충돌 세부는 외부 시스템이 맡게.

### Camera 조작자 분리
- CameraOp(…)/CameraOpMut 두 방식 실험. UI 이벤트 → 일급 연산자(타입)로 큐잉했다가 적용.

## 마지막 팁
- 처음엔 너무 일반화하지 말기. 트레이트는 “지금 필요한 최소 행위”만 구현.
- 작은 과제로 감각을 쌓자. 위 카타를 진짜 파일로 만들고 테스트를 돌려보기.
- 막힐 때는 “상속으로 풀면 어떻게 했을까?”를 먼저 떠올린 뒤, 그걸 **행위(트레이트)**로 바꿔보면 금방 감이 옴.

---


## 1) AABB 교차 판정
### 데이터 중심 (상태만 가진 타입 + 유틸 함수)
```rust
// 데이터만 있는 타입
struct Object {
    bbox: BoundingBox,
}

// 유틸리티 (데이터를 받아서 작업)
fn overlaps(a: &Object, b: &Object) -> bool {
    a.bbox.intersects(&b.bbox)
}

// 사용
let a = Object { bbox: bb1 };
let b = Object { bbox: bb2 };
let hit = overlaps(&a, &b);
```

### 행위 중심 (능력을 계약으로: HasAabb)
```rust
trait HasAabb {
    fn aabb(&self) -> &BoundingBox;
}

struct Mesh { bbox: BoundingBox }
struct Sphere { bbox: BoundingBox }

impl HasAabb for Mesh   { fn aabb(&self) -> &BoundingBox { &self.bbox } }
impl HasAabb for Sphere { fn aabb(&self) -> &BoundingBox { &self.bbox } }

// 제네릭 함수: 상속 없이 조합
fn overlaps<T: HasAabb, U: HasAabb>(a: &T, b: &U) -> bool {
    a.aabb().intersects(b.aabb())
}

// 사용
let hit = overlaps(&mesh, &sphere);
```

- 포인트: “무엇이다(상속)” 대신 “무엇을 할 수 있다(트레이트)”로 바꾸면 타입 조합이 자유로워짐.

## 2) 렌더(그리기)
### 데이터 중심 (태그 enum + 큰 match)
```rust
enum ShapeKind { Mesh, Sphere }
struct Shape {
    kind: ShapeKind,
    // 실제 데이터는 옵션/공유 포인터 등으로…
}

fn draw(shape: &Shape, ctx: &mut RenderCtx) {
    match shape.kind {
        ShapeKind::Mesh   => draw_mesh(shape, ctx),
        ShapeKind::Sphere => draw_sphere(shape, ctx),
    }
}
```

### 행위 중심 (동적 디스패치: dyn Drawable)
```rust
trait Drawable {
    fn draw(&self, ctx: &mut RenderCtx);
}

struct Mesh { /* … */ }
struct Sphere { /* … */ }

impl Drawable for Mesh   { fn draw(&self, ctx: &mut RenderCtx) { /*…*/ } }
impl Drawable for Sphere { fn draw(&self, ctx: &mut RenderCtx) { /*…*/ } }

// 서로 다른 타입을 한 컨테이너에
let mut list: Vec<Box<dyn Drawable>> = vec![
    Box::new(Mesh{/*…*/}),
    Box::new(Sphere{/*…*/})
];

for d in &list { d.draw(&mut ctx); }
```

- 포인트: 신규 도형 추가 시 match 수정 없이 타입만 추가 구현.

## 3) 공간 트리(간이)
### 데이터 중심 (오브젝트 전용 컨테이너)
```rust
struct Object { bbox: BoundingBox /*…*/ }

struct SpatialTree {
    nodes: Vec<Node>,
    objs:  Vec<Object>,
}

impl SpatialTree {
    fn insert(&mut self, o: Object) { /* bbox로만 처리 */ }
    fn query(&self, q: &BoundingBox) -> Vec<&Object> { /* … */ vec![] }
}
```

### 행위 중심 (제네릭 컨테이너 + 트레이트로 제약)
```rust
trait HasAabb { fn aabb(&self) -> &BoundingBox; }

struct SpatialTree<T: HasAabb> {
    nodes: Vec<Node>,
    objs:  Vec<std::sync::Arc<T>>,
}

impl<T: HasAabb> SpatialTree<T> {
    fn insert(&mut self, o: std::sync::Arc<T>) { /* o.aabb() 사용 */ }
    fn query<'a>(&'a self, q: &BoundingBox) -> Vec<&'a T> {
        self.objs.iter().filter_map(|a| {
            if a.aabb().intersects(q) { Some(a.as_ref()) } else { None }
        }).collect()
    }
}
```
- 포인트: 트리는 “박스를 제공할 수 있는 것”만 알면 됨. 메시/커브/라벨… 다 수용.

## 4) 카메라 조작
### 데이터 중심 (유틸 함수 모음)
```rust
struct Camera { eye: Point3, target: Point3, up: Vector3, /*…*/ }

fn pan(cam: &mut Camera, dx: f64, dy: f64)   { /* … */ }
fn orbit(cam: &mut Camera, yaw: f64, pitch: f64) { /* … */ }
fn zoom(cam: &mut Camera, factor: f64)       { /* … */ }
```

### 행위 중심 (연산을 1급 객체로, 합성 가능)
```rust
struct Camera { /* … */ }

trait CameraOpMut {
    fn apply(&self, cam: &mut Camera);
}

struct Pan { dx: f64, dy: f64 }
struct Orbit { yaw: f64, pitch: f64 }
struct Zoom { factor: f64 }

impl CameraOpMut for Pan   { fn apply(&self, cam: &mut Camera) { /*…*/ } }
impl CameraOpMut for Orbit { fn apply(&self, cam: &mut Camera) { /*…*/ } }
impl CameraOpMut for Zoom  { fn apply(&self, cam: &mut Camera) { /*…*/ } }

fn apply_all(cam: &mut Camera, ops: &[&dyn CameraOpMut]) {
    for op in ops { op.apply(cam); }
}

// 사용
apply_all(&mut cam, &[&Pan{dx:3.0, dy:1.0}, &Orbit{yaw:10.0, pitch:-5.0}, &Zoom{factor:0.9}]);
```
- 포인트: 이벤트를 “행위 객체”로 큐잉/리플레이/애니메이션에 바로 재사용 가능.

## 5) 레이 교차
### 데이터 중심 (종류별 큰 분기)
```rust
enum Prim { Triangle(Tri), Sphere(Sph) }

fn ray_hit(p: &Prim, ray: &Ray) -> Option<Hit> {
    match p {
        Prim::Triangle(t) => hit_tri(t, ray),
        Prim::Sphere(s)   => hit_sph(s, ray),
    }
}
```
### 행위 중심 (충돌 계약 분리)
```rust
trait IntersectsRay {
    fn hit(&self, ray: &Ray) -> Option<Hit>;
}

struct Triangle { /*…*/ }
struct Sphere   { /*…*/ }

impl IntersectsRay for Triangle { fn hit(&self, ray: &Ray) -> Option<Hit> { /*…*/ } }
impl IntersectsRay for Sphere   { fn hit(&self, ray: &Ray) -> Option<Hit> { /*…*/ } }

// 컨테이너는 행위만 의존
fn first_hit(xs: &[&dyn IntersectsRay], ray: &Ray) -> Option<Hit> {
    xs.iter().filter_map(|x| x.hit(ray)).min_by(|a,b| a.t.total_cmp(&b.t))
}
```

- 포인트: 새로운 프리미티브 추가 시 컨테이너/엔진 수정 없이 확장.

--- 

# 추가 팁

## 1) 이벤트 파이프라인
### (A) 데이터 중심: 거대한 match + 수동 파이프
```rust
// 이벤트와 컨텍스트(파이프 상태)
#[derive(Debug, Clone)]
enum Event { Key(char), Click { x: i32, y: i32 }, Quit }

#[derive(Default)]
struct PipelineCtx {
    log: Vec<String>,
    quit: bool,
}

// 단계별로 "데이터를 받아 작업"
fn log_stage(ev: &Event, ctx: &mut PipelineCtx) {
    ctx.log.push(format!("seen: {:?}", ev));
}

fn filter_stage(ev: &Event, ctx: &mut PipelineCtx) {
    if matches!(ev, Event::Key(' ')) {
        ctx.log.push("filtered space".into());
    }
}

fn handle_stage(ev: &Event, ctx: &mut PipelineCtx) {
    match ev {
        Event::Quit => ctx.quit = true,
        Event::Key(c) => ctx.log.push(format!("key={}", c)),
        Event::Click { x, y } => ctx.log.push(format!("click=({},{})", x, y)),
    }
}

fn run_pipeline(events: &[Event], ctx: &mut PipelineCtx) {
    for ev in events {
        // 수동으로 파이프 순서를 유지/호출
        log_stage(ev, ctx);
        filter_stage(ev, ctx);
        handle_stage(ev, ctx);
        if ctx.quit { break; }
    }
}

fn main() {
    let events = vec![Event::Key('a'), Event::Click { x: 3, y: 5 }, Event::Quit];
    let mut ctx = PipelineCtx::default();
    run_pipeline(&events, &mut ctx);
    println!("ctx={:?}", ctx.log);
}
```
### (B) 행위 중심: EventHandler 트레이트 + 체인(미들웨어)
```rust
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug, Clone)]
enum Event { Key(char), Click { x: i32, y: i32 }, Quit }

#[derive(Default, Debug)]
struct PipelineCtx { log: Vec<String>, quit: bool }

trait EventHandler {
    fn handle(&self, ev: &Event, ctx: &mut PipelineCtx);
}

struct Logger;
impl EventHandler for Logger {
    fn handle(&self, ev: &Event, ctx: &mut PipelineCtx) {
        ctx.log.push(format!("seen: {:?}", ev));
    }
}

struct SpaceFilter;
impl EventHandler for SpaceFilter {
    fn handle(&self, ev: &Event, ctx: &mut PipelineCtx) {
        if matches!(ev, Event::Key(' ')) {
            ctx.log.push("filtered space".into());
        }
    }
}

struct Core;
impl EventHandler for Core {
    fn handle(&self, ev: &Event, ctx: &mut PipelineCtx) {
        match ev {
            Event::Quit => ctx.quit = true,
            Event::Key(c) => ctx.log.push(format!("key={}", c)),
            Event::Click { x, y } => ctx.log.push(format!("click=({},{})", x, y)),
        }
    }
}

// 파이프라인: 핸들러들을 조합(순서만 바꾸면 정책 교체)
struct Pipeline {
    stages: Vec<Rc<dyn EventHandler>>,
}
impl Pipeline {
    fn new(stages: Vec<Rc<dyn EventHandler>>) -> Self { Self { stages } }
    fn run(&self, events: &[Event], ctx: &mut PipelineCtx) {
        'outer: for ev in events {
            for st in &self.stages {
                st.handle(ev, ctx);
                if ctx.quit { break 'outer; }
            }
        }
    }
}

fn main() {
    let pipe = Pipeline::new(vec![
        Rc::new(Logger),
        Rc::new(SpaceFilter),
        Rc::new(Core),
    ]);
    let events = vec![Event::Key('a'), Event::Click { x: 3, y: 5 }, Event::Quit];
    let mut ctx = PipelineCtx::default();
    pipe.run(&events, &mut ctx);
    println!("ctx={:?}", ctx);
}
```
### 핵심 차이
- 데이터 중심: “함수 + 큰 match” 에 이벤트를 계속 가져다 넣음(결합↑).
- 행위 중심: “핸들러의 능력” 을 조합해서 파이프를 구성(확장/재배치가 쉬움).

## 2) 뷰–모델 바인딩
### (A) 데이터 중심: 모델 변경 후 수동으로 뷰 갱신 호출
```rust
#[derive(Default, Debug, Clone)]
struct Model { count: i32 }

#[derive(Default)]
struct View { last_text: String }
impl View {
    fn render(&mut self, m: &Model) {
        self.last_text = format!("count = {}", m.count);
        println!("render: {}", self.last_text);
    }
}

// 컨트롤러가 "모델 수정 → 뷰 렌더"를 매번 수동 호출
fn main() {
    let mut model = Model::default();
    let mut view  = View::default();

    model.count += 1;
    view.render(&model);

    model.count += 10;
    view.render(&model);
}
```
### (B) 행위 중심: Observable 시그널 + Observer로 자동 바인딩
```rust
use std::rc::Rc;
use std::cell::RefCell;

// 아주 얇은 Observable (값 변경시 구독자에게 통지)
struct Signal<T> {
    value: RefCell<T>,
    subs: RefCell<Vec<Box<dyn Fn(&T)>>>,
}
impl<T: Clone> Signal<T> {
    fn new(v: T) -> Self { Self { value: RefCell::new(v), subs: RefCell::new(vec![]) } }
    fn get(&self) -> T { self.value.borrow().clone() }
    fn set(&self, v: T) {
        *self.value.borrow_mut() = v;
        for f in self.subs.borrow().iter() { f(&self.value.borrow()); }
    }
    fn subscribe<F: Fn(&T) + 'static>(&self, f: F) {
        self.subs.borrow_mut().push(Box::new(f));
    }
}

// 모델은 "시그널"로 노출
#[derive(Clone)]
struct Model {
    count: Rc<Signal<i32>>,
}
impl Model {
    fn new() -> Self { Self { count: Rc::new(Signal::new(0)) } }
}

// 뷰는 모델의 시그널을 구독하고, 변경되면 자동 렌더
struct View {
    last_text: String,
}
impl View {
    fn new(m: &Model) -> Self {
        let mut me = Self { last_text: String::new() };
        let text_ref = Rc::new(RefCell::new(String::new()));
        // 구독: 모델 count가 바뀌면 렌더 호출
        {
            let text_ref = text_ref.clone();
            m.count.subscribe(move |v| {
                *text_ref.borrow_mut() = format!("count = {}", v);
                println!("render: {}", text_ref.borrow());
            });
        }
        me
    }
}

fn main() {
    let model = Model::new();
    let _view  = View::new(&model); // 구독 시작

    model.count.set(1);    // 자동 렌더
    model.count.set(11);   // 자동 렌더
}
```

### 핵심 차이
- 데이터 중심: 모델을 바꾼 뒤 항상 수동으로 view.render()를 호출해야 함(누락 위험).
- 행위 중심: “모델이 값 변경 행위를 발행 → 구독한 뷰가 반응”으로 자동화(결합↓, 재사용↑).

## 왜 “행위 중심”인가
- 데이터 모델(명사)보다 능력/역할(동사) 을 1급 시민으로 다룸.
- “어떤 타입인가?”보다 **“무엇을 할 수 있는가?”**가 API 표면이 됨.
- 구성(Composition) + 트레이트(Interface) 로 시스템을 재배열하기 쉬움.
- 런타임에 정책/전략 교체(파이프라인, 미들웨어, 플러그인)가 쉬움.


----

## 사고 체인지를 위한 4문장

- 먼저 동사를 뽑는다: Log/Filter/Handle, Render/Validate/Apply, Load/Cache/Fetch …
- 동사마다 트레이트로 표준화: trait Logger { fn log(&self, …) }
- 트레이트 구현물을 조합해서 파이프/파사드 구성.
- 상태는 컨텍스트 하나로 모아서 &mut ctx로 흘린다. (부수효과는 모두 여기로)

## OOP → 행위 중심 “매핑표” (Rust 관점)
- 상속 트리 → trait 집합 + 구성체(필드로 전략 보관)
- 가상 함수 오버라이드 → dyn Trait(런타임) / 제네릭 T: Trait(컴파일타임)
- 공통 상위 클래스(ON_Object) → “빈 베이스” 제거, 능력 트레이트로 분해  
    예: trait Bounded { fn bbox(&self) -> BoundingBox; }
- 거대 매치/스위치 → 트레이트 폴리몰피즘으로 분산
- 옵저버/신호 → 경량 이벤트 버스 or Signal/subscribe(이전 예제)
- 싱글톤 → 컨텍스트 주입(명시적으로 &mut Ctx 전달)

## 리팩터링 체크리스트 (작게·빠르게)
- 동사 목록화  
    파일/모듈을 훑어 “기능 이름(동사)”만 빼서 적기. (로깅, 검증, 직렬화, 픽킹, 카메라 조작…)
- 트레이트 선언 (이름=동사)
- 메서드는 협업에 필요한 최소 인자만: fn handle(&self, ev: &Event, ctx: &mut Ctx)  
    가능하면 불변 self (&self), 부수효과는 ctx.

## 컨텍스트 설계
- 변경 상태, 캐시, 통계, 출력 버퍼 등 모든 사이드 이펙트를 Ctx에.
- IO/리소스 핸들(동기/비동기), 시간, 랜덤 씨드도 여기로.

## 파이프/조립 코드 만들기
- Vec<Rc<dyn Trait>> or 제네릭 Pipeline<T: Trait>.
- 순서·교체·조건 분기를 조립부로 빼기(핸들러는 순수).

## 거대 타입 분해
- 데이터 구조는 순수 데이터만 남기고, 행위는 외부 트레이트로.  
    예: BoundingBox는 계산/조합 로직만, 삽입/검색은 SpatialIndex 트레이트로.

## 테스트 고정
- 각 동사 트레이트에 표준 시나리오 테스트(입력→ctx 변화).
- 조합(Pipeline/ECS)에선 구성 순서가 결과에 미치는 영향 테스트.

## 안티패턴 빨간불
- “Base 클래스로 다 때려넣기”: 공통 데이터 + 공통 동작을 한 곳에 몰지 말 것.
- “거대한 enum + match 500줄”: 기능이 늘수록 수정 반경 폭증.
- “여기저기서 상태 수정”: ctx 외부에서 사이드 이펙트 발생 금지.
- “트레이트에 상태를 쌓음”: 재사용/동시성에 불리. 상태는 가능한 ctx.

## 작은 리팩터링 예(공간 트리)
### (Before) 데이터 중심
```rust
struct ObjectNode { bbox: BoundingBox, ty: ObjectKind, /* … */ }
// 거대한 match 로 타입별 교차/삽입/삭제 처리
fn insert(tree: &mut Tree, obj: &ObjectNode) { /* match obj.ty { … } */ }
```
### (After) 행위 중심
```rust
trait Bounded { fn bbox(&self) -> BoundingBox; }
trait HitTest { fn hits(&self, ray: &Ray) -> bool; }

struct SpatialTree {
    items: Vec<Box<dyn Bounded>>,    // or dyn (Bounded + HitTest) if needed
}

impl SpatialTree {
    fn insert(&mut self, b: Box<dyn Bounded>) { self.items.push(b); }
    fn query_box(&self, q: &BoundingBox) -> Vec<&dyn Bounded> {
        self.items.iter().map(|b| &**b)
            .filter(|b| b.bbox().intersects(q)).collect()
    }
}
```

---

# “무엇(데이터)인가?”에서 “무엇을 할 줄 아는가(트레이트)?”로 이동.

## 실전 연습 루트 (2주 분량 스스로 학습 플랜)
### Day 1–2
- 기존 모듈 1개 골라 동사 뽑기 → 트레이트 선언 → ctx 설계만 해보기(코드 미이동).
- 컴파일 안 해도 좋으니 인터페이스 스케치 우선.
### Day 3–4
- 200~400줄짜리 기능을 파이프라인화(로깅·검증·핸들 순으로 3단).
### Day 5–7
- 뷰–모델 한 군데에 시그널/구독 삽입(수동 호출 제거).
- 회귀 테스트로 렌더 호출 누락이 사라졌는지 확인.

### Week 2
- 공간 트리/픽킹/카메라 중 하나를 트레이트 단위로 분할하고 벤치.
- “구성 교체” 시나리오(예: 여러 필터/로거 조합)로 유연성 체감.

## 문서화 템플릿(팀 공유용)
- 목표: “X 모듈을 행위 중심으로 전환하여 ___을 가능하게 한다.”
- 동사 목록: Log, Filter, Handle, Render, Validate…
- 트레이트 사양
```rust
trait Xxx { fn op(&self, input: &A, ctx: &mut Ctx) -> Result<B>; }
```
- 입력/출력/부수효과(어떤 필드를 바꾸는가)를 글머리표로.
- 컨텍스트 정의: 필드, 스레딩, 오류 정책.
- 조립 예: 기본/디버그/테스트 파이프라인 3종.
- 마이그레이션: 바뀐 public API, 삭제된 코드, 대체 지침.

## 테스트: 단위/통합/성능 기준.

## 마지막 팁

- 처음부터 “전부 바꾸기”보다 경계(Adaptor) 를 만들어 섬→대륙 순으로 넓히세요.
- “성능 걱정”은 인터페이스가 안정된 후에. 제네릭로 바꿔 인라이닝하면 대부분 해결.
- 트레이트는 “추상화”가 아니라 조립점입니다. 작고 한정된 동사로 쪼개는 게 핵심.

---


## 1) 수렁을 피하는 대원칙 7

- 동사만 먼저, 타입/라이프타임은 나중
- 시그니처를 일단 “값 중심”으로 쓰세요. 참조는 최대한 미루고, 가능하면 Clone + Cow/Arc로 시작합니다.
- 모든 부수효과는 Ctx 하나로 트레이트는 &self(불변) + &mut Ctx만 받게 하면 lifetime 전파가 거의 없습니다.
```rust
trait Step { fn run(&self, input: &Input, ctx: &mut Ctx) -> Result<Output>; }
```

### Trait Object(런타임 다형)부터 시작
- 제네릭로 시작하면 lifetime/타입 전파가 폭발해요. 초판은:
```rust
type BoxStep = Box<dyn Step>; // or Rc<dyn Step>
struct Pipeline { steps: Vec<BoxStep> }
```
- 성능 병목이 보일 때만 제네릭로 올립니다.

### ID/핸들 패턴 (Arena/ECS식)
- 구조체 참조를 트레이트에 넣지 말고, ID로 참조하고 실제 데이터는 Ctx/아레나가 소유:
```rust
struct MeshId(u32);
struct Ctx { meshes: Arena<Mesh>, /* ... */ }
trait Op { fn apply(&self, id: MeshId, ctx: &mut Ctx); } // ← 수명 프리
```

### 객체 안전(Object-safe) 규칙을 지켜라
- 트레이트 오브젝트로 쓸 거면: 제네릭 메서드/Self: Sized/연관 상수 남발 금지.
- 필요하면 “두 개의 트레이트”로 나눠서, 바깥은 오브젝트-세이프, 안쪽은 제네릭로.
- 콜백은 HRTB로 받기 (수명 오염 방지)
```rust
fn visit<F>(&self, f: F) where for<'a> F: FnMut(&'a Node) { /* ... */ }
```
- 이렇게 하면 호출자 수명이 구현으로 새어들지 않아요.
- 초기에는 ‘소유’를 두껍게 &[T]보다 Arc<[T]> / Cow<'_, T> / SmallVec 등을 써서 설계 확정 전까지 수명 의존을 줄입니다.

## 2) 나쁜/좋은 트레이트 시그니처 비교 (수명 폭탄 방지)
### ❌ 나쁨: 수명을 외부로 새게 만듦
```rust
trait Intersect<'a> {
    fn hit(&'a self, a: &'a Mesh, b: &'a Mesh) -> bool; // 'a가 전체를 지배
}
```

### ✅ 좋음: 컨텍스트에 소유/캐시 모음, 트레이트는 얇게
```rust
struct Ctx<'s> { meshes: &'s Arena<Mesh>, scratch: Scratch, /* ... */ }
trait Intersect {
    fn hit(&self, a: MeshId, b: MeshId, ctx: &mut Ctx) -> bool;
}
```
- 외부 수명이 트레이트 시그니처에 등장하지 않으니 트레이트는 ‘수명 중립’.
- 실제 참조는 ctx.meshes.get(a) 안에서만 잠깐 빌려 씀.

## 3) “초판은 런타임, 병목만 제네릭” 단계적 업그레이드
### 1단계: 빠른 조립 (런타임 다형)
```rust
trait Step { fn run(&self, input: &Input, ctx: &mut Ctx) -> Output; }
struct Pipeline { steps: Vec<Box<dyn Step>>; }
```
### 2단계: 성능 민감 구간만 제네릭로
```rust
trait StepImpl { fn run_impl(&self, input: &Input, ctx: &mut Ctx) -> Output; }
struct Pipeline<T: StepImpl> { steps: Vec<T> } // 핵심 루프만 monomorphization
```
### 3단계: 하이브리드
- 상위 조립은 dyn Step, 내부 뜨거운 루프는 T: Kernel로 분리.

## 4) 수명 줄이는 6가지 패턴 (코드 조각)

### (a) 입력은 값/경량복사
```rust
#[derive(Clone)]
struct Command { name: Arc<str>, args: Arc<[u8]> }
trait Handle { fn handle(&self, cmd: Command, ctx: &mut Ctx); }
```

### (b) GAT로 이터레이터/뷰 노출 (필요할 때만)
```rust
trait Scene {
    type Iter<'a>: Iterator<Item = &'a Node> where Self: 'a;
    fn nodes(&self) -> Self::Iter<'_>;
}
```

### (c) 빌더로 ‘구성’과 ‘수행’ 분리
```rust
struct PipelineBuilder { steps: Vec<Box<dyn Step>> }
impl PipelineBuilder {
    fn add(mut self, s: impl Step + 'static) -> Self { self.steps.push(Box::new(s)); self }
    fn build(self) -> Pipeline { Pipeline { steps: self.steps } }
}
```

### (d) 에러 정책은 enum으로 중앙집중
```rust
enum Policy { Strict, BestEffort }
struct Ctx { policy: Policy, errors: Vec<anyhow::Error> }
```

### (e) 스케줄/이벤트 파이프는 ‘데이터→행위’ 분리
```rust
enum Event { Mouse{..}, Key{..} }
trait Listener { fn on(&self, ev: &Event, ctx: &mut Ctx); }
```

### (f) 어댑터/새장(Sealed)로 외부 확장 제어
```rust
mod sealed { pub trait Sealed {} }
pub trait Bounded: sealed::Sealed { fn bbox(&self) -> Aabb; }
```

## 5) “되돌리기 쉬운” 안전장치
- Facade 유지: 기존 API는 얇은 래퍼로 남겨두고 내부만 바꿔치기. 실패해도 외부 영향 최소화.
- Feature flag: cargo feature="behavior_pipeline"로 새/구 동작 전환.
- Contract Test 세트: 예전/새 구현에 같은 테스트 벡터를 돌려 비교(스냅샷 테스트 추천).
- Migration 단계 문서: public 변경점/대체법/폐기기한을 README에 명시.

## 6) 커밋 전 10문 체크리스트

- 트레이트 메서드에 수명 파라미터가 꼭 필요한가? (대부분 아니어야 함)
- 트레이트가 객체 안전인가? (dyn로 쓸 수 있는가)
- 부수효과는 전부 Ctx로만 흐르는가?
- 입력/출력은 값/경량 소유로 가능한가?
- 제네릭 채택 이유가 성능 근거가 있는가?
- 어댑터/파이프라인으로 구성이 테스트 가능한가?
- 실패/로그/메트릭이 Ctx에 일원화되어 있는가?
- 교체 가능성(전략 변경) 을 고려해 트레이트가 충분히 작고 단일 책임인가?
- 작은 합성으로 큰 행동을 만들 수 있는가?
- 계측 포인트(시간/할당/카운터)가 있는가?

## 7) 미니 예시: 공간 인덱스(데이터 중심 → 행위 중심)

### 데이터 중심(OOP식)
```rust
struct Object { bbox: Aabb, kind: Kind /* ... */ }
fn insert(tree: &mut Tree, o: &Object) { /* kind별 분기 */ }
```

### 행위 중심
```rust
trait Bounded { fn bbox(&self) -> Aabb; }
struct Spatial { items: Vec<Box<dyn Bounded>>; }
impl Spatial {
    fn insert(&mut self, b: impl Bounded + 'static) { self.items.push(Box::new(b)); }
    fn query(&self, q: Aabb) -> impl Iterator<Item=&dyn Bounded> {
        self.items.iter().map(|b| &**b).filter(move |b| b.bbox().intersects(q))
    }
}
```
- 수명 없음, 트레이트 얇음, 조립 쉬움.
- 나중에 성능 필요 시 Spatial<T: Bounded>로 확장.

## 8) 연습 루틴 (짧고 안전하게)
- 기존 함수 하나를 trait + ctx로 추상화.
- “런타임→제네릭” 전환 스파이크를 소규모(100줄 미만)로 시도.
- Contract 테스트로 옛/새 구현을 비교(스냅샷+벤치).
- “상태(데이터)는 Context 한 군데에 모으고, 모든 행위는 &mut Context를 통해서만 읽고/쓴다.”

---


## 1) 기본 형태
```rust
// 1) 중심 저장소
struct Ctx {
    meshes: Arena<Mesh>,    // 소유 데이터 모음
    log: Vec<String>,       // 부수효과/로그
    // cache, rng, metrics, … 필요 것들 여기로
}

// 2) 순수 읽기 행위
trait Query {
    type Output;
    fn eval(&self, ctx: &Ctx) -> Self::Output;
}

// 3) 상태 변경 행위
trait Op {
    type Error;
    fn run(&self, ctx: &mut Ctx) -> Result<(), Self::Error>;
}
```

- 핵심은 행위가 직접 다른 객체를 들고 있지 않고, 항상 Ctx를 통해 간접 접근한다는 점입니다.

## 2) 핸들(ID)로 참조하고, 실제 데이터는 Ctx가 소유
```rust
#[derive(Copy, Clone)]
struct MeshId(u32);

struct TranslateMesh { id: MeshId, dx: f64, dy: f64, dz: f64 }

impl Op for TranslateMesh {
    type Error = &'static str;
    fn run(&self, ctx: &mut Ctx) -> Result<(), Self::Error> {
        let mesh = ctx.meshes.get_mut(self.id).ok_or("invalid id")?;
        mesh.translate(self.dx, self.dy, self.dz);
        ctx.log.push(format!("moved {:?}", self.id));
        Ok(())
    }
}
```
- 트레이트에 수명이 전혀 안 보이죠.

- 참조는 ctx.meshes.get_mut(..)에서 잠깐만 빌려 쓰고 끝.

## 3) 파이프라인(행위 조립)은 이런 식
```rust
type BoxOp = Box<dyn Op<Error = anyhow::Error>>;
struct Pipeline { steps: Vec<BoxOp> }
impl Pipeline {
    fn push(&mut self, op: impl Op<Error = anyhow::Error> + 'static) {
        self.steps.push(Box::new(op));
    }
    fn run(&self, ctx: &mut Ctx) -> anyhow::Result<()> {
        for step in &self.steps { step.run(ctx)?; }
        Ok(())
    }
}

```
- 처음엔 dyn으로 간단히(설계 유연).
- 나중에 병목이 보이면 일부만 제네릭로 바꿔 monomorphization 하면 됩니다.

## 4) 읽기 전용 질의는 &Ctx로
```rust
struct MeshCount;
impl Query for MeshCount {
    type Output = usize;
    fn eval(&self, ctx: &Ctx) -> Self::Output {
        ctx.meshes.len()
    }
}
```
- 읽기는 &Ctx, 쓰기는 &mut Ctx — 부수효과의 통로를 1개(Ctx)로 고정하면 설계가 깔끔해집니다.

## 5) 왜 이 패턴이 좋은가 (요약)
- lifetime 격리: 트레이트/구조체에 수명 파라미터가 안 붙음 → 조립·교체가 쉬움.
- 전략 교체 용이: dyn Op 목록만 바꿔도 동작 변경 가능.
- 테스트·리플레이: Ctx에만 더미 데이터 넣고, 같은 Op/Query 반복 적용 가능.
- 에러/로그 중앙화: 모든 부수효과가 Ctx를 거치니 한 곳에서 정책 관리.


