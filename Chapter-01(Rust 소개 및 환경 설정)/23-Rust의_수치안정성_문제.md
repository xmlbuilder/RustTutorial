# 수치 안정성(Numerical Robustness)과 언어별 차이

## 1. 개요
수치 안정성(Numerical Robustness)은 CAD, 시뮬레이션, FEM, 기하 알고리즘 등에서 연산의 정확성과 일관성을 유지하기 위한 핵심 요소입니다.  
동일한 알고리즘이라도 **언어별로(특히 C#, C++, Rust)** 부동소수점 연산 처리, 최적화, NaN/Inf 전파 방식이 다르기 때문에 결과가 달라질 수 있습니다.

이 문서는 C#, C++, Rust의 수치 연산 특성을 비교하고, Rust로 포팅할 때 왜 동일한 코드가 더 많은 오류를 유발하는지를 설명합니다.  
결론을 말하자면 더 수렴시키기가 어렵씁니다.  
C#, C++에서 잘 돌아가던 알고리즘에 돌지 않는 경우가 많습니다.


---

## 2. 언어별 수치 연산 특성 비교

| 항목 | C# | C++ | Rust |
|------|----|-----|------|
| **부동소수점 표준** | IEEE 754 준수 (JIT 기반) | IEEE 754 준수 (컴파일러별 약간 차이) | IEEE 754 완전 준수 (strict FP) |
| **NaN 전파** | 비교적 관대 (예: `NaN == NaN` → false지만 연산 유지) | 컴파일러 최적화에 따라 무시되기도 함 | 항상 전파, 최적화 불허 |
| **정규화(denormal) 처리** | 일부 런타임에서 자동 flush-to-zero(FTZ) | 옵션에 따라 flush 가능 | flush 없음 (엄격하게 유지) |
| **오차 누적 허용도** | 높음 — double 기본 | 보통 double (컴파일러가 최적화 시 재배열 가능) | 낮음 — 표현식 평가 순서 고정 |
| **경계 처리(clamp)** | 일부 API 자동 clamp | 대부분 수동 처리 필요 | 수동 처리 필수 (안 하면 panic 또는 NaN) |
| **디버그/릴리즈 차이** | JIT 최적화로 동작이 일관됨 | 릴리즈에서 수학식 재배열 가능 | 디버그/릴리즈 동일한 결과 보장 |

- 요약하자면:  
> Rust는 **수학적으로 가장 엄격한 언어**이고, C#은 **가장 관대한 언어**, C++은 **그 중간**입니다.

---

## 3. Rust에서 더 많은 실패가 발생하는 이유

C#/C++에서 잘 작동하던 수학 코드가 Rust로 오면 깨지는 이유는 다음과 같습니다:

### 1. **Rust는 표현식 평가 순서가 고정되어 있고, 최적화로 인한 오차 보정이 없습니다.**  
   → C++은 `a + b + c`를 `(a + c) + b`로 바꿔 계산할 수 있지만, Rust는 절대 순서를 바꾸지 않습니다.

### 2. **Rust는 denormal/underflow 값도 그대로 전파합니다.**  
   → C#은 자동으로 `0`으로 flush하지만, Rust는 `1e-308` 같은 미세한 값도 유지합니다.

### 3. **Rust는 NaN/Inf 처리에 엄격합니다.**  
   → NaN 비교는 항상 false, Inf는 그대로 propagate 됩니다.  
   → C++에서는 최적화 중 NaN 체크가 무시되기도 합니다.

### 4. **경계 처리(clamp, snap)가 자동이 아닙니다.**  
   → `u = clamp(u, umin, umax)` 를 개발자가 직접 넣지 않으면 그대로 out-of-range 발생.

### 5. **정규화(normalize) 실패에 대한 관용이 없습니다.**  
   → 0벡터를 normalize하면 바로 NaN 발생. (C++/C#은 대체로 0으로 처리)

---

## 4. 해결 전략: 엄격한 코어 + 관용 정책층

Rust에서는 수치 안정성을 위해 다음과 같은 구조를 추천합니다.

### ① 엄격한 코어 (Strict Core)
- IEEE 754 규칙 그대로 계산.
- `basis_funs`, `find_span`, `eval_point` 등 핵심 수학 루틴.
- 여기서는 예외나 오차를 **숨기지 않는다**.

### ② 관용 정책층 (Robust Policy Layer)
- `safe_normalize`, `snap_param_inside`, `rel_abs_tol` 등의 유틸 함수.
- 경계, NaN, 0길이, 매듭, Newton 실패 등 모든 예외를 관용적으로 처리.
- 개발자가 더 개발 할 때 주의가 필요합니다.

### ③ 도메인 계층 (Domain Layer)
- `closest_point_to`, `project`, `intersect` 등 실제 CAD 연산.
- 항상 정책층의 유틸을 거쳐 코어 함수를 호출.

- 이렇게 나누면,
> Rust의 엄격함은 유지하면서도, 공학적 관용을 개발자가 직접 통제할 수 있습니다.

---

## 5. 수치 안정성 가이드라인 요약

| 구분 | 내용 | Rust 권장 처리 |
|------|------|----------------|
| `매듭 경계 처리` | `[knot[p], knot[n+1])` 반폐구간 | `snap_param_inside` 로 내부 조정 |
| `정규화 실패` | 0벡터 등 | `safe_normalize` 로 길이 확인 후 수행 |
| `선형성 판정` | 절대 tol → 상대 tol | `tol * |v|` 형태로 수정 |
| `평면성 판정` | 절대 오차 비교 금지 | `|dot(p - p0, n)| <= tol * |n|` |
| `뉴턴 반복` | 발산, out-of-range | clamp + iteration limit + re-seed |
| `denormal 처리` | 너무 작은 값 | flush-to-zero 정책 적용 |
| `테스트 tolerance` | 절대 tol 고정 금지 | `tol = max(rel * scale, abs)` |

---

## 6. 결론

C#과 C++은 **컴파일러와 런타임이 수치적 관용을 제공**하지만, Rust는 **그런 여지를 남기지 않습니다.**

이는 단기적으로 테스트 실패를 늘리지만, 장기적으로 보면 **신뢰성과 재현성, 수학적 정확성**을 보장합니다.

> **Rust는 “개발자가 관용을 설계해야 하는 언어”입니다.**  
> 즉, **컴파일러가 숨겨주던 모든 수치적 불안정성을 드러내 주는 언어** 이기도 합니다.

따라서 CAD/FEM/Geometry 엔진을 Rust로 옮길 때는 다음을 목표로 해야 합니다:
- 핵심 코어는 **엄격하게**,
- 주변 정책은 **의식적으로 관용적으로**,
- 결과적으로 **모든 계산이 예측 가능한 범위 내**에서 수행되도록 만드는 것.

---


