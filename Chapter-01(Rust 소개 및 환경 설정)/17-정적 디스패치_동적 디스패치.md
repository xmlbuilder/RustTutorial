# 정적 디스패치 / 동적 디스패치

Rust에서의 정적 디스패치 vs 동적 디스패치는 성능과 유연성 사이의 선택.  
아래에 개념, 예시, 장단점, 적용 가능 / 불가능한 상황까지 자세하게 정리.  

## 🧠 개념 요약
| 디스패치 방식     | 설명                                 |
|------------------|--------------------------------------|
| `impl Trait`      | 정적 디스패치: 컴파일 시점에 타입 결정 |
| `dyn Trait` + `Box`/`Rc` | 동적 디스패치: 런타임에 타입 결정     |


## ✅ 정적 디스패치
### 예시
```rust
fn draw_all(xs: &[impl Drawable]) {
    for x in xs {
        x.draw();
    }
}
```

### 또는
```rust
fn draw_all<T: Drawable>(xs: &[T]) {
    for x in xs {
        x.draw();
    }
}

```

### 특징
- 컴파일 시점에 타입이 확정됨
- 모노모픽: 제네릭이 실제 타입으로 치환되어 컴파일됨
- 인라인 최적화 가능
### 장점
- 성능이 뛰어남 (함수 호출이 인라인될 수 있음)
- 타입 안정성 높음
- 제네릭 기반으로 코드 재사용 가능
## 단점
- 슬라이스에 여러 타입을 혼합해서 넣을 수 없음
- 모든 타입이 동일해야 함 ([T, T, T])

## ✅ 동적 디스패치
## 예시
```rust
fn draw_all(xs: Vec<Box<dyn Drawable>>) {
    for x in xs {
        x.draw();
    }
}
```

### 특징
- 런타임에 타입 결정
- dyn Trait은 vtable 기반 호출
- 여러 타입을 동일한 Trait 객체로 추상화 가능
### 장점
- 서로 다른 타입을 같은 Trait로 묶어서 처리 가능
- 유연한 구조 설계 가능 (ECS, UI 위젯 등)
### 단점
- 성능 손해 (vtable lookup, heap allocation)
- 타입 정보가 런타임에만 존재 → 컴파일러 최적화 어려움

## 🧩 적용 가능/불가능한 상황
| 상황                              | 정적 디스패치 (`impl Trait`) | 동적 디스패치 (`dyn Trait`) |
|-----------------------------------|-------------------------------|------------------------------|
| 동일한 타입 슬라이스              | ✅ 가능                        | ❌ 불필요                     |
| 서로 다른 타입을 하나의 벡터에 저장 | ❌ 불가능                      | ✅ 가능                       |
| 성능이 중요한 루프                | ✅ 적합                        | ❌ 피하는 게 좋음             |
| UI 요소, ECS 컴포넌트             | ❌ 불편함                      | ✅ 적합                       |
| 제네릭 함수에서 Trait 사용        | ✅ 자연스러움                   | ❌ 복잡해짐                   |
| 런타임 확장성 (플러그인 등)       | ❌ 제한적                      | ✅ 유리                       |

## ✨ 요약
| 비교 항목         | 정적 디스패치 (`impl Trait`)         | 동적 디스패치 (`dyn Trait`)           |
|------------------|--------------------------------------|----------------------------------------|
| 타입 결정 시점    | 컴파일 시점                           | 런타임                                 |
| 성능              | 빠름 (인라인 최적화 가능)             | 느림 (vtable + heap)                   |
| 유연성            | 낮음 (동일 타입만 처리 가능)          | 높음 (다양한 타입을 Trait로 추상화)   |
| 메모리 할당       | 없음 (스택 기반)                      | 있음 (`Box`, `Rc`, 등으로 힙 할당)     |
| 사용 예시         | 게임 루프, 수치 계산, 제네릭 알고리즘 | UI 위젯, ECS, 플러그인 시스템          |

---

## 🧩 예제: 서로 다른 타입을 Drawable로 처리
```rust
trait Drawable {
    fn draw(&self);
}

struct Circle;
struct Square;

impl Drawable for Circle {
    fn draw(&self) {
        println!("Drawing a circle");
    }
}

impl Drawable for Square {
    fn draw(&self) {
        println!("Drawing a square");
    }
}
```


### ✅ 동적 디스패치: 가능
```rust
fn main() {
    let shapes: Vec<Box<dyn Drawable>> = vec![
        Box::new(Circle),
        Box::new(Square),
    ];

    for shape in shapes {
        shape.draw(); // vtable을 통해 호출
    }
}
```

- Vec<Box<dyn Drawable>>는 서로 다른 타입을 Trait 객체로 묶어서 저장 가능
- 런타임에 draw() 호출 → 동적 디스패치

### ❌ 정적 디스패치: 불가능
```rust
fn draw_all<T: Drawable>(items: &[T]) {
    for item in items {
        item.draw();
    }
}

fn main() {
    let circles = vec![Circle, Circle];
    let squares = vec![Square, Square];

    draw_all(&circles); // OK
    draw_all(&squares); // OK

    // ❌ 아래처럼 서로 다른 타입을 하나의 슬라이스로 묶을 수 없음
    // let mixed = vec![Circle, Square]; // 컴파일 에러!
}
```

- draw_all()은 동일한 타입만 처리 가능
- Vec<T>는 T가 동일해야 함
- 서로 다른 타입을 하나의 슬라이스에 넣을 수 없기 때문에 정적 디스패치로는 불가능

## ✨ 요약
| 상황                                | 정적 디스패치 (`impl Trait`) | 동적 디스패치 (`dyn Trait`) |
|-------------------------------------|-------------------------------|------------------------------|
| 동일한 타입만 처리                  | ✅ 가능                        | ✅ 가능                       |
| 서로 다른 타입을 하나의 벡터에 저장 | ❌ 불가능                      | ✅ 가능                       |
| 런타임 확장성 (플러그인, UI 등)     | ❌ 제한적                      | ✅ 유리                       |

---



## 🧠 왜 dyn이 동적 디스패치일까?
- dyn Trait은 Trait 객체를 의미.
- Trait 객체는 **vtable(가상 함수 테이블)**을 통해 런타임에 메서드를 호출합니다.
- 즉, 어떤 타입인지 컴파일 시점에 확정하지 않고, 런타임에 결정해요.
### 예시
```rust
trait Drawable {
    fn draw(&self);
}

fn draw_all(items: Vec<Box<dyn Drawable>>) {
    for item in items {
        item.draw(); // 동적 디스패치: vtable 통해 호출
    }
}
```
### ✅ 정적 vs 동적 디스패치 비교

| 코드 형태                  | 디스패치 방식     |
|---------------------------|------------------|
| `fn foo(x: impl Trait)`   | 정적 디스패치     |
| `fn foo<T: Trait>(x: T)`  | 정적 디스패치     |
| `Box<dyn Trait>`          | 동적 디스패치     |
| `&dyn Trait`              | 동적 디스패치     |



## 🧠 객체 지향 관점에서의 디스패치 설명
| 개념                  | Rust 정적 디스패치 (`impl Trait`)         | Rust 동적 디스패치 (`dyn Trait`)              |
|-----------------------|--------------------------------------------|-----------------------------------------------|
| 클래스 상속 비유      | 같은 클래스 인스턴스만 저장 가능           | 다양한 서브클래스를 부모 타입으로 저장 가능   |
| 예시 비유             | `Vec<Circle>`만 가능                       | `Vec<Box<Shape>>`에 `Circle`, `Square` 모두 가능 |
| 런타임 다형성         | ❌ 없음                                     | ✅ 있음                                        |
| 메서드 호출 방식      | 컴파일 시점에 결정 (인라인 가능)           | 런타임에 vtable 통해 호출                      |
| 객체 지향 유사성      | 제네릭 기반 템플릿                         | 상속 기반 다형성                              |


## ✨ 비유로 설명하면 이렇게 말할 수 있어요:
“Rust에서 정적 디스패치는 C++ 템플릿처럼 같은 타입만 저장 가능하고,  
동적 디스패치는 Shape*에 Circle이나 Square를 넣는 것처럼  
부모 타입으로 다양한 자식 타입을 저장할 수 있음.”  

---

## 🧠 Rust는 왜 “상속” 대신 “디스패치”를 쓸까?
| 개념 항목             | 객체 지향 언어 (예: C++) | Rust                                | Rust 디스패치 방식         |
|----------------------|--------------------------|-------------------------------------|----------------------------|
| 행위 추상화 방식      | `extends`                | `impl Trait for Type`               | `impl Trait`, `dyn Trait` |
| 다형성 표현           | 부모 클래스 참조         | 트레잇 기반                         | 정적/동적 디스패치         |
| 메서드 호출 방식      | 가상 함수 (virtual)       | 트레잇 메서드                       | 컴파일 또는 런타임 디스패치 |
| 런타임 다형성         | ✅ 있음                   | ❌ 없음 (상속 없음)                 | ✅ `dyn Trait`으로 가능     |


## ✅ Rust의 디스패치 방식
- 정적 디스패치: 컴파일 시점에 타입이 결정됨 (impl Trait, 제네릭)
- 동적 디스패치: 런타임에 타입이 결정됨 (dyn Trait, vtable)
Rust는 상속 대신 트레잇 기반의 디스패치를 통해  
“이 타입이 이 행위를 할 수 있다”는 걸 명시적으로 표현.

## ✨ 객체 지향 개발자에게 설명할 때 이렇게 말할 수 있음:
“Rust는 클래스 상속이 없고, 대신 트레잇을 통해 행위를 추상화.  
그리고 그 행위를 호출할 때는 **디스패치(dispatch)** 라는 방식으로 처리.  
정적 디스패치는 C++ 템플릿처럼, 동적 디스패치는 부모 클래스 포인터처럼 동작.”  

---



