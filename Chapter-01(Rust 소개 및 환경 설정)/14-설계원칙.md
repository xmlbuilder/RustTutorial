# 설계 원칙

## 🧠 핵심 문제: 안전성과 효율성 사이의 균형
| 요소        | 장점                              | 단점                                      | 전략적 접근                         |
|-------------|-----------------------------------|-------------------------------------------|-------------------------------------|
| `lifetime`  | 참조 유효성 보장, 안전성 확보       | 구조 전체에 퍼지면 복잡도 폭증             | 참조 최소화, 소유권 기반 설계        |
| `ownership` | 메모리 자동 관리, 이동/해제 안전    | 이동/복사 설계 어려움, API 경계 설계 부담   | `Box`, `Arc` 등으로 격리             |
| `Clone`     | 간단한 복사, 소유권 회피 가능       | 성능 저하, 메모리 낭비 가능성              | 불변/초기화용에만 전략적으로 사용    |

## 📌 핵심 요약:
- lifetime은 안전하지만 구조에 퍼지면 유지보수가 어려워짐
- ownership은 강력하지만 이동/복사 설계가 까다로움
- Clone은 쉬운 해결책처럼 보이지만 성능을 갉아먹을 수 있음

## 🔧 방향 설정 전략 – 복잡성 최소화 + 효율성 유지
### ✅ 1. 소유권 우선, 참조 최소화
- 구조체 내부는 String, Vec, Box, Arc 등 소유권 기반 타입으로 설계
- &str, &T는 API 경계에서만 사용 → 내부로 끌어들이지 않음
### ✅ 2. Clone은 전략적으로만 사용
- 불변 데이터, 설정값, 초기화용 값 등은 Clone 허용
- 빈번한 복사나 대용량 데이터는 Arc, Rc, Cow로 공유
### ✅ 3. Cow<'a, T>는 반환용으로만 사용
- 구조체 필드에 넣으면 lifetime이 퍼짐
- API에서 “참조 또는 소유”를 선택할 수 있게 할 때만 사용
### ✅ 4. 스마트 포인터로 lifetime 격리
- Box<T> → 힙에 저장, 이동 가능
- Arc<T> → 스레드 안전한 공유
- Arc<Mutex<T>> → 공유 + 변경 가능

### ✨ 실전 설계 예: 효율성과 안전성의 균형
```rust
use std::sync::Arc;
struct Config {
    name: Arc<String>,       // 공유 가능, Clone 없이 참조 가능
    values: Box<[i32]>,      // 힙에 저장, 이동 가능
    cache: Option<Arc<Vec<u8>>>, // 필요 시만 초기화
}
```
- Arc로 공유하면서 Clone 최소화
- Box로 소유권 유지하면서 lifetime 제거
- Option으로 초기화 시점 제어

## 💡 요약 – 설계 방향
| 요소        | 전략 또는 선택지         |
|-------------|---------------------------|
| `Clone`     | 전략적으로만 사용         |
| 소유권 유지 | `Box`, `Arc`, `Cow` 활용  |
| 참조 최소화 | 구조체 내부에는 피하고 API 경계에서만 사용 |

### 📌 핵심:
- Clone은 불변 데이터나 초기화용으로만 제한적으로 사용
- Box, Arc, Cow는 lifetime을 격리하고 소유권을 유지하는 데 효과적
- 구조체 내부는 소유권 기반으로 설계하고, 참조는 외부에서만 제한적으로 사용

---

# Cow 사용법

Cow<'a, T>는 Clone-on-write의 줄임말로, 참조(&T)와 소유(T)를 하나의 타입으로 표현할 수 있는 아주 유용한 도구.  
특히 API 반환값에서 lifetime을 최소화하면서도 유연성을 확보할 때 빛을 발합니다.

## ✅ 실전 예: Cow<'a, str>을 반환하는 함수
```rust
use std::borrow::Cow;
fn normalize_name<'a>(input: &'a str) -> Cow<'a, str> {
    if input.contains(' ') {
        // 공백이 있으면 소유권을 가진 새 String을 만들어 반환
        Cow::Owned(input.replace(' ', "_"))
    } else {
        // 공백이 없으면 원래 참조를 그대로 반환
        Cow::Borrowed(input)
    }
}
```

## 🔍 사용 예
```rust
fn main() {
    let raw = "Jung Hwan";
    let name = normalize_name(raw);
    println!("Normalized: {}", name); // Jung_Hwan

    let raw2 = "JungHwan";
    let name2 = normalize_name(raw2);
    println!("Normalized: {}", name2); // JungHwan
}
```

## 💡 이 방식의 장점 – Cow<'a, str> 반환
| 상황               | 반환 형태              | 장점                                | 설명                                      |
|--------------------|------------------------|-------------------------------------|-------------------------------------------|
| 수정 불필요         | `Cow::Borrowed(&str)`  | 성능 최적화                         | 원본 참조 그대로 사용 → 복사 없음          |
| 수정 필요           | `Cow::Owned(String)`   | 안전한 소유권 확보                  | 새로 만든 값 반환 → lifetime 격리 가능     |

## 📌 핵심:
- Cow는 참조와 소유를 하나의 타입으로 표현
- API에서 불필요한 Clone을 피하면서도 유연한 반환 가능
- 구조체 내부에 넣는 건 위험하지만, 반환값으로는 매우 효과적

- 사용자는 Cow를 그대로 &str처럼 사용 가능
- 불필요한 Clone을 피하면서도 유연한 API 제공

## ✨ 요약
```rust
fn process<'a>(input: &'a str) -> Cow<'a, str> {
    if 조건 { Cow::Owned(…) } else { Cow::Borrowed(input) }
}
```
- Cow는 참조와 소유를 동시에 표현할 수 있는 타입
- 반환값에서 lifetime을 최소화하면서도 효율성과 유연성을 확보할 수 있음

## 소유권 확인
Cow<'a, T>는 내부적으로 Borrowed(&T) 또는 Owned(T)를 가지고 있기 때문에,  
소유권이 있는지 없는지는 런타임에 is_owned() 메서드로 확인할 수 있음.

### ✅ Cow의 소유 여부 확인 방법
```rust
use std::borrow::Cow;
fn normalize_name<'a>(input: &'a str) -> Cow<'a, str> {
    if input.contains(' ') {
        Cow::Owned(input.replace(' ', "_"))
    } else {
        Cow::Borrowed(input)
    }
}

fn main() {
    let raw = "Jung Hwan";
    let name = normalize_name(raw);
    println!("Normalized: {}", name);
    println!("name is owned? {}", name.is_owned()); // true

    let raw2 = "JungHwan";
    let name2 = normalize_name(raw2);
    println!("Normalized: {}", name2);
    println!("name2 is owned? {}", name2.is_owned()); // false
}
```

## 🔍 결과 – Cow<'a, str> 반환값의 소유 여부
| 변수    | 값           | `is_owned()` |
|---------|--------------|--------------|
| `name`  | "Jung_Hwan"  | `true`       |
| `name2` | "JungHwan"   | `false`      |

- name은 공백이 있어서 String으로 새로 만들어졌기 때문에 소유권 있음
- name2는 원본 참조 그대로 사용했기 때문에 소유권 없음

## 💡 요약 – Cow<'a, T> 소유 여부 확인
| 메서드           | 내부 상태           | 반환값       |
|------------------|---------------------|--------------|
| `is_owned()`     | `Cow::Owned(T)`     | `true` / `false` |
| `is_borrowed()`  | `Cow::Borrowed(&T)` | `true` / `false` |

## 📌 핵심:
- is_owned() → 내부가 Owned(T)일 때 true
- is_borrowed() → 내부가 Borrowed(&T)일 때 true
- 두 메서드는 런타임에 소유 여부를 안전하게 판단할 수 있게 해줍니다

---

# Cow 값 추출 하기

Cow<'a, T>는 Deref 트레이트를 구현하고 있어서 unwrap 없이도 마치 &T처럼 바로 사용할 수 있습니다.

## ✅ 핵심 요약 – Cow<'a, T> 사용 방식
| 기능              | 설명                                      |
|-------------------|-------------------------------------------|
| `Cow<'a, T>: Deref<T>` | `*cow`, `cow.method()`처럼 바로 사용 가능       |
| `unwrap()`        | `Cow`에는 필요 없음 (`Result`, `Option`에만 해당) |
| `into_owned()`    | `T` 타입으로 소유권 확보 (`String`, `Vec`, 등)     |

## 🔧 실전 예
```rust
use std::borrow::Cow;

fn normalize_name<'a>(input: &'a str) -> Cow<'a, str> {
    if input.contains(' ') {
        Cow::Owned(input.replace(' ', "_"))
    } else {
        Cow::Borrowed(input)
    }
}

fn main() {
    let name = normalize_name("Jung Hwan");

    // ✅ 바로 사용 가능
    println!("Normalized: {}", name);          // Deref로 &str처럼 사용
    println!("Length: {}", name.len());        // &str 메서드 호출 가능
    println!("First char: {}", name.chars().next().unwrap());

    // ❌ unwrap()은 필요 없음
    // ✅ 소유권이 필요할 때만 into_owned()
    let owned: String = name.into_owned();     // 여기서만 복사 발생
}
```

## 💡 요약 – Cow<'a, T> 사용 방식
| 기능            | 설명                                      |
|-----------------|-------------------------------------------|
| `Deref`         | `&T`처럼 바로 사용 가능 (`cow.len()`, `cow.chars()`) |
| `into_owned()`  | `String` 등으로 소유권 확보 (복사 발생)     |
| `is_owned()`    | 내부가 `Owned(T)`인지 확인 가능 (`true`/`false`) |

## 📌 결론:
Cow는 unwrap 없이 바로 사용 가능하며, 소유권이 필요할 때만 into_owned()을 호출하면 됩니다.

## 소유권 이전
```rust
let owned: String = name.into_owned();
```
이 코드는 Cow<'a, str> 타입인 name에서 소유권을 가진 String을 추출.
그리고 그 이후에는 name 자체는 스코프를 벗어나면 drop되고, owned는 새로운 String으로 살아남습니다.

### 🔍 내부 동작 흐름
- name이 Cow::Borrowed(&str)이면 → String::from(&str)로 복사
- name이 Cow::Owned(String)이면 → String을 move해서 반환
- name은 이후 사용 불가 (move 발생)

### ✅ 예시로 확인
```rust
use std::borrow::Cow;
fn main() {
    let name: Cow<str> = Cow::Owned("Jung Hwan".to_string());
    let owned: String = name.into_owned(); // move 발생

    // println!("{}", name); // ❌ error: value moved
    println!("{}", owned); // ✅ "Jung Hwan"
}
```

## 💡 요약 – Cow<'a, T> → into_owned() 흐름
| 단계           | 설명                                      |
|----------------|-------------------------------------------|
| `into_owned()` | `Cow<'a, T>` → `T`로 소유권 확보             |
| `name`         | `Cow<'a, T>` → 이후 move되어 더 이상 사용 불가 |
| `owned`        | `T` 타입 (`String`, `Vec`, 등) → 자유롭게 사용 가능 |


---



