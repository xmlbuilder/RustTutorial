# DMatrix / SMatrix

## ğŸ§® DMatrix í•µì‹¬ í•¨ìˆ˜ ìš”ì•½ ë° ìƒ˜í”Œ

### âœ… ê¸°ë³¸ ì„¤ì •
```rust
use nalgebra::{DMatrix, DVector};
```

### âœ… 1. Identity í–‰ë ¬ ìƒì„±
```rust
use nalgebra::DMatrix;

fn main() {
    let identity = DMatrix::<f64>::identity(3, 3);
    println!("Identity matrix:\n{}", identity);
}
```

- í•¨ìˆ˜: DMatrix::identity(rows, cols)
- ì„¤ëª…: ë‹¨ìœ„ í–‰ë ¬ ìƒì„± (ì •ë°©í–‰ë ¬ë§Œ ì˜ë¯¸ ìˆìŒ)

### âœ… 2. ì „ì¹˜ (Transpose)
```rust
fn main() {
    let m = DMatrix::from_row_slice(2, 3, &[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]);
    let transposed = m.transpose();
    println!("Transposed:\n{}", transposed);
}
```

- í•¨ìˆ˜: matrix.transpose()
- ì„¤ëª…: í–‰ê³¼ ì—´ì„ ë’¤ë°”ê¿ˆ

### âœ… 3. ì—­í–‰ë ¬ (Inverse)
```rust
fn main() {
    let m = DMatrix::from_row_slice(2, 2, &[4.0, 7.0, 2.0, 6.0]);
    if let Some(inv) = m.try_inverse() {
        println!("Inverse:\n{}", inv);
    } else {
        println!("Matrix is not invertible.");
    }
}
```

- í•¨ìˆ˜: matrix.try_inverse()
- ì„¤ëª…: ì—­í–‰ë ¬ ë°˜í™˜ (ì •ë°©í–‰ë ¬ë§Œ ê°€ëŠ¥, ì‹¤íŒ¨ ì‹œ None)

### âœ… 4. íŠ¹ì • í–‰(row) ì¶”ì¶œ
```rust
fn main() {
    let m = DMatrix::from_row_slice(3, 3, &[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]);
    let row = m.row(1); // ë‘ ë²ˆì§¸ í–‰
    println!("Row 1: {}", row);
}
```

- í•¨ìˆ˜: matrix.row(index)
- ì„¤ëª…: RowVectorë¡œ ë°˜í™˜ë¨

### âœ… 5. íŠ¹ì • ì—´(column) ì¶”ì¶œ
```rust
fn main() {
    let m = DMatrix::from_row_slice(3, 3, &[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]);
    let col = m.column(2); // ì„¸ ë²ˆì§¸ ì—´
    println!("Column 2: {}", col);
}
```

- í•¨ìˆ˜: matrix.column(index)
- ì„¤ëª…: Vectorë¡œ ë°˜í™˜ë¨

### âœ… 6. í–‰ë ¬ ê³±ì…ˆ
```rust
fn main() {
    let a = DMatrix::from_row_slice(2, 3, &[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]);
    let b = DMatrix::from_row_slice(3, 2, &[7.0, 8.0, 9.0, 10.0, 11.0, 12.0]);
    let product = &a * &b;
    println!("Product:\n{}", product);
}
```

- ì—°ì‚°ì: *
- ì„¤ëª…: í–‰ë ¬ ê³± (ë‚´ì  ê·œì¹™ì— ë”°ë¼ í¬ê¸° ë§ì•„ì•¼ í•¨)

### âœ… 7. í–‰ë ¬ í•©/ì°¨
```rust
fn main() {
    let a = DMatrix::from_element(2, 2, 1.0);
    let b = DMatrix::from_element(2, 2, 2.0);
    let sum = &a + &b;
    let diff = &a - &b;
    println!("Sum:\n{}", sum);
    println!("Difference:\n{}", diff);
}
```

- ì—°ì‚°ì: +, -
- ì„¤ëª…: ê°™ì€ í¬ê¸°ì˜ í–‰ë ¬ë¼ë¦¬ë§Œ ê°€ëŠ¥

### âœ… 8. ìŠ¤ì¹¼ë¼ ê³±/ë‚˜ëˆ—ì…ˆ
```rust
fn main() {
    let m = DMatrix::from_element(2, 2, 3.0);
    let scaled = &m * 2.0;
    let divided = &m / 3.0;
    println!("Scaled:\n{}", scaled);
    println!("Divided:\n{}", divided);
}
```

- ì—°ì‚°ì: *, /
- ì„¤ëª…: ëª¨ë“  ì›ì†Œì— ëŒ€í•´ ìŠ¤ì¹¼ë¼ ì—°ì‚°

## ğŸ“Œ ì°¸ê³ 
- DMatrixëŠ” ë™ì  í¬ê¸° í–‰ë ¬ë¡œ, ëŸ°íƒ€ì„ì— í¬ê¸°ë¥¼ ì§€ì •í•  ìˆ˜ ìˆì–´ìš”.
- SMatrixëŠ” ì •ì  í¬ê¸° í–‰ë ¬ë¡œ, ì»´íŒŒì¼ íƒ€ì„ì— í¬ê¸°ê°€ ê³ ì •ë©ë‹ˆë‹¤.
- try_inverse()ëŠ” ì‹¤íŒ¨ ê°€ëŠ¥ì„±ì´ ìˆìœ¼ë¯€ë¡œ í•­ìƒ Option ì²˜ë¦¬ í•„ìš”í•©ë‹ˆë‹¤.


## ğŸ§® SMatrix í•µì‹¬ í•¨ìˆ˜ ìš”ì•½ ë° ìƒ˜í”Œ

### âœ… ê¸°ë³¸ ì„¤ì •
```rust
use nalgebra::{SMatrix, SVector};
```


### ğŸ§® 1. Identity í–‰ë ¬
```rust
fn identity_example() {
    let identity: SMatrix<f64, 3, 3> = SMatrix::identity();
    println!("Identity matrix:\n{}", identity);
}
```


### ğŸ”„ 2. ì „ì¹˜ (Transpose)
```rust
fn transpose_example() {
    let m = SMatrix::<f64, 2, 3>::from_row_slice(&[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]);
    let transposed = m.transpose();
    println!("Transposed:\n{}", transposed);
}
```

### ğŸ” 3. ì—­í–‰ë ¬ (Inverse)
```rust
fn inverse_example() {
    let m = SMatrix::<f64, 2, 2>::from_row_slice(&[4.0, 7.0, 2.0, 6.0]);
    if let Some(inv) = m.try_inverse() {
        println!("Inverse:\n{}", inv);
    } else {
        println!("Matrix is not invertible.");
    }
}
```

### ğŸ“ 4. íŠ¹ì • í–‰/ì—´ ì¶”ì¶œ
```rust
fn row_col_example() {
    let m = SMatrix::<f64, 3, 3>::from_row_slice(&[
        1.0, 2.0, 3.0,
        4.0, 5.0, 6.0,
        7.0, 8.0, 9.0,
    ]);
    let row = m.row(1);
    let col = m.column(2);
    println!("Row 1: {}", row);
    println!("Column 2: {}", col);
}
```


### âœ–ï¸ 5. í–‰ë ¬ ê³±ì…ˆ
```rust
fn multiplication_example() {
    let a = SMatrix::<f64, 2, 3>::from_row_slice(&[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]);
    let b = SMatrix::<f64, 3, 2>::from_row_slice(&[7.0, 8.0, 9.0, 10.0, 11.0, 12.0]);
    let product = a * b;
    println!("Product:\n{}", product);
}
```


### â•â– 6. í–‰ë ¬ í•©/ì°¨
```rust
fn add_sub_example() {
    let a = SMatrix::<f64, 2, 2>::from_element(1.0);
    let b = SMatrix::<f64, 2, 2>::from_element(2.0);
    let sum = a + b;
    let diff = a - b;
    println!("Sum:\n{}", sum);
    println!("Difference:\n{}", diff);
}
```


### ğŸ”¢ 7. ìŠ¤ì¹¼ë¼ ê³±/ë‚˜ëˆ—ì…ˆ
```rust
fn scalar_example() {
    let m = SMatrix::<f64, 2, 2>::from_element(3.0);
    let scaled = m * 2.0;
    let divided = m / 3.0;
    println!("Scaled:\n{}", scaled);
    println!("Divided:\n{}", divided);
}
```

## ğŸ§  ìš”ì•½ ë¹„êµ
| ê¸°ëŠ¥             | DMatrix ì‚¬ìš© ì˜ˆì‹œ      | SMatrix ì‚¬ìš© ì˜ˆì‹œ   | ì°¨ì´ì  ë° íŠ¹ì§•     |
|------------------|-------------------------|-----------------|-----------------------|
| ë‹¨ìœ„ í–‰ë ¬ ìƒì„±    | DMatrix::<f64>::identity(3, 3)   | SMatrix::<f64, 3, 3>::identity()   | DMatrixëŠ” ëŸ°íƒ€ì„ í¬ê¸°, SMatrixëŠ” ì»´íŒŒì¼ íƒ€ì„ ê³ ì • í¬ê¸° |
| í–‰/ì—´ ì¶”ì¶œ       | .row(i), .column(j)      | .row(i), .column(j)   | ì‚¬ìš© ë°©ì‹ ë™ì¼, ë°˜í™˜ íƒ€ì…ì€ ê³ ì • í¬ê¸° ì—¬ë¶€ì— ë”°ë¼ ë‹¤ë¦„ |
| ì—­í–‰ë ¬ ê³„ì‚°       | .try_inverse()        | .try_inverse()             | ì •ë°©í–‰ë ¬ì¼ ë•Œë§Œ ê°€ëŠ¥, SMatrixëŠ” ì„±ëŠ¥ìƒ ë” ë¹ ë¦„         |

---

# slice ì‚¬ìš©

```rust
let m = SMatrix::<f64, 2, 3>::from_row_slice(&[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]);
```
ì„ì‹œ ìŠ¬ë¼ì´ìŠ¤ ë¦¬í„°ëŸ´ì„ ì°¸ì¡°í•´ì„œ ê°’ì„ ë³µì‚¬í•˜ëŠ” ë°©ì‹
## âœ… ëª©ì : ì™¸ë¶€ heap ë°ì´í„°ë¥¼ ë§Œë“¤ì§€ ì•Šê³ , ì†Œìœ ê¶Œë„ ë„˜ê¸°ì§€ ì•Šê¸° ìœ„í•´
- &[1.0, ...]ëŠ” ì„ì‹œë¡œ ìŠ¤íƒì— ìƒì„±ëœ ìŠ¬ë¼ì´ìŠ¤.
- from_row_slice()ëŠ” ê·¸ ê°’ì„ ë³µì‚¬í•´ì„œ SMatrix ë‚´ë¶€ì— ì €ì¥í•˜ê³ , ì›ë³¸ì€ ë°”ë¡œ dropë©ë‹ˆë‹¤.
- ì¦‰, heapì— ë”°ë¡œ ë²¡í„°ë¥¼ ë§Œë“¤ í•„ìš” ì—†ì´, ì§§ê²Œ ì“°ê³  ë²„ë¦¬ëŠ” ë°©ì‹.  

&[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]ì²˜ëŸ¼ ë¦¬í„°ëŸ´ ë°°ì—´ì„ ì°¸ì¡°í•˜ëŠ” ê²½ìš°, RustëŠ” ì´ ë°ì´í„°ë¥¼ **ìŠ¤íƒ(stack)** ì— ì €ì¥í•©ë‹ˆë‹¤.

## âœ… ì •ë¦¬í•˜ë©´
- [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]  
    â†’ ìŠ¤íƒì— ì €ì¥ëœ ê³ ì • í¬ê¸° ë°°ì—´ ([f64; 6])
- &[...]  
    â†’ ì´ ë°°ì—´ì— ëŒ€í•œ ë¶ˆë³€ ì°¸ì¡° (&[f64])
- from_row_slice(&[...])  
    â†’ ì´ ì°¸ì¡°ëœ ë°ì´í„°ë¥¼ ë³µì‚¬í•´ì„œ SMatrix ë‚´ë¶€ì— ì €ì¥
- í•¨ìˆ˜ í˜¸ì¶œì´ ëë‚˜ë©´  
    â†’ ì´ ì„ì‹œ ë°°ì—´ì€ dropë˜ê³  ì‚¬ë¼ì§ (í•˜ì§€ë§Œ ì´ë¯¸ ë³µì‚¬ëê¸° ë•Œë¬¸ì— ë¬¸ì œ ì—†ìŒ)

## ğŸ’¡ ì°¸ê³ : heapì— ì•ˆ ì˜¬ë¼ê°€ëŠ” ì´ìœ 
RustëŠ” [T; N]ì²˜ëŸ¼ í¬ê¸°ê°€ ê³ ì •ëœ ë°°ì—´ì€ ìŠ¤íƒì— ì €ì¥í•©ë‹ˆë‹¤.  
heapì— ì˜¬ë¼ê°€ë ¤ë©´ Box<[T]>, Vec<T> ê°™ì€ ë™ì  í¬ê¸° ì»¨í…Œì´ë„ˆë¥¼ ì”€.

## ğŸ” ì˜ˆì‹œ ë¹„êµ
| í‘œí˜„ì‹                        | ì €ì¥ ìœ„ì¹˜ | ì†Œìœ ê¶Œ ìˆìŒ? | íŠ¹ì§• ì„¤ëª…                                                                 |
|------------------------------|------------|---------------|---------------------------------------------------------------------------|
| [1.0, 2.0, 3.0]              | ìŠ¤íƒ       | âœ… ìˆìŒ        | ê³ ì • í¬ê¸° ë°°ì—´. ìŠ¤íƒì— ì§ì ‘ ì €ì¥ë˜ë©° ë¹ ë¦„                                 |
| &[1.0, 2.0, 3.0]            | ìŠ¤íƒ ì°¸ì¡°  | âŒ ì—†ìŒ        | ìŠ¤íƒì— ìˆëŠ” ë°°ì—´ì„ ì°¸ì¡°. ê°’ì€ ë³µì‚¬ë˜ì§€ ì•ŠìŒ                              |
| vec![1.0, 2.0, 3.0]         | í™         | âœ… ìˆìŒ        | ë™ì  í¬ê¸°. heapì— ì €ì¥ë˜ë©° í¬ê¸° ë³€ê²½ ê°€ëŠ¥                                 |
| Box::new([1.0, 2.0, 3.0])   | í™         | âœ… ìˆìŒ        | ê³ ì • í¬ê¸° ë°°ì—´ì„ heapì— ì €ì¥. ì†Œìœ ê¶Œ ìˆìŒ                                 |

## âš¡ ì™œ ì†ë„ê°€ ë¹ ë¥¼ê¹Œ?
| ìš”ì†Œ           | ì„¤ëª…                                                                 |
|----------------|----------------------------------------------------------------------|
| [f64; N]       | ê³ ì • í¬ê¸° ë°°ì—´ â†’ ìŠ¤íƒì— ì €ì¥ë¨ â†’ í• ë‹¹/í•´ì œ ë¹„ìš©ì´ ê±°ì˜ ì—†ìŒ              |
| f64            | Copy íŠ¸ë ˆì‡ì„ êµ¬í˜„í•œ ì›ì‹œ íƒ€ì… â†’ ë³µì‚¬ ë¹„ìš©ì´ ë§¤ìš° ë‚®ìŒ                    |
| &[...]         | ì°¸ì¡°ë§Œ ë„˜ê¹€ â†’ ì†Œìœ ê¶Œ ì´ë™ ì—†ìŒ â†’ heap í• ë‹¹ ì—†ì´ ë¹ ë¥´ê²Œ ì²˜ë¦¬ ê°€ëŠ¥          |

## ì´ ì¡°í•© ë•ë¶„ì— SMatrix::from_row_slice(&[...]) ê°™ì€ ì½”ë“œëŠ”
- âœ”ï¸ ë¹ ë¥´ê³ 
- âœ”ï¸ ì•ˆì „í•˜ê³ 
-= âœ”ï¸ ë©”ëª¨ë¦¬ ë‚­ë¹„ë„ ì—†ì–´ìš”

## âœ… ì‹¤ì „ì—ì„œ ì™œ ì´ë ‡ê²Œ ì“°ëŠ”ê°€?
- í…ŒìŠ¤íŠ¸ ì½”ë“œ, ë²¤ì¹˜ë§ˆí¬, ìƒ˜í”Œ ìƒì„± ë“±ì—ì„œ ë¹ ë¥´ê²Œ ë°ì´í„°ë¥¼ ë„˜ê¸°ê³  ì‹¶ì„ ë•Œ
- heapì— ë²¡í„°ë¥¼ ë§Œë“¤ í•„ìš” ì—†ì´ ê°„ë‹¨í•˜ê²Œ SMatrixë‚˜ SVectorë¥¼ ì´ˆê¸°í™”í•  ë•Œ
- ì†Œìœ ê¶Œì„ ë„˜ê¸°ì§€ ì•Šê³  ì•ˆì „í•˜ê²Œ ë³µì‚¬ë§Œ í•˜ê³  ì‹¶ì„ ë•Œ

## ğŸ’¡ ì˜ˆì‹œ ë¹„êµ
```rust
let m = SMatrix::<f64, 2, 3>::from_row_slice(&[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]);
// ë¹ ë¥´ê³  ì•ˆì „. ìŠ¤íƒì— ì ê¹ ìƒì„±ëœ ë°°ì—´ì„ ë³µì‚¬í•´ì„œ ì‚¬ìš©
```

### vec ì‚¬ìš©
```rust
let data = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0];
let m = SMatrix::<f64, 2, 3>::from_row_slice(&data);
// heapì— ìˆëŠ” ë°ì´í„°ë¥¼ ë³µì‚¬. ì„±ëŠ¥ì€ ê´œì°®ì§€ë§Œ ë©”ëª¨ë¦¬ ê´€ë¦¬ê°€ ë” ë³µì¡
```



