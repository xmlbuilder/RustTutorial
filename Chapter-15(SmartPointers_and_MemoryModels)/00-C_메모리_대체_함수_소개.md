# C 메모리 관련 함수 대체
## 🧪 C vs Rust: 메모리 함수 비교 예시
### 1. memcpy → copy_from_slice
```cpp
// C
memcpy(dest, src, len);
```

```rust
// Rust
dest[..len].copy_from_slice(&src[..len]);
```
- ✅ Rust는 경계 검사와 타입 안전을 보장

### 2. memcmp → == 또는 slice::eq
```cpp
// C
int result = memcmp(a, b, len);
```

```rust
// Rust
let result = &a[..len] == &b[..len];
```
- ✅ Rust는 직접 비교로 간결하고 안전하게 처리


### 3. memset → fill 또는 vec![value; len]
```cpp
// C
memset(arr, 0, len);
```

```rust
// Rust
arr.fill(0); // 기존 배열
let arr = vec![0u8; len]; // 새 벡터 생성
```

- ✅ Rust는 타입 기반 초기화로 안전하게 처리


### 4. strcpy → String::from 또는 .to_string()
```cpp
// C
char dest[100];
strcpy(dest, src);
```

```rust
// Rust
let dest = src.to_string(); // 또는 String::from(src)
```

- ✅ Rust는 소유권 기반으로 복사 처리


### 5. strlen → .len() (UTF-8 주의)
```cpp
// C
size_t len = strlen(str);
```

```rust
// Rust
let len = str.len(); // 바이트 길이
let char_len = str.chars().count(); // 문자 길이
```

- ✅ Rust는 UTF-8 기반이므로 문자 길이와 바이트 길이 구분 필요


### 6. strncpy → get(..).unwrap_or("")
```cpp
// C
strncpy(dest, src, n);
```

```rust
// Rust
let dest = &src[..n.min(src.len())];
```

- ✅ Rust는 슬라이스로 안전하게 경계 처리


### 7. memmove → copy_within
```cpp
// C
memmove(dest, src, len);
```

```rust
// Rust
vec.copy_within(src_range, dest_start);
```

- ✅ Rust는 내부 복사도 안전하게 처리


### 8. calloc → vec![0; len]
```cpp
// C
int* arr = calloc(len, sizeof(int));
```

```rust
// Rust
let arr = vec![0; len];
```

- ✅ Rust는 타입 기반 초기화로 안전하게 메모리 할당


### 9. realloc → Vec::resize
```cpp
// C
arr = realloc(arr, new_size);
```

```rust
// Rust
arr.resize(new_size, 0);

```
- ✅ Rust는 자동 메모리 관리로 안전하게 크기 조절


### 10. free → 자동 drop
```cpp
// C
free(ptr);
```

```rust
// Rust
// 변수 범위를 벗어나면 자동으로 drop됨
```

- ✅ Rust는 소유권 시스템으로 메모리 해제를 자동 처리


## ✅ 결론
Rust는 C의 저수준 메모리 함수를 대부분 안전하고 직관적인 방식으로 대체할 수 있습니다.  
unsafe를 쓰지 않고도 성능과 안정성을 동시에 확보할 수 있음. 

